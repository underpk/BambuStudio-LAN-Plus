From beb960c818a12def8fd3b0c21b7ca813c94e7c60 Mon Sep 17 00:00:00 2001
From: Local Build <local@build.local>
Date: Thu, 18 Dec 2025 09:04:56 +0700
Subject: [PATCH] Add LAN device rename feature

- Added set_local_dev_nickname/get_local_dev_nickname methods to MachineObject
- Modified modify_device_name to save locally for LAN devices
- Enabled edit button for LAN devices with access rights
- Load saved nicknames when LAN devices are discovered
---
 src/slic3r/GUI/DeviceCore/DevManager.cpp |  902 ++++
 src/slic3r/GUI/DeviceManager.cpp         | 5429 ++++++++++++++++++++++
 src/slic3r/GUI/DeviceManager.hpp         |  901 ++++
 src/slic3r/GUI/SelectMachinePop.cpp      | 1094 +++++
 4 files changed, 8326 insertions(+)
 create mode 100644 src/slic3r/GUI/DeviceCore/DevManager.cpp
 create mode 100644 src/slic3r/GUI/DeviceManager.cpp
 create mode 100644 src/slic3r/GUI/DeviceManager.hpp
 create mode 100644 src/slic3r/GUI/SelectMachinePop.cpp

diff --git a/src/slic3r/GUI/DeviceCore/DevManager.cpp b/src/slic3r/GUI/DeviceCore/DevManager.cpp
new file mode 100644
index 0000000..5b69a1d
--- /dev/null
+++ b/src/slic3r/GUI/DeviceCore/DevManager.cpp
@@ -0,0 +1,902 @@
+#include <nlohmann/json.hpp>
+#include "DevInfo.h"
+#include "DevManager.h"
+#include "DevUtil.h"
+
+// TODO: remove this include
+#include "slic3r/GUI/DeviceManager.hpp"
+#include "slic3r/GUI/I18N.hpp"
+#include "slic3r/GUI/GUI_App.hpp"
+#include "slic3r/Utils/BBLUtil.hpp"
+
+#include "libslic3r/Time.hpp"
+
+using namespace nlohmann;
+
+namespace Slic3r
+{
+    DeviceManager::DeviceManager(NetworkAgent* agent)
+    {
+        m_agent = agent;
+        m_refresher = new DeviceManagerRefresher(this);
+
+        DevPrinterConfigUtil::InitFilePath(resources_dir());
+    }
+
+    DeviceManager::~DeviceManager()
+    {
+        delete m_refresher;
+
+        for (auto it = localMachineList.begin(); it != localMachineList.end(); it++)
+        {
+            if (it->second)
+            {
+                delete it->second;
+                it->second = nullptr;
+            }
+        }
+        localMachineList.clear();
+
+        for (auto it = userMachineList.begin(); it != userMachineList.end(); it++)
+        {
+            if (it->second)
+            {
+                delete it->second;
+                it->second = nullptr;
+            }
+        }
+        userMachineList.clear();
+    }
+
+
+    void DeviceManager::EnableMultiMachine(bool enable)
+    {
+        m_agent->enable_multi_machine(enable);
+        m_enable_mutil_machine = enable;
+    }
+
+    void DeviceManager::start_refresher() { m_refresher->Start(); }
+    void DeviceManager::stop_refresher() { m_refresher->Stop(); }
+
+
+    void DeviceManager::keep_alive()
+    {
+        MachineObject* obj = this->get_selected_machine();
+        if (obj)
+        {
+            if (obj->keep_alive_count == 0)
+            {
+                obj->last_keep_alive = std::chrono::system_clock::now();
+            }
+            obj->keep_alive_count++;
+            std::chrono::system_clock::time_point start = std::chrono::system_clock::now();
+            auto internal = std::chrono::duration_cast<std::chrono::milliseconds>(start - obj->last_keep_alive);
+            if (internal.count() > TIMEOUT_FOR_KEEPALIVE && (internal.count() < 1000 * 60 * 60 * 300))
+            {
+                BOOST_LOG_TRIVIAL(info) << "keep alive = " << internal.count() << ", count = " << obj->keep_alive_count;
+                obj->command_request_push_all();
+                obj->last_keep_alive = start;
+            }
+            else if (obj->m_push_count == 0)
+            {
+                BOOST_LOG_TRIVIAL(info) << "keep alive = " << internal.count() << ", push_count = 0, count = " << obj->keep_alive_count;
+                obj->command_request_push_all();
+                obj->last_keep_alive = start;
+            }
+        }
+    }
+
+    void DeviceManager::check_pushing()
+    {
+        keep_alive();
+        MachineObject* obj = this->get_selected_machine();
+
+        std::chrono::system_clock::time_point start = std::chrono::system_clock::now();
+        auto internal = std::chrono::duration_cast<std::chrono::milliseconds>(start - obj->last_update_time);
+
+        if (obj && !obj->is_support_mqtt_alive)
+        {
+            if (internal.count() > TIMEOUT_FOR_STRAT && internal.count() < 1000 * 60 * 60 * 300)
+            {
+                BOOST_LOG_TRIVIAL(info) << "command_pushing: diff = " << internal.count();
+                obj->command_pushing("start");
+            }
+        }
+    }
+
+    void DeviceManager::on_machine_alive(std::string json_str)
+    {
+        try {
+            json j = json::parse(json_str);
+            std::string dev_name        = j["dev_name"].get<std::string>();
+            std::string dev_id          = j["dev_id"].get<std::string>();
+            std::string dev_ip          = j["dev_ip"].get<std::string>();
+            std::string printer_type_str= j["dev_type"].get<std::string>();
+            std::string printer_signal  = j["dev_signal"].get<std::string>();
+            std::string connect_type    = j["connect_type"].get<std::string>();
+            std::string bind_state      = j["bind_state"].get<std::string>();
+
+            if (connect_type == "farm") {
+                connect_type ="lan";
+                bind_state   = "free";
+            }
+
+            std::string sec_link = "";
+            std::string ssdp_version = "";
+            if (j.contains("sec_link")) {
+                sec_link = j["sec_link"].get<std::string>();
+            }
+            if (j.contains("ssdp_version")) {
+                ssdp_version = j["ssdp_version"].get<std::string>();
+            }
+            std::string connection_name = "";
+            if (j.contains("connection_name")) {
+                connection_name = j["connection_name"].get<std::string>();
+            }
+
+            MachineObject* obj;
+
+            /* update userMachineList info */
+            auto it = userMachineList.find(dev_id);
+            if (it != userMachineList.end()) {
+                if (it->second->get_dev_ip() != dev_ip ||
+                    it->second->bind_state != bind_state ||
+                    it->second->bind_sec_link != sec_link ||
+                    it->second->connection_type() != connect_type ||
+                    it->second->bind_ssdp_version != ssdp_version)
+                {
+                    if (it->second->bind_state != bind_state) {
+                        OnMachineBindStateChanged(it->second, bind_state);
+                    }
+
+                    it->second->set_dev_ip(dev_ip);
+                    it->second->bind_state          = bind_state;
+                    it->second->bind_sec_link       = sec_link;
+                    it->second->GetInfo()->SetConnectionType(connect_type);
+                    it->second->bind_ssdp_version   = ssdp_version;
+                    BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " UpdateUserMachineInfo"
+                        << ", dev_id= " << BBLCrossTalk::Crosstalk_DevId(dev_id)
+                        << ", ip = "  << BBLCrossTalk::Crosstalk_DevIP(dev_ip)
+                        << ", printer_name= " << BBLCrossTalk::Crosstalk_DevName(dev_name)
+                        << ", con_type= " << connect_type << ", signal= " << printer_signal
+                        << ", bind_state= " << bind_state;
+                }
+            }
+
+            /* update localMachineList */
+            it = localMachineList.find(dev_id);
+            if (it != localMachineList.end()) {
+                // update properties
+                /* ip changed */
+                obj = it->second;
+
+                if (obj->get_dev_ip().compare(dev_ip) != 0) {
+                    if ( connection_name.empty() ) {
+                        BOOST_LOG_TRIVIAL(info) << "MachineObject IP changed from " << BBLCrossTalk::Crosstalk_DevIP(obj->get_dev_ip())
+                                                << " to " << BBLCrossTalk::Crosstalk_DevIP(dev_ip);
+                        obj->set_dev_ip(dev_ip);
+                    }
+                    else {
+                        if ( obj->dev_connection_name.empty() || obj->dev_connection_name.compare(connection_name) == 0) {
+                            BOOST_LOG_TRIVIAL(info) << "MachineObject IP changed from " << BBLCrossTalk::Crosstalk_DevIP(obj->get_dev_ip())
+                                                    << " to " << BBLCrossTalk::Crosstalk_DevIP(dev_ip) << " connection_name is " << connection_name;
+                            if(obj->dev_connection_name.empty()){obj->dev_connection_name = connection_name;}
+                            obj->set_dev_ip(dev_ip);
+                        }
+                    }
+                    /* ip changed reconnect mqtt */
+                }
+
+                if (obj->wifi_signal != printer_signal ||
+                    obj->connection_type() != connect_type ||
+                    obj->bind_state != bind_state ||
+                    obj->bind_sec_link != sec_link ||
+                    obj->bind_ssdp_version != ssdp_version ||
+                    obj->printer_type != _parse_printer_type(printer_type_str))
+                {
+                    if (obj->connection_type() != connect_type ||
+                        obj->bind_state != bind_state ||
+                        obj->bind_sec_link != sec_link ||
+                        obj->bind_ssdp_version != ssdp_version ||
+                        obj->printer_type != _parse_printer_type(printer_type_str))
+                    {
+                        BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " UpdateLocalMachineInfo"
+                            << ", dev_id= " << BBLCrossTalk::Crosstalk_DevId(dev_id)
+                            << ", ip = " << BBLCrossTalk::Crosstalk_DevIP(dev_ip)
+                            << ", printer_name= " << BBLCrossTalk::Crosstalk_DevName(dev_name)
+                            << ", con_type= " << connect_type << ", signal= " << printer_signal
+                            << ", bind_state= " << bind_state;
+                    }
+                    else
+                    {
+                        BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " UpdateLocalMachineInfo_WIFI"
+                            << ", dev_id= " << BBLCrossTalk::Crosstalk_DevId(dev_id)
+                            << ", ip = "  << BBLCrossTalk::Crosstalk_DevIP(dev_ip)
+                            << ", printer_name= " << BBLCrossTalk::Crosstalk_DevName(dev_name)
+                            << ", con_type= " << connect_type << ", signal= " << printer_signal
+                            << ", bind_state= " << bind_state;
+                    }
+
+                    obj->wifi_signal         = printer_signal;
+                    it->second->GetInfo()->SetConnectionType(connect_type);
+                    obj->bind_state          = bind_state;
+                    obj->bind_sec_link       = sec_link;
+                    obj->bind_ssdp_version   = ssdp_version;
+                    obj->printer_type        = _parse_printer_type(printer_type_str);
+                }
+
+                // U0 firmware
+                if (obj->connection_type().empty() && obj->bind_state.empty())
+                    obj->bind_state = "free";
+
+                obj->m_is_online = true;
+                // Use saved local nickname if available, otherwise use SSDP discovered name
+                std::string local_nickname = obj->get_local_dev_nickname();
+                if (!local_nickname.empty()) {
+                    obj->set_dev_name(local_nickname);
+                } else {
+                    obj->set_dev_name(dev_name);
+                }
+                /* if (!obj->dev_ip.empty()) {
+                Slic3r::GUI::wxGetApp().app_config->set_str("ip_address", obj->dev_id, obj->dev_ip);
+                Slic3r::GUI::wxGetApp().app_config->save();
+                }*/
+            }
+            else {
+                /* insert a new machine */
+                obj = new MachineObject(this, m_agent, dev_name, dev_id, dev_ip);
+                obj->printer_type = _parse_printer_type(printer_type_str);
+                obj->wifi_signal = printer_signal;
+                obj->GetInfo()->SetConnectionType(connect_type);
+                obj->bind_state     = bind_state;
+                obj->bind_sec_link  = sec_link;
+                obj->dev_connection_name = connection_name;
+                obj->bind_ssdp_version = ssdp_version;
+                obj->m_is_online = true;
+
+                //load access code and local nickname
+                AppConfig* config = Slic3r::GUI::wxGetApp().app_config;
+                if (config) {
+                    obj->set_access_code(Slic3r::GUI::wxGetApp().app_config->get("access_code", dev_id), false);
+                    obj->set_user_access_code(Slic3r::GUI::wxGetApp().app_config->get("user_access_code", dev_id), false);
+                    // Load saved local nickname if available
+                    std::string local_nickname = obj->get_local_dev_nickname();
+                    if (!local_nickname.empty()) {
+                        obj->set_dev_name(local_nickname);
+                    }
+                }
+                localMachineList.insert(std::make_pair(dev_id, obj));
+
+                /* if (!obj->dev_ip.empty()) {
+                Slic3r::GUI::wxGetApp().app_config->set_str("ip_address", obj->dev_id, obj->dev_ip);
+                Slic3r::GUI::wxGetApp().app_config->save();
+                }*/
+                BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " New Machine, dev_id= " << BBLCrossTalk::Crosstalk_DevId(dev_id)
+                    << ", ip = " << BBLCrossTalk::Crosstalk_DevIP(dev_ip) <<", printer_name = " << BBLCrossTalk::Crosstalk_DevName(dev_name)
+                    << ", con_type= " << connect_type <<", signal= " << printer_signal << ", bind_state= " << bind_state;
+            }
+        }
+        catch (...) {
+            ;
+        }
+    }
+
+    MachineObject* DeviceManager::insert_local_device(std::string dev_name, std::string dev_id,
+        std::string dev_ip, std::string connection_type, std::string bind_state,
+        std::string version, std::string access_code, std::string printer_type)
+    {
+        MachineObject* obj;
+        obj = new MachineObject(this, m_agent, dev_name, dev_id, dev_ip);
+        if (printer_type.empty())
+            obj->printer_type = _parse_printer_type("C11");
+        else
+            obj->printer_type = _parse_printer_type(printer_type);
+
+        if (connection_type == "farm") {
+            obj->GetInfo()->SetConnectionType("lan");
+        } else {
+            obj->GetInfo()->SetConnectionType(connection_type);
+        }
+
+        obj->bind_state          = connection_type == "farm" ? "free":bind_state;
+        obj->bind_sec_link = "secure";
+        obj->bind_ssdp_version = version;
+        obj->m_is_online = true;
+        obj->set_access_code(access_code, false);
+        obj->set_user_access_code(access_code, false);
+
+
+        auto it = localMachineList.find(dev_id);
+        if (it != localMachineList.end()) {
+            localMachineList[dev_id] = obj;
+        } else {
+            localMachineList.insert(std::make_pair(dev_id, obj));
+        }
+
+        return obj;
+    }
+
+    int DeviceManager::query_bind_status(std::string& msg)
+    {
+        if (!m_agent)
+        {
+            msg = "";
+            return -1;
+        }
+
+        BOOST_LOG_TRIVIAL(trace) << "DeviceManager::query_bind_status";
+        std::map<std::string, MachineObject*>::iterator it;
+        std::vector<std::string> query_list;
+        for (it = localMachineList.begin(); it != localMachineList.end(); it++)
+        {
+            query_list.push_back(it->first);
+        }
+
+        unsigned int http_code;
+        std::string http_body;
+        int result = m_agent->query_bind_status(query_list, &http_code, &http_body);
+
+        if (result < 0)
+        {
+            msg = (boost::format("code=%1%,body=%2") % http_code % http_body).str();
+        }
+        else
+        {
+            msg = "";
+            try
+            {
+                json j = json::parse(http_body);
+                if (j.contains("bind_list"))
+                {
+
+                    for (auto& item : j["bind_list"])
+                    {
+                        auto it = localMachineList.find(item["dev_id"].get<std::string>());
+                        if (it != localMachineList.end())
+                        {
+                            if (!item["user_id"].is_null())
+                                it->second->bind_user_id = item["user_id"].get<std::string>();
+                            if (!item["user_name"].is_null())
+                                it->second->bind_user_name = item["user_name"].get<std::string>();
+                            else
+                                it->second->bind_user_name = "Free";
+                        }
+                    }
+                }
+            }
+            catch (...)
+            {
+                ;
+            }
+        }
+        return result;
+    }
+
+    MachineObject* DeviceManager::get_user_machine(std::string dev_id)
+    {
+        if (!m_agent || !m_agent->is_user_login())
+        {
+            return nullptr;
+        }
+
+        std::map<std::string, MachineObject*>::iterator it = userMachineList.find(dev_id);
+        if (it == userMachineList.end()) return nullptr;
+        return it->second;
+    }
+
+    MachineObject* DeviceManager::get_my_machine(std::string dev_id)
+    {
+        auto list = get_my_machine_list();
+        auto it = list.find(dev_id);
+        if (it != list.end())
+        {
+            return it->second;
+        }
+        return nullptr;
+    }
+
+    void DeviceManager::clean_user_info()
+    {
+        BOOST_LOG_TRIVIAL(trace) << "DeviceManager::clean_user_info";
+        // reset selected_machine
+        selected_machine = "";
+        local_selected_machine = "";
+
+        OnSelectedMachineChanged(selected_machine, "");
+
+        // clean user list
+        for (auto it = userMachineList.begin(); it != userMachineList.end(); it++)
+        {
+            if (it->second)
+            {
+                it->second->set_access_code("");
+                delete it->second;
+                it->second = nullptr;
+            }
+        }
+        userMachineList.clear();
+    }
+
+    bool DeviceManager::set_selected_machine(std::string dev_id)
+    {
+        BOOST_LOG_TRIVIAL(info) << "set_selected_machine=" << BBLCrossTalk::Crosstalk_DevId(dev_id)
+            << " cur_selected=" << BBLCrossTalk::Crosstalk_DevId(selected_machine);
+        auto my_machine_list = get_my_machine_list();
+        auto it = my_machine_list.find(dev_id);
+
+        // disconnect last if dev_id difference from previous one
+        auto last_selected = my_machine_list.find(selected_machine);
+        if (last_selected != my_machine_list.end() && selected_machine != dev_id)
+        {
+            if (last_selected->second->connection_type() == "lan")
+            {
+                m_agent->disconnect_printer();
+            }
+            else if (last_selected->second->connection_type() == "cloud") {
+                m_agent->set_user_selected_machine("");
+            }
+        }
+
+        // connect curr
+        if (it != my_machine_list.end())
+        {
+            if (selected_machine == dev_id)
+            {
+                // same dev_id, cloud => reset update time
+                if (it->second->connection_type() != "lan")
+                {
+                    BOOST_LOG_TRIVIAL(info) << "set_selected_machine: same cloud machine, dev_id =" << BBLCrossTalk::Crosstalk_DevId(dev_id)
+                        << ", just reset update time";
+
+                    // only reset update time
+                    it->second->reset_update_time();
+
+                    // check subscribe state
+                    Slic3r::GUI::wxGetApp().on_start_subscribe_again(dev_id);
+
+                    return true;
+                }
+                // same dev_id, lan => disconnect and reconnect
+                else
+                {
+                    BOOST_LOG_TRIVIAL(info) << "set_selected_machine: same lan machine, dev_id =" << BBLCrossTalk::Crosstalk_DevId(dev_id)
+                        << ", disconnect and reconnect";
+
+                    // lan mode printer reconnect printer
+                    if (m_agent)
+                    {
+                        m_agent->disconnect_printer();
+                        it->second->reset();
+
+#if !BBL_RELEASE_TO_PUBLIC
+                        it->second->connect(Slic3r::GUI::wxGetApp().app_config->get("enable_ssl_for_mqtt") == "true" ? true : false);
+#else
+                        it->second->connect(it->second->local_use_ssl_for_mqtt);
+#endif
+                    }
+                }
+            }
+            else
+            {
+                if (m_agent)
+                {
+                    if (it->second->connection_type() != "lan" || it->second->connection_type().empty())
+                    {
+                        // diff dev_id, cloud => set_user_selected_machine(new)
+                        BOOST_LOG_TRIVIAL(info) << "set_selected_machine: select new cloud machine, dev_id =" << BBLCrossTalk::Crosstalk_DevId(dev_id);
+                        m_agent->set_user_selected_machine(dev_id);
+                        it->second->reset();
+                    }
+                    else
+                    {
+                        BOOST_LOG_TRIVIAL(info) << "set_selected_machine: select new lan machine, dev_id =" << BBLCrossTalk::Crosstalk_DevId(dev_id);
+                        it->second->reset();
+#if !BBL_RELEASE_TO_PUBLIC
+                        it->second->connect(Slic3r::GUI::wxGetApp().app_config->get("enable_ssl_for_mqtt") == "true" ? true : false);
+#else
+                        it->second->connect(it->second->local_use_ssl_for_mqtt);
+#endif
+                    }
+                }
+            }
+            for (auto& data : it->second->m_nozzle_filament_data)
+            {
+                data.second.checked_filament.clear();
+            }
+        }
+
+        if (selected_machine != dev_id) {
+            OnSelectedMachineChanged(selected_machine, dev_id);
+        }
+
+        selected_machine = dev_id;
+        return true;
+    }
+
+    MachineObject* DeviceManager::get_selected_machine()
+    {
+        if (selected_machine.empty()) return nullptr;
+
+        MachineObject* obj = get_user_machine(selected_machine);
+        if (obj)
+            return obj;
+
+        // return local machine has access code
+        auto it = localMachineList.find(selected_machine);
+        if (it != localMachineList.end())
+        {
+            if (it->second->has_access_right())
+                return it->second;
+        }
+        return nullptr;
+    }
+
+    void DeviceManager::add_user_subscribe()
+    {
+        /* user machine */
+        std::vector<std::string> dev_list;
+        for (auto it = userMachineList.begin(); it != userMachineList.end(); it++)
+        {
+            dev_list.push_back(it->first);
+            BOOST_LOG_TRIVIAL(trace) << "add_user_subscribe: " << BBLCrossTalk::Crosstalk_DevId(it->first);
+        }
+        m_agent->add_subscribe(dev_list);
+    }
+
+
+    void DeviceManager::del_user_subscribe()
+    {
+        /* user machine */
+        std::vector<std::string> dev_list;
+        for (auto it = userMachineList.begin(); it != userMachineList.end(); it++)
+        {
+            dev_list.push_back(it->first);
+            BOOST_LOG_TRIVIAL(trace) << "del_user_subscribe: " << BBLCrossTalk::Crosstalk_DevId(it->first);
+        }
+        m_agent->del_subscribe(dev_list);
+    }
+
+    void DeviceManager::subscribe_device_list(std::vector<std::string> dev_list)
+    {
+        std::vector<std::string> unsub_list;
+        subscribe_list_cache.clear();
+        for (auto& it : subscribe_list_cache)
+        {
+            if (it != selected_machine)
+            {
+                unsub_list.push_back(it);
+                BOOST_LOG_TRIVIAL(trace) << "subscribe_device_list: unsub dev id = " << BBLCrossTalk::Crosstalk_DevId(it);
+            }
+        }
+        BOOST_LOG_TRIVIAL(trace) << "subscribe_device_list: unsub_list size = " << unsub_list.size();
+
+        if (!selected_machine.empty())
+        {
+            subscribe_list_cache.push_back(selected_machine);
+        }
+        for (auto& it : dev_list)
+        {
+            subscribe_list_cache.push_back(it);
+            BOOST_LOG_TRIVIAL(trace) << "subscribe_device_list: sub dev id = " << BBLCrossTalk::Crosstalk_DevId(it);
+        }
+        BOOST_LOG_TRIVIAL(trace) << "subscribe_device_list: sub_list size = " << subscribe_list_cache.size();
+        if (!unsub_list.empty())
+            m_agent->del_subscribe(unsub_list);
+        if (!dev_list.empty())
+            m_agent->add_subscribe(subscribe_list_cache);
+    }
+
+    std::map<std::string, MachineObject*> DeviceManager::get_my_machine_list()
+    {
+        std::map<std::string, MachineObject*> result;
+
+        for (auto it = userMachineList.begin(); it != userMachineList.end(); it++)
+        {
+            if (it->second && !it->second->is_lan_mode_printer())
+            {
+                result.insert(std::make_pair(it->first, it->second));
+            }
+        }
+
+        for (auto it = localMachineList.begin(); it != localMachineList.end(); it++)
+        {
+            if (it->second && it->second->has_access_right() && it->second->is_avaliable() && it->second->is_lan_mode_printer())
+            {
+                // remove redundant in userMachineList
+                if (result.find(it->first) == result.end())
+                {
+                    result.emplace(std::make_pair(it->first, it->second));
+                }
+            }
+        }
+        return result;
+    }
+
+    std::map<std::string, MachineObject*> DeviceManager::get_my_cloud_machine_list()
+    {
+        std::map<std::string, MachineObject*> result;
+        for (auto it = userMachineList.begin(); it != userMachineList.end(); it++)
+        {
+            if (it->second && !it->second->is_lan_mode_printer()) { result.emplace(*it); }
+        }
+        return result;
+    }
+
+    std::string DeviceManager::get_first_online_user_machine() const
+    {
+        for (auto it = userMachineList.begin(); it != userMachineList.end(); it++)
+        {
+            if (it->second && it->second->is_online())
+            {
+                return it->second->get_dev_id();
+            }
+        }
+        return "";
+    }
+
+    void DeviceManager::modify_device_name(std::string dev_id, std::string dev_name)
+    {
+        BOOST_LOG_TRIVIAL(trace) << "modify_device_name";
+
+        // Find the device to check if it's a LAN device
+        MachineObject* obj = nullptr;
+        auto it = userMachineList.find(dev_id);
+        if (it != userMachineList.end()) {
+            obj = it->second;
+        } else {
+            auto local_it = localMachineList.find(dev_id);
+            if (local_it != localMachineList.end()) {
+                obj = local_it->second;
+            }
+        }
+
+        // For LAN mode printers, save the name locally
+        if (obj && obj->is_lan_mode_printer()) {
+            obj->set_local_dev_nickname(dev_name);
+            BOOST_LOG_TRIVIAL(info) << "modify_device_name: saved local nickname for LAN device " << dev_id;
+            return;
+        }
+
+        // For cloud devices, use the cloud API
+        if (m_agent)
+        {
+            int result = m_agent->modify_printer_name(dev_id, dev_name);
+            if (result == 0)
+            {
+                update_user_machine_list_info();
+            }
+        }
+    }
+
+    void DeviceManager::parse_user_print_info(std::string body)
+    {
+        if (device_subseries.size() <= 0) {
+            device_subseries = DevPrinterConfigUtil::get_all_subseries();
+            if (device_subseries.size() <= 0) {
+                device_subseries.insert(std::pair<std::string, std::vector<std::string>>("", std::vector<std::string>()));
+            }
+        }
+
+        BOOST_LOG_TRIVIAL(trace) << "DeviceManager::parse_user_print_info";
+        std::lock_guard<std::mutex> lock(listMutex);
+        std::set<std::string> new_list;
+        try
+        {
+            json j = json::parse(body);
+
+#if !BBL_RELEASE_TO_PUBLIC
+            BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << ": " << BBLCrossTalk::Crosstalk_JsonLog(j);
+#endif
+
+            if (j.contains("devices") && !j["devices"].is_null())
+            {
+                for (auto& elem : j["devices"])
+                {
+                    MachineObject* obj = nullptr;
+                    std::string dev_id;
+                    if (!elem["dev_id"].is_null())
+                    {
+                        dev_id = elem["dev_id"].get<std::string>();
+                        new_list.insert(dev_id);
+                    }
+                    std::map<std::string, MachineObject*>::iterator iter = userMachineList.find(dev_id);
+                    if (iter != userMachineList.end())
+                    {
+                        /* update field */
+                        obj = iter->second;
+                        obj->GetInfo()->SetDevId(dev_id);
+                    }
+                    else
+                    {
+                        obj = new MachineObject(this, m_agent, "", dev_id, "");
+                        if (m_agent)
+                        {
+                            obj->set_bind_status(m_agent->get_user_name());
+                        }
+
+                        if (obj->get_dev_ip().empty())
+                        {
+                            obj->get_dev_ip() = Slic3r::GUI::wxGetApp().app_config->get("ip_address", dev_id);
+                        }
+                        userMachineList.insert(std::make_pair(dev_id, obj));
+                    }
+
+                    if (!obj) continue;
+
+                    if (!elem["dev_id"].is_null())
+                        obj->GetInfo()->SetDevId(elem["dev_id"].get<std::string>());
+                    if (!elem["dev_name"].is_null())
+                        obj->set_dev_name(elem["dev_name"].get<std::string>());
+                    if (!elem["dev_online"].is_null())
+                        obj->m_is_online = elem["dev_online"].get<bool>();
+                    if (elem.contains("dev_model_name") && !elem["dev_model_name"].is_null()) {
+                        auto printer_type = elem["dev_model_name"].get<std::string>();
+                        for (const std::pair<std::string, std::vector<std::string>> &pair : device_subseries) {
+                            auto it = std::find(pair.second.begin(), pair.second.end(), printer_type);
+                            if (it != pair.second.end())
+                            {
+                                obj->printer_type = Slic3r::_parse_printer_type(pair.first);
+                                break;
+                            }
+                            else
+                            {
+                                obj->printer_type = Slic3r::_parse_printer_type(printer_type);
+                            }
+                        }
+                    }
+                    if (!elem["task_status"].is_null())
+                        obj->iot_print_status = elem["task_status"].get<std::string>();
+                    if (elem.contains("dev_access_code") && !elem["dev_access_code"].is_null())
+                    {
+                        std::string acc_code = elem["dev_access_code"].get<std::string>();
+                        acc_code.erase(std::remove(acc_code.begin(), acc_code.end(), '\n'), acc_code.end());
+                        obj->set_access_code(acc_code);
+                    }
+                }
+
+                //remove MachineObject from userMachineList
+                std::map<std::string, MachineObject*>::iterator iterat;
+                for (iterat = userMachineList.begin(); iterat != userMachineList.end(); )
+                {
+                    if (new_list.find(iterat->first) == new_list.end())
+                    {
+                        iterat = userMachineList.erase(iterat);
+                    }
+                    else
+                    {
+                        iterat++;
+                    }
+                }
+            }
+        }
+        catch (std::exception& e)
+        {
+            BOOST_LOG_TRIVIAL(error) << __FUNCTION__ << " exception=" << e.what();
+        }
+    }
+
+    void DeviceManager::update_user_machine_list_info()
+    {
+        if (!m_agent) return;
+
+        BOOST_LOG_TRIVIAL(debug) << "update_user_machine_list_info";
+        unsigned int http_code;
+        std::string body;
+        int result = m_agent->get_user_print_info(&http_code, &body);
+        if (result == 0) {
+            Slic3r::GUI::wxGetApp().CallAfter([this, body]() {
+                parse_user_print_info(body);
+            });
+        }
+    }
+
+    void DeviceManager::load_last_machine()
+    {
+        if (userMachineList.empty()) return;
+
+        else if (userMachineList.size() == 1)
+        {
+            this->set_selected_machine(userMachineList.begin()->second->get_dev_id());
+        }
+        else
+        {
+            if (m_agent)
+            {
+                std::string last_monitor_machine = m_agent->get_user_selected_machine();
+                bool found = false;
+                for (auto it = userMachineList.begin(); it != userMachineList.end(); it++)
+                {
+                    if (last_monitor_machine == it->first)
+                    {
+                        this->set_selected_machine(last_monitor_machine);
+                        found = true;
+                    }
+                }
+                if (!found)
+                    this->set_selected_machine(userMachineList.begin()->second->get_dev_id());
+            }
+        }
+    }
+
+    void DeviceManager::OnMachineBindStateChanged(MachineObject* obj, const std::string& new_state)
+    {
+        if (!obj) { return; }
+        if (obj->get_dev_id() == selected_machine)
+        {
+            if (new_state == "free") { OnSelectedMachineLost(); }
+        }
+    }
+
+    void DeviceManager::OnSelectedMachineLost()
+    {
+        GUI::wxGetApp().sidebar().update_sync_status(nullptr);
+        GUI::wxGetApp().sidebar().load_ams_list(nullptr);
+    }
+
+    void DeviceManager::OnSelectedMachineChanged(const std::string& /*pre_dev_id*/,
+                                                 const std::string& /*new_dev_id*/)
+    {
+        if (MachineObject* obj_ = get_selected_machine()) {
+            GUI::wxGetApp().sidebar().update_sync_status(obj_);
+            GUI::wxGetApp().sidebar().load_ams_list(obj_);
+        };
+    }
+
+    void DeviceManager::reload_printer_settings()
+    {
+        for (auto obj : this->userMachineList) { obj.second->reload_printer_settings(); };
+    }
+
+
+    DeviceManagerRefresher::DeviceManagerRefresher(DeviceManager* manger) : wxObject()
+    {
+        m_manager = manger;
+        m_timer = new wxTimer();
+        m_timer->Bind(wxEVT_TIMER, &DeviceManagerRefresher::on_timer, this);
+    }
+
+    DeviceManagerRefresher::~DeviceManagerRefresher()
+    {
+        m_timer->Stop();
+        delete m_timer;
+    }
+
+    void DeviceManagerRefresher::on_timer(wxTimerEvent& event)
+    {
+        if (!m_manager) { return; }
+
+        NetworkAgent* agent = m_manager->get_agent();
+        if (!agent) { return; }
+
+        // reset to active
+        Slic3r::GUI::wxGetApp().reset_to_active();
+
+        MachineObject* obj = m_manager->get_selected_machine();
+        if (!obj) { return; }
+
+        // check valid machine
+        if (obj && m_manager->get_my_machine(obj->get_dev_id()) == nullptr)
+        {
+            m_manager->set_selected_machine("");
+            agent->set_user_selected_machine("");
+            return;
+        }
+
+        // do some refresh
+        if (Slic3r::GUI::wxGetApp().is_user_login())
+        {
+            m_manager->check_pushing();
+            try
+            {
+                agent->refresh_connection();
+            }
+            catch (...)
+            {
+                ;
+            }
+        }
+
+        // certificate
+        agent->install_device_cert(obj->get_dev_id(), obj->is_lan_mode_printer());
+    }
+}
\ No newline at end of file
diff --git a/src/slic3r/GUI/DeviceManager.cpp b/src/slic3r/GUI/DeviceManager.cpp
new file mode 100644
index 0000000..b2f0534
--- /dev/null
+++ b/src/slic3r/GUI/DeviceManager.cpp
@@ -0,0 +1,5429 @@
+#include "libslic3r/libslic3r.h"
+#include "DeviceManager.hpp"
+#include "libslic3r/Time.hpp"
+#include "libslic3r/Thread.hpp"
+#include "slic3r/Utils/BBLUtil.hpp"
+#include "slic3r/Utils/NetworkAgent.hpp"
+#include "GuiColor.hpp"
+
+#include "GUI_App.hpp"
+#include "MsgDialog.hpp"
+#include "DeviceErrorDialog.hpp"
+#include "Plater.hpp"
+#include "GUI_App.hpp"
+#include "ReleaseNote.hpp"
+#include <thread>
+#include <mutex>
+#include <codecvt>
+#include <boost/foreach.hpp>
+#include <boost/typeof/typeof.hpp>
+#include <boost/uuid/uuid.hpp>
+#include <boost/uuid/uuid_generators.hpp>
+#include <boost/uuid/uuid_io.hpp>
+
+/* mac need the macro while including <boost/stacktrace.hpp>*/
+#ifdef  __APPLE__
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#endif
+#include <boost/stacktrace.hpp>
+
+#include <wx/dir.h>
+#include "fast_float/fast_float.h"
+
+#include "DeviceCore/DevAxis.h"
+#include "DeviceCore/DevChamber.h"
+#include "DeviceCore/DevFilaSystem.h"
+#include "DeviceCore/DevExtensionTool.h"
+#include "DeviceCore/DevExtruderSystem.h"
+#include "DeviceCore/DevNozzleSystem.h"
+#include "DeviceCore/DevBed.h"
+#include "DeviceCore/DevLamp.h"
+#include "DeviceCore/DevFan.h"
+#include "DeviceCore/DevStorage.h"
+#include "DeviceCore/DevNozzleRack.h"
+
+#include "DeviceCore/DevConfig.h"
+#include "DeviceCore/DevCtrl.h"
+#include "DeviceCore/DevInfo.h"
+#include "DeviceCore/DevPrintOptions.h"
+#include "DeviceCore/DevPrintTaskInfo.h"
+#include "DeviceCore/DevHMS.h"
+#include "DeviceCore/DevUpgrade.h"
+
+#include "DeviceCore/DevMapping.h"
+#include "DeviceCore/DevManager.h"
+#include "DeviceCore/DevUtil.h"
+
+
+#define CALI_DEBUG
+#define MINUTE_30 1800000    //ms
+#define TIME_OUT  5000       //ms
+
+namespace pt = boost::property_tree;
+
+float string_to_float(const std::string& str_value) {
+    float value = 0.0;
+    fast_float::from_chars(str_value.c_str(), str_value.c_str() + str_value.size(), value);
+    return value;
+}
+
+int get_tray_id_by_ams_id_and_slot_id(int ams_id, int slot_id)
+{
+    if (ams_id == VIRTUAL_TRAY_MAIN_ID || ams_id == VIRTUAL_TRAY_DEPUTY_ID) {
+        return ams_id;
+    } else {
+        return ams_id * 4 + slot_id;
+    }
+}
+
+wxString Slic3r::get_stage_string(int stage)
+{
+    switch(stage) {
+    case 0:
+        return _L("Printing");
+    case 1:
+        return _L("Auto bed leveling");
+    case 2:
+        return _L("Heatbed preheating");
+    case 3:
+        return _L("Vibration compensation");
+    case 4:
+        return _L("Changing filament");
+    case 5:
+        return _L("M400 pause");
+    case 6:
+        return _L("Paused (filament ran out)");
+    case 7:
+        return _L("Heating nozzle");
+    case 8:
+        return _L("Calibrating dynamic flow");
+    case 9:
+        return _L("Scanning bed surface");
+    case 10:
+        return _L("Inspecting first layer");
+    case 11:
+        return _L("Identifying build plate type");
+    case 12:
+        return _L("Calibrating Micro Lidar");
+    case 13:
+        return _L("Homing toolhead");
+    case 14:
+        return _L("Cleaning nozzle tip");
+    case 15:
+        return _L("Checking extruder temperature");
+    case 16:
+        return _L("Paused by the user");
+    case 17:
+        return _L("Pause (front cover fall off)");
+    case 18:
+        return _L("Calibrating the micro lidar");
+    case 19:
+        return _L("Calibrating flow ratio");
+    case 20:
+        return _L("Pause (nozzle temperature malfunction)");
+    case 21:
+        return _L("Pause (heatbed temperature malfunction)");
+    case 22:
+        return _L("Filament unloading");
+    case 23:
+        return _L("Pause (step loss)");
+    case 24:
+        return _L("Filament loading");
+    case 25:
+        return _L("Motor noise cancellation");
+    case 26:
+        return _L("Pause (AMS offline)");
+    case 27:
+        return _L("Pause (low speed of the heatbreak fan)");
+    case 28:
+        return _L("Pause (chamber temperature control problem)");
+    case 29:
+        return _L("Cooling chamber");
+    case 30:
+        return _L("Pause (Gcode inserted by user)");
+    case 31:
+        return _L("Motor noise showoff");
+    case 32:
+        return _L("Pause (nozzle clumping)");
+    case 33:
+        return _L("Pause (cutter error)");
+    case 34:
+        return _L("Pause (first layer error)");
+    case 35:
+        return _L("Pause (nozzle clog)");
+    case 36:
+        return _L("Measuring motion percision");
+    case 37:
+        return _L("Enhancing motion percision");
+    case 38:
+        return _L("Measure motion accuracy");
+    case 39:
+        return _L("Nozzle offset calibration");
+    case 40:
+        return _L("high temperature auto bed levelling");
+    case 41:
+        return _L("Auto Check: Quick Release Lever");
+    case 42:
+        return _L("Auto Check: Door and Upper Cover");
+    case 43:
+        return _L("Laser Calibration");
+    case 44:
+        return _L("Auto Check: Platform");
+    case 45:
+        return _L("Confirming BirdsEye Camera location");
+    case 46:
+        return _L("Calibrating BirdsEye Camera");
+    case 47:
+        return _L("Auto bed leveling -phase 1");
+    case 48:
+        return _L("Auto bed leveling -phase 2");
+    case 49:
+        return _L("Heating chamber");
+    case 50:
+        return _L("Cooling heatbed");
+    case 51:
+        return _L("Printing calibration lines");
+    case 52:
+        return _L("Auto Check: Material");
+    case 53:
+        return _L("Live View Camera Calibration");
+    case 54:
+        return _L("Waiting for heatbed to reach target temperature");
+    case 55:
+        return _L("Auto Check: Material Position");
+    case 56:
+        return _L("Cutting Module Offset Calibration");
+    case 57:
+        return _L("Measuring Surface");
+    case 58:
+        return _L("Thermal Preconditioning for first layer optimization");
+    case 59:
+        return _L("Homing Blade Holder");                             // O1C
+    case 60:
+        return _L("Calibrating Camera Offset");                       // O1C
+    case 61:
+        return _L("Calibrating Blade Holder Position");               // O1C
+    case 62:
+        return _L("Hotend Pick and Place Test");                      // O1C
+    case 63:
+        return _L("Waiting for the Chamber temperature to equalize"); // O1S  O1E/U1   O1D/U2.5
+    case 64:
+        return _L(" Preparing Hotend");//O1C/U0
+    case 65:
+        return _L("Calibrating the detection position of nozzle clumping"); // N7
+    case 66:
+        return _L("Purifying the chamber air");
+    default:
+        BOOST_LOG_TRIVIAL(info) << "stage = " << stage;
+    }
+    return "";
+}
+
+std::string to_string_nozzle_diameter(float nozzle_diameter)
+{
+    float eps = 1e-3;
+    if (abs(nozzle_diameter - 0.2) < eps) {
+        return "0.2";
+    }
+    else if (abs(nozzle_diameter - 0.4) < eps) {
+        return "0.4";
+    }
+    else if (abs(nozzle_diameter - 0.6) < eps) {
+        return "0.6";
+    }
+    else if (abs(nozzle_diameter - 0.8) < eps) {
+        return "0.8";
+    }
+    return "0";
+}
+
+void sanitizeToUtf8(std::string& str) {
+    std::string result;
+    size_t i = 0;
+
+    while (i < str.size()) {
+        unsigned char c = str[i];
+        size_t remainingBytes = 0;
+        bool valid = true;
+
+        if ((c & 0x80) == 0x00) { // 1-byte character (ASCII)
+            remainingBytes = 0;
+        }
+        else if ((c & 0xE0) == 0xC0) { // 2-byte character
+            remainingBytes = 1;
+        }
+        else if ((c & 0xF0) == 0xE0) { // 3-byte character
+            remainingBytes = 2;
+        }
+        else if ((c & 0xF8) == 0xF0) { // 4-byte character
+            remainingBytes = 3;
+        }
+        else {
+            valid = false; // Invalid first byte
+        }
+
+        if (valid && i + remainingBytes < str.size()) {
+            for (size_t j = 1; j <= remainingBytes; ++j) {
+                if ((str[i + j] & 0xC0) != 0x80) {
+                    valid = false; // Invalid continuation byte
+                    break;
+                }
+            }
+        }
+        else {
+            valid = false; // Truncated character
+        }
+
+        if (valid) {
+            // Append valid UTF-8 character
+            result.append(str, i, remainingBytes + 1);
+            i += remainingBytes + 1;
+        }
+        else {
+            // Replace invalid character with space
+            result += ' ';
+            ++i; // Skip the invalid byte
+        }
+    }
+    str = std::move(result);
+}
+
+namespace Slic3r {
+
+/* Common Functions */
+void split_string(std::string s, std::vector<std::string>& v) {
+
+    std::string t = "";
+    for (int i = 0; i < s.length(); ++i) {
+        if (s[i] == ',') {
+            v.push_back(t);
+            t = "";
+        }
+        else {
+            t.push_back(s[i]);
+        }
+    }
+    v.push_back(t);
+}
+
+static wxString _generate_nozzle_id(NozzleVolumeType nozzle_type, const std::string& diameter)
+{
+    // HS00-0.4
+    std::string nozzle_id = "H";
+    switch (nozzle_type) {
+    case NozzleVolumeType::nvtStandard: {
+        nozzle_id += "S";
+        break;
+    }
+    case NozzleVolumeType::nvtHighFlow: {
+        nozzle_id += "H";
+        break;
+    }
+    default:
+        nozzle_id += "H";
+        break;
+    }
+    nozzle_id += "00";
+    nozzle_id += "-";
+    nozzle_id += diameter;
+    return nozzle_id;
+}
+
+NozzleVolumeType convert_to_nozzle_type(const std::string &str)
+{
+    if (str.size() < 8) {
+        assert(false);
+        return NozzleVolumeType::nvtStandard;
+    }
+    NozzleVolumeType res = NozzleVolumeType::nvtStandard;
+    if (str[1] == 'S')
+        res = NozzleVolumeType::nvtStandard;
+    else if (str[1] == 'H')
+        res = NozzleVolumeType::nvtHighFlow;
+    return res;
+}
+
+wxString MachineObject::get_printer_type_display_str() const
+{
+    std::string display_name = DevPrinterConfigUtil::get_printer_display_name(printer_type);
+    if (!display_name.empty())
+        return display_name;
+    else
+        return _L("Unknown");
+}
+
+std::string MachineObject::get_printer_thumbnail_img_str() const
+{
+    std::string img_str = DevPrinterConfigUtil::get_printer_thumbnail_img(printer_type);
+    std::string img_url;
+
+     if (!img_str.empty())
+     {
+        img_url = Slic3r::resources_dir() + "\\images\\" + img_str ;
+        if (fs::exists(img_url + ".svg"))
+        {
+            return img_url;
+        }
+        else
+        {
+            img_url = img_str;
+        }
+     }
+     else
+     {
+        img_url =  "printer_thumbnail";
+     }
+
+    return img_url;
+}
+
+std::string MachineObject::get_auto_pa_cali_thumbnail_img_str() const
+{
+    return DevPrinterConfigUtil::get_printer_auto_pa_cali_image(printer_type);
+}
+
+std::string MachineObject::get_ftp_folder()
+{
+    return DevPrinterConfigUtil::get_ftp_folder(printer_type);
+}
+
+bool MachineObject::HasRecentCloudMessage()
+{
+    auto curr_time = std::chrono::system_clock::now();
+    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(curr_time - last_cloud_msg_time_);
+    return diff.count() < 5000;
+}
+
+bool MachineObject::HasRecentLanMessage()
+{
+    auto curr_time = std::chrono::system_clock::now();
+    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(curr_time - last_lan_msg_time_);
+    return diff.count() < 5000;
+}
+
+std::string MachineObject::get_access_code() const
+{
+    if (get_user_access_code().empty())
+        return access_code;
+    return get_user_access_code();
+}
+
+void MachineObject::set_access_code(std::string code, bool only_refresh)
+{
+    this->access_code = code;
+    if (only_refresh) {
+        AppConfig* config = GUI::wxGetApp().app_config;
+        if (config) {
+            if (!code.empty()) {
+                GUI::wxGetApp().app_config->set_str("access_code", get_dev_id(), code);
+            } else {
+                GUI::wxGetApp().app_config->erase("access_code", get_dev_id());
+            }
+        }
+    }
+}
+
+void MachineObject::erase_user_access_code()
+{
+    this->user_access_code = "";
+    AppConfig* config = GUI::wxGetApp().app_config;
+    if (config) {
+        GUI::wxGetApp().app_config->erase("user_access_code", get_dev_id());
+        //GUI::wxGetApp().app_config->save();
+    }
+}
+
+void MachineObject::set_user_access_code(std::string code, bool only_refresh)
+{
+    this->user_access_code = code;
+    if (only_refresh && !code.empty()) {
+        AppConfig* config = GUI::wxGetApp().app_config;
+        if (config && !code.empty()) {
+            GUI::wxGetApp().app_config->set_str("user_access_code", get_dev_id(), code);
+        }
+    }
+}
+
+std::string MachineObject::get_user_access_code() const
+{
+    AppConfig* config = GUI::wxGetApp().app_config;
+    if (config) {
+        return GUI::wxGetApp().app_config->get("user_access_code", get_dev_id());
+    }
+    return "";
+}
+
+void MachineObject::set_local_dev_nickname(std::string name)
+{
+    AppConfig* config = GUI::wxGetApp().app_config;
+    if (config) {
+        if (!name.empty()) {
+            GUI::wxGetApp().app_config->set_str("device_nickname", get_dev_id(), name);
+        } else {
+            GUI::wxGetApp().app_config->erase("device_nickname", get_dev_id());
+        }
+        GUI::wxGetApp().app_config->save();
+    }
+    // Update the in-memory device name as well
+    dev_name = name;
+}
+
+std::string MachineObject::get_local_dev_nickname() const
+{
+    AppConfig* config = GUI::wxGetApp().app_config;
+    if (config) {
+        return GUI::wxGetApp().app_config->get("device_nickname", get_dev_id());
+    }
+    return "";
+}
+
+bool MachineObject::has_local_dev_nickname() const
+{
+    return !get_local_dev_nickname().empty();
+}
+
+std::string MachineObject::get_show_printer_type() const
+{
+    std::string printer_type = this->printer_type;
+    if (this->is_support_upgrade_kit && this->installed_upgrade_kit)
+        printer_type = "C12";
+    return printer_type;
+}
+PrinterSeries MachineObject::get_printer_series() const
+{
+    std::string series =  DevPrinterConfigUtil::get_printer_series_str(printer_type);
+    if (series == "series_x1" || series == "series_o")
+        return PrinterSeries::SERIES_X1;
+    else if (series == "series_p1p")
+        return PrinterSeries::SERIES_P1P;
+    else
+        return PrinterSeries::SERIES_P1P;
+}
+
+PrinterArch MachineObject::get_printer_arch() const
+{
+    return DevPrinterConfigUtil::get_printer_arch(printer_type);
+}
+
+std::string MachineObject::get_printer_ams_type() const
+{
+    return DevPrinterConfigUtil::get_printer_use_ams_type(printer_type);
+}
+
+bool MachineObject::is_series_n(const std::string& series_str) { return series_str == "series_n";  }
+bool MachineObject::is_series_p(const std::string& series_str) { return series_str == "series_p1p";}
+bool MachineObject::is_series_x(const std::string& series_str) { return series_str == "series_x1"; }
+bool MachineObject::is_series_o(const std::string& series_str) { return series_str == "series_o";  }
+
+bool MachineObject::is_series_n() const { return is_series_n(DevPrinterConfigUtil::get_printer_series_str(printer_type)); }
+bool MachineObject::is_series_p() const { return is_series_p(DevPrinterConfigUtil::get_printer_series_str(printer_type)); }
+bool MachineObject::is_series_x() const { return is_series_x(DevPrinterConfigUtil::get_printer_series_str(printer_type)); }
+bool MachineObject::is_series_o() const { return is_series_o(DevPrinterConfigUtil::get_printer_series_str(printer_type)); }
+
+std::string MachineObject::get_printer_series_str() const{ return DevPrinterConfigUtil::get_printer_series_str(printer_type);};
+
+void MachineObject::reload_printer_settings()
+{
+    print_json.load_compatible_settings("", "");
+    parse_json("cloud", "{}");
+}
+
+MachineObject::MachineObject(DeviceManager* manager, NetworkAgent* agent, std::string name, std::string id, std::string ip)
+    :dev_name(name),
+    dev_ip(ip),
+    subtask_(nullptr),
+    model_task(nullptr),
+    slice_info(nullptr),
+    m_is_online(false)
+{
+    BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " called for dev_id=" << BBLCrossTalk::Crosstalk_DevId(id) << ", main_thread=" << wxThread::IsMain();
+    if (!wxThread::IsMain()) {
+        assert(false && "critical warning");
+        BOOST_LOG_TRIVIAL(error) << __FUNCTION__ << "called from other thread, callstack: " << boost::stacktrace::stacktrace();
+    }
+
+    m_manager = manager;
+    m_agent = agent;
+
+    m_dev_info = DevInfo::Create(this);
+    m_dev_info->SetDevId(id);
+
+    reset();
+
+    /* temprature fields */
+    frame_temp          = 0.0f;
+
+    /* ams fileds */
+    ams_exist_bits = 0;
+    tray_exist_bits = 0;
+    tray_is_bbl_bits = 0;
+
+    /* signals */
+    wifi_signal = "";
+
+    /* printing */
+    mc_print_stage = 0;
+    mc_print_error_code = 0;
+    print_error = 0;
+    mc_print_line_number = 0;
+    mc_print_percent = 0;
+    mc_print_sub_stage = 0;
+    mc_left_time = 0;
+    hw_switch_state = 0;
+
+    has_ipcam = true; // default true
+
+
+    auto vslot = DevAmsTray(std::to_string(VIRTUAL_TRAY_MAIN_ID));
+    vt_slot.push_back(vslot);
+
+    {
+        m_axis    = DevAxis::Create(this);
+        m_chamber = DevChamber::Create(this);
+        m_lamp = new DevLamp(this);
+        m_fan = new DevFan(this);
+        m_bed = new DevBed(this);
+
+        m_storage       = new DevStorage(this);
+        m_extder_system = new DevExtderSystem(this);
+        m_extension_tool = DevExtensionTool::Create(this);
+        m_nozzle_system = new DevNozzleSystem(this);
+        m_fila_system   = new DevFilaSystem(this);
+        m_upgrade       = DevUpgrade::Create(this);
+        m_hms_system    = new DevHMS(this);
+        m_config = new DevConfig(this);
+
+        m_ctrl = new DevCtrl(this);
+        m_print_options = new DevPrintOptions(this);
+    }
+}
+
+MachineObject::~MachineObject()
+{
+    BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " called for dev_id=" << BBLCrossTalk::Crosstalk_DevId(get_dev_id()) << ", main_thread=" << wxThread::IsMain();
+    if (!wxThread::IsMain()) {
+        assert(false && "critical warning");
+        BOOST_LOG_TRIVIAL(error) << __FUNCTION__ << " called from other thread, callstack: " << boost::stacktrace::stacktrace();
+    }
+
+    if (subtask_) {
+        delete subtask_;
+        subtask_ = nullptr;
+    }
+
+    if (model_task) {
+        delete model_task;
+        model_task = nullptr;
+    }
+
+    free_slice_info();
+
+    while (!m_command_error_code_dlgs.empty()) {
+        delete *m_command_error_code_dlgs.begin();/*element will auto remove from m_command_error_code_dlgs on deleted*/
+    }
+
+    {
+        delete m_lamp;
+        m_lamp = nullptr;
+
+        delete m_fan;
+        m_fan  = nullptr;
+
+        delete m_bed;
+        m_bed = nullptr;
+
+        delete m_extder_system;
+        m_extder_system = nullptr;
+
+        delete m_nozzle_system;
+        m_nozzle_system = nullptr;
+
+        delete m_ctrl;
+        m_ctrl = nullptr;
+
+        delete m_fila_system;
+        m_fila_system = nullptr;
+
+        delete m_hms_system;
+        m_hms_system = nullptr;
+
+        delete m_config;
+        m_config = nullptr;
+
+        delete m_print_options;
+        m_print_options = nullptr;
+    }
+}
+
+bool MachineObject::is_in_extrusion_cali()
+{
+    auto curr_time = std::chrono::system_clock::now();
+    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(curr_time - last_extrusion_cali_start_time);
+    if (diff.count() < EXTRUSION_OMIT_TIME) {
+        mc_print_percent = 0;
+        return true;
+    }
+
+    if (is_in_printing_status(print_status)
+        && print_type == "system"
+        && boost::contains(m_gcode_file, "extrusion_cali")
+        )
+    {
+        return true;
+    }
+    return false;
+}
+
+bool MachineObject::is_extrusion_cali_finished()
+{
+    auto curr_time = std::chrono::system_clock::now();
+    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(curr_time - last_extrusion_cali_start_time);
+    if (diff.count() < EXTRUSION_OMIT_TIME) {
+        return false;
+    }
+
+    if (boost::contains(m_gcode_file, "extrusion_cali")
+        && this->mc_print_percent == 100)
+        return true;
+    else
+        return false;
+}
+
+
+DevAmsTray *MachineObject::get_curr_tray()
+{
+    const std::string& cur_ams_id = m_extder_system->GetCurrentAmsId();
+    if (cur_ams_id.compare(std::to_string(VIRTUAL_TRAY_MAIN_ID)) == 0) {
+        return &vt_slot[0];
+    }
+
+    DevAms* curr_ams = get_curr_Ams();
+    if (!curr_ams) return nullptr;
+
+    auto it = curr_ams->GetTrays().find(m_extder_system->GetCurrentSlotId());
+    if (it != curr_ams->GetTrays().end())
+    {
+        return it->second;
+    }
+
+    return nullptr;
+}
+
+std::string MachineObject::get_filament_id(std::string ams_id, std::string tray_id) const {
+    return this->get_tray(ams_id, tray_id).setting_id;
+}
+
+std::string MachineObject::get_filament_type(const std::string& ams_id, const std::string& tray_id) const {
+    return this->get_tray(ams_id, tray_id).get_filament_type();
+}
+
+std::string MachineObject::get_filament_display_type(const std::string& ams_id, const std::string& tray_id) const {
+    return this->get_tray(ams_id, tray_id).get_display_filament_type();
+}
+
+void MachineObject::_parse_ams_status(int ams_status)
+{
+    ams_status_sub = ams_status & 0xFF;
+    int ams_status_main_int = (ams_status & 0xFF00) >> 8;
+    if (ams_status_main_int == (int)AmsStatusMain::AMS_STATUS_MAIN_IDLE) {
+        ams_status_main = AmsStatusMain::AMS_STATUS_MAIN_IDLE;
+    } else if (ams_status_main_int == (int) AmsStatusMain::AMS_STATUS_MAIN_FILAMENT_CHANGE) {
+        ams_status_main = AmsStatusMain::AMS_STATUS_MAIN_FILAMENT_CHANGE;
+    } else if (ams_status_main_int == (int) AmsStatusMain::AMS_STATUS_MAIN_RFID_IDENTIFYING) {
+        ams_status_main = AmsStatusMain::AMS_STATUS_MAIN_RFID_IDENTIFYING;
+    } else if (ams_status_main_int == (int) AmsStatusMain::AMS_STATUS_MAIN_ASSIST) {
+        ams_status_main = AmsStatusMain::AMS_STATUS_MAIN_ASSIST;
+    } else if (ams_status_main_int == (int) AmsStatusMain::AMS_STATUS_MAIN_CALIBRATION) {
+        ams_status_main = AmsStatusMain::AMS_STATUS_MAIN_CALIBRATION;
+    } else if (ams_status_main_int == (int) AmsStatusMain::AMS_STATUS_MAIN_SELF_CHECK) {
+        ams_status_main = AmsStatusMain::AMS_STATUS_MAIN_SELF_CHECK;
+    } else if (ams_status_main_int == (int) AmsStatusMain::AMS_STATUS_MAIN_DEBUG) {
+        ams_status_main = AmsStatusMain::AMS_STATUS_MAIN_DEBUG;
+    } else {
+        ams_status_main = AmsStatusMain::AMS_STATUS_MAIN_UNKNOWN;
+    }
+
+    BOOST_LOG_TRIVIAL(trace) << "ams_debug: main = " << ams_status_main_int << ", sub = " << ams_status_sub;
+}
+
+bool MachineObject::can_unload_filament()
+{
+    bool result = false;
+    if (!HasAms())
+        return true;
+
+    if (ams_status_main == AMS_STATUS_MAIN_IDLE && hw_switch_state == 1 && m_extder_system->GetCurrentAmsId() == "255") {
+        return true;
+    }
+    return result;
+}
+
+static float calc_color_distance(wxColour c1, wxColour c2)
+{
+    float lab[2][3];
+    RGB2Lab(c1.Red(), c1.Green(), c1.Blue(), &lab[0][0], &lab[0][1], &lab[0][2]);
+    RGB2Lab(c2.Red(), c2.Green(), c2.Blue(), &lab[1][0], &lab[1][1], &lab[1][2]);
+
+    return DeltaE76(lab[0][0], lab[0][1], lab[0][2], lab[1][0], lab[1][1], lab[1][2]);
+}
+
+void MachineObject::get_ams_colors(std::vector<wxColour> &ams_colors) {
+    m_fila_system->CollectAmsColors(ams_colors);
+}
+
+std::string MachineObject::get_firmware_type_str()
+{
+    // return product by default;
+    // always return product, printer do not push this field
+    return "product";
+}
+
+std::string MachineObject::get_lifecycle_type_str()
+{
+    // return product by default;
+    // always return product, printer do not push this field
+    return "product";
+}
+
+bool MachineObject::is_in_upgrading() const
+{
+    return m_upgrade->IsUpgrading();
+}
+
+std::string MachineObject::get_ota_version()
+{
+    auto it = module_vers.find("ota");
+    if (it != module_vers.end()) {
+        //double check name
+        if (it->second.name == "ota") {
+            return it->second.sw_ver;
+        }
+    }
+    return "";
+}
+
+bool MachineObject::check_version_valid()
+{
+    bool valid = true;
+    for (auto module : module_vers) {
+        if (module.second.sn.empty()
+            && module.first != "ota"
+            && module.first != "xm")
+            return false;
+        if (module.second.sw_ver.empty())
+            return false;
+    }
+    get_version_retry = 0;
+    return valid;
+}
+
+std::map<int, DevFirmwareVersionInfo> MachineObject::get_ams_version()
+{
+    std::vector<std::string> multi_tray_ams_type = {"ams", "n3f"};
+    std::map<int, DevFirmwareVersionInfo> result;
+    for (int i = 0; i < 8; i++) {
+        std::string ams_id;
+        for (auto type : multi_tray_ams_type)
+        {
+            ams_id = type + "/" + std::to_string(i);
+            auto it = module_vers.find(ams_id);
+            if (it != module_vers.end()) {
+                result.emplace(std::pair(i, it->second));
+            }
+        }
+    }
+
+    std::string single_tray_ams_type = "n3s";
+    int n3s_start_id = 128;
+    for (int i = n3s_start_id; i < n3s_start_id + 8; i++) {
+        std::string ams_id;
+        ams_id = single_tray_ams_type + "/" + std::to_string(i);
+        auto it = module_vers.find(ams_id);
+        if (it != module_vers.end()) {
+            result.emplace(std::pair(i, it->second));
+        }
+    }
+    return result;
+}
+
+void MachineObject::clear_version_info()
+{
+    air_pump_version_info = DevFirmwareVersionInfo();
+    laser_version_info = DevFirmwareVersionInfo();
+    cutting_module_version_info = DevFirmwareVersionInfo();
+    extinguish_version_info = DevFirmwareVersionInfo();
+    module_vers.clear();
+    m_nozzle_system->ClearFirmwareInfoWTM();
+}
+
+void MachineObject::store_version_info(const DevFirmwareVersionInfo& info)
+{
+    if (info.isAirPump()) {
+        air_pump_version_info = info;
+    } else if (info.isLaszer()) {
+        laser_version_info = info;
+    } else if (info.isCuttingModule()) {
+        cutting_module_version_info = info;
+    } else if (info.isExtinguishSystem()) {
+        extinguish_version_info = info;
+    }else if (info.isWTM()) {
+        m_nozzle_system->AddFirmwareInfoWTM(info);
+    }
+
+    module_vers.emplace(info.name, info);
+}
+
+bool MachineObject::is_system_printing()
+{
+    if (is_in_calibration() && is_in_printing_status(print_status))
+        return true;
+    //FIXME
+    //if (print_type == "system" && is_in_printing_status(print_status))
+        //return true;
+    return false;
+}
+
+bool MachineObject::check_pa_result_validation(PACalibResult& result)
+{
+    if (result.k_value < 0 || result.k_value > 10)
+        return false;
+
+    return true;
+}
+
+bool MachineObject::is_filament_at_extruder()
+{
+    if (hw_switch_state == 1)
+        return true;
+    else if (hw_switch_state == 0)
+        return false;
+    else {
+       //default
+        return true;
+    }
+}
+
+wxString MachineObject::get_curr_stage()
+{
+    if (stage_list_info.empty()) {
+        return "";
+    }
+    return get_stage_string(stage_curr);
+}
+
+int MachineObject::get_curr_stage_idx()
+{
+    int result = -1;
+    for (int i = 0; i < stage_list_info.size(); i++) {
+        if (stage_list_info[i] == stage_curr) {
+            return i;
+        }
+    }
+    return -1;
+}
+
+bool MachineObject::is_in_calibration()
+{
+    // gcode file: auto_cali_for_user.gcode or auto_cali_for_user_param
+    if (boost::contains(m_gcode_file, "auto_cali_for_user")
+        && stage_curr != 0) {
+        return true;
+    } else {
+        // reset
+        if (stage_curr != 0) {
+            calibration_done = false;
+        }
+    }
+    return false;
+}
+
+bool MachineObject::is_calibration_done()
+{
+    return calibration_done;
+}
+
+bool MachineObject::is_calibration_running()
+{
+    if (is_in_calibration() && is_in_printing_status(print_status))
+        return true;
+    return false;
+}
+
+void MachineObject::parse_state_changed_event()
+{
+    // parse calibration done
+    if (last_mc_print_stage != mc_print_stage) {
+        if (mc_print_stage == 1 && boost::contains(m_gcode_file, "auto_cali_for_user")) {
+            calibration_done = true;
+        } else {
+            calibration_done = false;
+        }
+    }
+    last_mc_print_stage = mc_print_stage;
+}
+
+void MachineObject::parse_home_flag(int flag)
+{
+    m_home_flag = flag;
+
+    is_220V_voltage = ((flag >> 3) & 0x1) != 0;
+    if (time(nullptr) - xcam_auto_recovery_hold_start > HOLD_TIME_3SEC) {
+        xcam_auto_recovery_step_loss = ((flag >> 4) & 0x1) != 0;
+    }
+
+    camera_recording            = ((flag >> 5) & 0x1) != 0;
+
+    if (time(nullptr) - ams_user_setting_start > HOLD_COUNT_MAX)
+    {
+        m_fila_system->GetAmsSystemSetting().SetDetectRemainEnabled(((flag >> 7) & 0x1) != 0);
+    }
+
+   // sdcard_state = MachineObject::SdcardState(get_flag_bits(flag, 8, 2));
+   m_storage->set_sdcard_state(get_flag_bits(flag, 8, 2));
+
+
+    if (time(nullptr) - ams_switch_filament_start > HOLD_TIME_3SEC)
+    {
+        m_fila_system->GetAmsSystemSetting().SetAutoRefillEnabled(((flag >> 10) & 0x1) != 0);
+    }
+
+    is_support_flow_calibration = ((flag >> 15) & 0x1) != 0;
+    if (this->is_series_o()) { is_support_flow_calibration = false; } // todo: Temp modification due to incorrect machine push message for H2D
+
+    is_support_pa_calibration = ((flag >> 16) & 0x1) != 0;
+    if (this->is_series_p()) { is_support_pa_calibration = false; } // todo: Temp modification due to incorrect machine push message for P
+
+    if (time(nullptr) - xcam_prompt_sound_hold_start > HOLD_TIME_3SEC) {
+        xcam_allow_prompt_sound = ((flag >> 17) & 0x1) != 0;
+    }
+
+    is_support_prompt_sound = ((flag >> 18) & 0x1) != 0;
+    is_support_filament_tangle_detect = ((flag >> 19) & 0x1) != 0;
+
+    if (time(nullptr) - xcam_filament_tangle_detect_hold_start > HOLD_TIME_3SEC) {
+        xcam_filament_tangle_detect = ((flag >> 20) & 0x1) != 0;
+    }
+
+    /*if(!is_support_motor_noise_cali){
+        is_support_motor_noise_cali = ((flag >> 21) & 0x1) != 0;
+    }*/
+    is_support_motor_noise_cali = ((flag >> 21) & 0x1) != 0;
+
+    is_support_user_preset = ((flag >> 22) & 0x1) != 0;
+
+    is_support_nozzle_blob_detection = ((flag >> 25) & 0x1) != 0;
+
+    if (time(nullptr) - nozzle_blob_detection_hold_start > HOLD_TIME_3SEC) {
+        nozzle_blob_detection_enabled = ((flag >> 24) & 0x1) != 0;
+    }
+
+    is_support_air_print_detection = ((flag >> 29) & 0x1) != 0;
+    if (auto ptr = m_fila_system->GetAmsFirmwareSwitch().lock();
+        ptr->GetCurrentFirmwareIdxRun() == DevAmsSystemFirmwareSwitch::IDX_AMS_AMS2_AMSHT) {
+        is_support_air_print_detection = false;// special case, for the firmware, air print is not supported
+    }
+    ams_air_print_status = ((flag >> 28) & 0x1) != 0;
+
+    /*if (!is_support_p1s_plus) {
+        auto supported_plus = ((flag >> 27) & 0x1) != 0;
+        auto installed_plus = ((flag >> 26) & 0x1) != 0;
+
+        if (installed_plus && supported_plus) {
+            is_support_p1s_plus = true;
+        }
+        else {
+            is_support_p1s_plus = false;
+        }
+    }*/
+
+    is_support_upgrade_kit = ((flag >> 27) & 0x1) != 0;
+    installed_upgrade_kit = ((flag >> 26) & 0x1) != 0;
+
+    is_support_agora = ((flag >> 30) & 0x1) != 0;
+    if (is_support_agora)
+        is_support_tunnel_mqtt = false;
+}
+
+int MachineObject::get_bed_temperature_limit()
+{
+    if (get_printer_series() == PrinterSeries::SERIES_X1) {
+        if (is_220V_voltage)
+            return 110;
+        else {
+            return 120;
+        }
+    } else {
+        int limit = bed_temperature_limit < 0?BED_TEMP_LIMIT:bed_temperature_limit;
+        return limit;
+    }
+    return BED_TEMP_LIMIT;
+}
+
+bool MachineObject::is_filament_installed()
+{
+    if (m_extder_system->GetTotalExtderCount() > 0) {
+        // right//or single
+        auto ext = m_extder_system->m_extders[MAIN_EXTRUDER_ID];
+        if (ext.m_ext_has_filament) {
+            return true;
+        }
+    }
+    /*left*/
+    if (m_extder_system->GetTotalExtderCount() > 1) {
+        auto ext = m_extder_system->m_extders[DEPUTY_EXTRUDER_ID];
+        if (ext.m_ext_has_filament) {
+            return true;
+        }
+    }
+    return false;
+}
+
+bool MachineObject::is_makeworld_subtask()
+{
+    if (model_task && model_task->design_id > 0) {
+        BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " model task id: " << model_task->task_id << " is makeworld model";
+        return true;
+    }
+    return false;
+}
+
+bool MachineObject::is_sdcard_printing()
+{
+    if (can_abort()
+        && (obj_subtask_id.compare("0") == 0 || obj_subtask_id.empty())
+        && (profile_id_ == "0" || profile_id_.empty())
+        && (project_id_ == "0" || project_id_.empty()))
+        return true;
+    else
+        return false;
+}
+
+
+
+bool MachineObject::is_timelapse()
+{
+    return camera_timelapse;
+}
+
+bool MachineObject::is_recording_enable()
+{
+    return camera_recording_when_printing;
+}
+
+bool MachineObject::is_recording()
+{
+    return camera_recording;
+}
+
+int MachineObject::get_liveview_remote()
+{
+    if (is_support_agora) {
+        return liveview_remote == LVR_None ? LVR_Agora : liveview_remote == LVR_Tutk ? LVR_TutkAgora : liveview_remote;
+    }
+    return liveview_remote;
+}
+
+int MachineObject::get_file_remote()
+{
+    if (is_support_agora)
+        file_remote = file_remote == FR_None ? FR_Agora : file_remote == FR_Tutk ? FR_TutkAgora : file_remote;
+    return file_remote;
+}
+
+std::string MachineObject::parse_version()
+{
+    auto ota_version = module_vers.find("ota");
+    if (ota_version != module_vers.end()) return ota_version->second.sw_ver;
+    auto series = get_printer_series();
+    if (series == PrinterSeries::SERIES_X1) {
+        auto rv1126_version = module_vers.find("rv1126");
+        if (rv1126_version != module_vers.end()) return rv1126_version->second.sw_ver;
+    } else if (series == PrinterSeries::SERIES_P1P) {
+        auto esp32_version = module_vers.find("esp32");
+        if (esp32_version != module_vers.end()) return esp32_version->second.sw_ver;
+    }
+    return "";
+}
+
+void MachineObject::parse_version_func()
+{
+}
+
+bool MachineObject::canEnableTimelapse(wxString &error_message) const
+{
+    if (!is_support_timelapse) {
+        error_message = _L("Timelapse is not supported on this printer.");
+        return false;
+    }
+
+    if (is_support_internal_timelapse)
+    {
+        return true;
+    }
+
+    if (m_storage->get_sdcard_state() != DevStorage::SdcardState::HAS_SDCARD_NORMAL) {
+        if (m_storage->get_sdcard_state() == DevStorage::SdcardState::NO_SDCARD) {
+            error_message = _L("Timelapse is not supported while the storage does not exist.");
+        } else if (m_storage->get_sdcard_state() == DevStorage::SdcardState::HAS_SDCARD_ABNORMAL) {
+            error_message = _L("Timelapse is not supported while the storage is unavailable.");
+        } else if (m_storage->get_sdcard_state() == DevStorage::SdcardState::HAS_SDCARD_READONLY) {
+            error_message = _L("Timelapse is not supported while the storage is readonly.");
+        }
+
+        return false;
+    }
+
+    return true;
+}
+
+int MachineObject::command_get_version(bool with_retry)
+{
+    json j;
+    j["info"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["info"]["command"] = "get_version";
+    if (with_retry)
+        get_version_retry = GET_VERSION_RETRYS;
+    return this->publish_json(j, 1);
+}
+
+int MachineObject::command_get_access_code() {
+    json j;
+    j["system"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["system"]["command"] = "get_access_code";
+
+    return this->publish_json(j);
+}
+
+
+int MachineObject::command_request_push_all(bool request_now)
+{
+    auto curr_time = std::chrono::system_clock::now();
+    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(curr_time - last_request_push);
+
+    if (diff.count() < REQUEST_PUSH_MIN_TIME) {
+        if (request_now) {
+            BOOST_LOG_TRIVIAL(trace) << "static: command_request_push_all, dev_id=" << BBLCrossTalk::Crosstalk_DevId(get_dev_id());
+            last_request_push = std::chrono::system_clock::now();
+        }
+        else {
+            BOOST_LOG_TRIVIAL(trace) << "static: command_request_push_all: send request too fast, dev_id=" << BBLCrossTalk::Crosstalk_DevId(get_dev_id());
+            return -1;
+        }
+    } else {
+        BOOST_LOG_TRIVIAL(trace) << "static: command_request_push_all, dev_id=" << BBLCrossTalk::Crosstalk_DevId(get_dev_id());
+        last_request_push = std::chrono::system_clock::now();
+    }
+
+    json j;
+    j["pushing"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["pushing"]["command"]     = "pushall";
+    j["pushing"]["version"]     =  1;
+    j["pushing"]["push_target"] =  1;
+    return this->publish_json(j);
+}
+
+int MachineObject::command_pushing(std::string cmd)
+{
+    auto curr_time = std::chrono::system_clock::now();
+    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(curr_time - last_request_start);
+    if (diff.count() < REQUEST_START_MIN_TIME) {
+        BOOST_LOG_TRIVIAL(trace) << "static: command_request_start: send request too fast, dev_id=" << BBLCrossTalk::Crosstalk_DevId(get_dev_id());
+        return -1;
+    }
+    else {
+        BOOST_LOG_TRIVIAL(trace) << "static: command_request_start, dev_id=" << BBLCrossTalk::Crosstalk_DevId(get_dev_id());
+        last_request_start = std::chrono::system_clock::now();
+    }
+
+    if (cmd == "start" || cmd == "stop") {
+        json j;
+        j["pushing"]["command"] = cmd;
+        j["pushing"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+        return this->publish_json(j);
+    }
+    return -1;
+}
+
+int MachineObject::command_clean_print_error(std::string subtask_id, int print_error)
+{
+    json j;
+    j["print"]["command"] = "clean_print_error";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["subtask_id"] = subtask_id;
+    j["print"]["print_error"] = print_error;
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_clean_print_error_uiop(int print_error)
+{
+    json j;
+    j["system"]["command"] = "uiop";
+    j["system"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["system"]["name"] = "print_error";
+    j["system"]["action"] = "close";
+    j["system"]["source"] = 1;// 0-Mushu 1-Studio
+    j["system"]["type"] = "dialog";
+
+    // the error to be cleaned
+    char buf[32];
+    ::sprintf(buf, "%08X", print_error);
+    j["system"]["err"] = std::string(buf);
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_task_partskip(std::vector<int> part_ids)
+{
+    json j;
+    j["print"]["command"] = "skip_objects";
+    j["print"]["obj_list"] = part_ids;
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+
+    return this->publish_json(j, 1);
+}
+
+int MachineObject::command_task_abort()
+{
+    json j;
+    j["print"]["command"] = "stop";
+    j["print"]["param"] = "";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+
+    return this->publish_json(j, 1);
+}
+
+int MachineObject::command_task_cancel(std::string job_id)
+{
+    json j;
+    j["print"]["command"] = "stop";
+    j["print"]["param"] = "";
+    j["print"]["job_id"] = job_id;
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+
+    return this->publish_json(j, 1);
+}
+
+int MachineObject::command_task_pause()
+{
+    json j;
+    j["print"]["command"] = "pause";
+    j["print"]["param"] = "";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+
+    return this->publish_json(j, 1);
+}
+
+int MachineObject::command_task_resume()
+{
+    if(check_resume_condition()) return 0;
+
+    json j;
+    j["print"]["command"] = "resume";
+    j["print"]["param"] = "";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+
+    return this->publish_json(j, 1);
+}
+
+int MachineObject::command_hms_idle_ignore(const std::string &error_str, int type)
+{
+    if(check_resume_condition()) return 0;
+
+    json j;
+    j["print"]["command"]     = "idle_ignore";
+    j["print"]["err"]         = error_str;
+    j["print"]["type"]        = type;
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    return this->publish_json(j, 1);
+}
+
+int MachineObject::command_hms_resume(const std::string& error_str, const std::string& job_id)
+{
+    if(check_resume_condition()) return 0;
+
+    json j;
+    j["print"]["command"] = "resume";
+    j["print"]["err"] = error_str;
+    j["print"]["param"] = "reserve";
+    j["print"]["job_id"] = job_id;
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+
+    return this->publish_json(j, 1);
+}
+
+int MachineObject::command_hms_ignore(const std::string& error_str, const std::string& job_id)
+{
+    if(check_resume_condition()) return 0;
+
+    json j;
+    j["print"]["command"] = "ignore";
+    j["print"]["err"] = error_str;
+    j["print"]["param"] = "reserve";
+    j["print"]["job_id"] = job_id;
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+
+    return this->publish_json(j, 1);
+}
+
+int MachineObject::command_hms_stop(const std::string &error_str, const std::string &job_id) {
+    json j;
+    j["print"]["command"]     = "stop";
+    j["print"]["err"]         = error_str;
+    j["print"]["param"]       = "reserve";
+    j["print"]["job_id"]      = job_id;
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+
+    return this->publish_json(j, 1);
+}
+
+int MachineObject::command_stop_buzzer()
+{
+    json j;
+    j["print"]["command"] = "buzzer_ctrl";
+    j["print"]["mode"] = 0;
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+
+    return this->publish_json(j, 1);
+}
+
+int MachineObject::command_set_bed(int temp)
+{
+    if (m_support_mqtt_bet_ctrl)
+    {
+        json j;
+        j["print"]["command"] = "set_bed_temp";
+        j["print"]["temp"] = temp;
+        j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+        return this->publish_json(j);
+    }
+
+    std::string gcode_str = (boost::format("M140 S%1%\n") % temp).str();
+    try {
+        json j;
+        j["ctrl_type"] = "bed_temp";
+        j["value"] = temp;
+
+        NetworkAgent* agent = GUI::wxGetApp().getAgent();
+        if (agent) agent->track_event("printer_control", j.dump());
+    }
+    catch (...) {}
+
+    return this->publish_gcode(gcode_str);
+}
+
+int MachineObject::command_set_nozzle(int temp)
+{
+    std::string gcode_str = (boost::format("M104 S%1%\n") % temp).str();
+    try {
+        json j;
+        j["ctrl_type"] = "nozzle_temp";
+        j["value"] = temp;
+
+        NetworkAgent* agent = GUI::wxGetApp().getAgent();
+        if (agent) agent->track_event("printer_control", j.dump());
+    }
+    catch (...) {}
+    return this->publish_gcode(gcode_str);
+}
+
+int MachineObject::command_set_nozzle_new(int nozzle_id, int temp)
+{
+    json j;
+    j["print"]["sequence_id"]    = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["command"]        = "set_nozzle_temp";
+    j["print"]["extruder_index"] = nozzle_id;
+    j["print"]["target_temp"]    = temp;
+
+    return this->publish_json(j, 1);
+}
+
+int MachineObject::command_refresh_nozzle(){
+    json j;
+    j["print"]["sequence_id"]    = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["command"]        = "refresh_nozzle";
+
+    return this->publish_json(j, 1);
+}
+
+int MachineObject::check_resume_condition()
+{
+    if (jobState_ > 1) {
+        GUI::wxGetApp().show_dialog(_L("To ensure your safety, certain processing tasks (such as laser) can only be resumed on printer."));
+        return 1;
+    }
+    return 0;
+}
+
+int MachineObject::command_ams_change_filament(bool load, std::string ams_id, std::string slot_id, int old_temp, int new_temp)
+{
+    json j;
+    try {
+        auto tray_id = 0;
+        if (atoi(ams_id.c_str()) < 16) {
+            tray_id = atoi(ams_id.c_str()) * 4 + atoi(slot_id.c_str());
+        }
+
+        j["print"]["command"]     = "ams_change_filament";
+        j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+        j["print"]["curr_temp"]   = old_temp;
+        j["print"]["tar_temp"]    = new_temp;
+        j["print"]["ams_id"]      = atoi(ams_id.c_str());
+
+        if (!load) {
+            j["print"]["target"]  = 255;
+            j["print"]["slot_id"] = 255; // the new protocol to mark unload
+
+        } else {
+            if (tray_id == 0) {
+                j["print"]["target"]  = atoi(ams_id.c_str());
+            } else {
+                j["print"]["target"]  = tray_id;
+            }
+
+            j["print"]["slot_id"] = atoi(slot_id.c_str());
+        }
+
+    } catch (const std::exception &) {}
+    return this->publish_json(j);
+}
+
+int MachineObject::command_ams_user_settings(bool start_read_opt, bool tray_read_opt, bool remain_flag)
+{
+    json j;
+    j["print"]["command"] = "ams_user_setting";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["ams_id"] = -1; // all ams
+    j["print"]["startup_read_option"]   = start_read_opt;
+    j["print"]["tray_read_option"]      = tray_read_opt;
+    j["print"]["calibrate_remain_flag"] = remain_flag;
+
+    m_fila_system->GetAmsSystemSetting().SetDetectOnInsertEnabled(tray_read_opt);
+    m_fila_system->GetAmsSystemSetting().SetDetectOnPowerupEnabled(start_read_opt);
+    m_fila_system->GetAmsSystemSetting().SetDetectRemainEnabled(remain_flag);
+    ams_user_setting_start = time(nullptr);
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_ams_calibrate(int ams_id)
+{
+    std::string gcode_cmd = (boost::format("M620 C%1% \n") % ams_id).str();
+    BOOST_LOG_TRIVIAL(trace) << "ams_debug: gcode_cmd" << gcode_cmd;
+    return this->publish_gcode(gcode_cmd);
+}
+
+int MachineObject::command_ams_filament_settings(int ams_id, int slot_id, std::string filament_id, std::string setting_id, std::string tray_color, std::string tray_type, int nozzle_temp_min, int nozzle_temp_max)
+{
+    int tag_tray_id = 0;
+    int tag_ams_id  = ams_id;
+    int tag_slot_id = slot_id;
+
+    if (tag_ams_id == VIRTUAL_TRAY_MAIN_ID || tag_ams_id == VIRTUAL_TRAY_DEPUTY_ID) {
+        tag_tray_id = VIRTUAL_TRAY_DEPUTY_ID;
+    } else {
+        tag_tray_id = tag_slot_id;
+    }
+
+    json j;
+    j["print"]["command"]       = "ams_filament_setting";
+    j["print"]["sequence_id"]   = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["ams_id"]        = tag_ams_id;
+    j["print"]["slot_id"]       = tag_slot_id;
+    j["print"]["tray_id"]       = tag_tray_id;
+    j["print"]["tray_info_idx"] = filament_id;
+    j["print"]["setting_id"]    = setting_id;
+    // format "FFFFFFFF"   RGBA
+    j["print"]["tray_color"]        = tray_color;
+    j["print"]["nozzle_temp_min"]   = nozzle_temp_min;
+    j["print"]["nozzle_temp_max"]   = nozzle_temp_max;
+    j["print"]["tray_type"]         = tray_type;
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_ams_refresh_rfid(std::string tray_id)
+{
+    std::string gcode_cmd = (boost::format("M620 R%1% \n") % tray_id).str();
+    BOOST_LOG_TRIVIAL(trace) << "ams_debug: gcode_cmd" << gcode_cmd;
+    return this->publish_gcode(gcode_cmd);
+}
+
+int MachineObject::command_ams_refresh_rfid2(int ams_id,  int slot_id)
+{
+    json j;
+    j["print"]["command"]       = "ams_get_rfid";
+    j["print"]["sequence_id"]   = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["ams_id"]        = ams_id;
+    j["print"]["slot_id"]       = slot_id;
+    return this->publish_json(j);
+}
+
+
+int MachineObject::command_ams_select_tray(std::string tray_id)
+{
+    std::string gcode_cmd = (boost::format("M620 P%1% \n") % tray_id).str();
+    BOOST_LOG_TRIVIAL(trace) << "ams_debug: gcode_cmd" << gcode_cmd;
+    return this->publish_gcode(gcode_cmd);
+}
+
+int MachineObject::command_ams_control(std::string action)
+{
+    if (action == "resume" && check_resume_condition()) return 0;
+
+    //valid actions
+    if (action == "resume" || action == "reset" || action == "pause" || action == "done" || action == "abort") {
+        json j;
+        j["print"]["command"] = "ams_control";
+        j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+        j["print"]["param"] = action;
+        return this->publish_json(j);
+    }
+    return -1;
+}
+
+int MachineObject::command_ams_drying_stop()
+{
+    json j;
+    j["print"]["command"] = "auto_stop_ams_dry";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    return this->publish_json(j);
+}
+
+int MachineObject::command_start_extrusion_cali(int tray_index, int nozzle_temp, int bed_temp, float max_volumetric_speed, std::string setting_id)
+{
+    BOOST_LOG_TRIVIAL(trace) << "extrusion_cali: tray_id = " << tray_index << ", nozzle_temp = " << nozzle_temp << ", bed_temp = " << bed_temp
+                            << ", max_volumetric_speed = " << max_volumetric_speed;
+
+    json j;
+    j["print"]["command"] = "extrusion_cali";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["tray_id"] = tray_index;
+    //j["print"]["setting_id"] = setting_id;
+    //j["print"]["name"] = "";
+    j["print"]["nozzle_temp"] = nozzle_temp;
+    j["print"]["bed_temp"] = bed_temp;
+    j["print"]["max_volumetric_speed"] = max_volumetric_speed;
+
+    // enter extusion cali
+    last_extrusion_cali_start_time = std::chrono::system_clock::now();
+    return this->publish_json(j);
+}
+
+int MachineObject::command_stop_extrusion_cali()
+{
+    BOOST_LOG_TRIVIAL(trace) << "extrusion_cali: stop";
+    if (is_in_extrusion_cali()) {
+        return command_task_abort();
+    }
+    return 0;
+}
+
+int MachineObject::command_extrusion_cali_set(int tray_index, std::string setting_id, std::string name, float k, float n, int bed_temp, int nozzle_temp, float max_volumetric_speed)
+{
+    json j;
+    j["print"]["command"] = "extrusion_cali_set";
+    j["print"]["sequence_id"]   = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["tray_id"]       = tray_index;
+    //j["print"]["setting_id"]    = setting_id;
+    //j["print"]["name"]          = name;
+    j["print"]["k_value"]       = k;
+    j["print"]["n_coef"]        = 1.4f;     // fixed n
+    //j["print"]["n_coef"]        = n;
+    if (bed_temp >= 0 && nozzle_temp >= 0 && max_volumetric_speed >= 0) {
+        j["print"]["bed_temp"]      = bed_temp;
+        j["print"]["nozzle_temp"]   = nozzle_temp;
+        j["print"]["max_volumetric_speed"] = max_volumetric_speed;
+    }
+    return this->publish_json(j);
+}
+
+
+int MachineObject::command_set_printing_speed(DevPrintingSpeedLevel lvl)
+{
+    json j;
+    j["print"]["command"] = "print_speed";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["param"] = std::to_string((int)lvl);
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_set_printing_option(bool auto_recovery)
+{
+    int print_option = (int)auto_recovery << (int)PRINT_OP_AUTO_RECOVERY;
+    json j;
+    j["print"]["command"]       = "print_option";
+    j["print"]["sequence_id"]   = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["option"]        = print_option;
+    j["print"]["auto_recovery"] = auto_recovery;
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_nozzle_blob_detect(bool nozzle_blob_detect)
+{
+    json j;
+    j["print"]["command"] = "print_option";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["nozzle_blob_detect"] = nozzle_blob_detect;
+    nozzle_blob_detection_enabled = nozzle_blob_detect;
+    nozzle_blob_detection_hold_start = time(nullptr);
+    return this->publish_json(j);
+}
+
+int MachineObject::command_set_prompt_sound(bool prompt_sound){
+    json j;
+    j["print"]["command"] = "print_option";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["sound_enable"] = prompt_sound;
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_set_filament_tangle_detect(bool filament_tangle_detect) {
+    json j;
+    j["print"]["command"] = "print_option";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["filament_tangle_detect"] = filament_tangle_detect;
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_ams_switch_filament(bool switch_filament)
+{
+    json j;
+    j["print"]["command"] = "print_option";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["auto_switch_filament"] = switch_filament;
+
+    m_fila_system->GetAmsSystemSetting().SetAutoRefillEnabled(switch_filament);
+    BOOST_LOG_TRIVIAL(trace) << "command_ams_filament_settings:" << switch_filament;
+    ams_switch_filament_start = time(nullptr);
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_ams_air_print_detect(bool air_print_detect)
+{
+    json j;
+    j["print"]["command"] = "print_option";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["air_print_detect"] = air_print_detect;
+
+    ams_air_print_status = air_print_detect;
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_extruder_control(int nozzle_id, double val)
+{
+    json j;
+    j["print"]["command"]     = "set_extrusion_length";
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["extruder_index"] = nozzle_id;
+    j["print"]["length"] = (int)val;
+    return this->publish_json(j);
+}
+
+bool MachineObject::is_support_command_calibration()
+{
+    if (get_printer_series() == PrinterSeries::SERIES_X1) {
+        auto ap_ver_it = module_vers.find("rv1126");
+        if (ap_ver_it != module_vers.end()) {
+            if (ap_ver_it->second.sw_ver.compare("00.00.15.79") < 0)
+                return false;
+        }
+    }
+    return true;
+}
+
+int MachineObject::command_start_calibration(bool vibration, bool bed_leveling, bool xcam_cali, bool motor_noise, bool nozzle_cali, bool bed_cali, bool clumppos_cali)
+{
+    if (!is_support_command_calibration()) {
+        // fixed gcode file
+        json j;
+        j["print"]["command"] = "gcode_file";
+        j["print"]["param"] = "/usr/etc/print/auto_cali_for_user.gcode";
+        j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+        return this->publish_json(j);
+    } else {
+        json j;
+        j["print"]["command"] = "calibration";
+        j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+        j["print"]["option"]  = +   (clumppos_cali ? 1 << 6 : 0)
+                                +   (bed_cali     ? 1 << 5 : 0)
+                                +   (nozzle_cali  ? 1 << 4 : 0)
+                                +   (motor_noise  ? 1 << 3 : 0)
+                                +   (vibration    ? 1 << 2 : 0)
+                                +   (bed_leveling ? 1 << 1 : 0)
+                                +   (xcam_cali    ? 1 << 0 : 0);
+        return this->publish_json(j);
+    }
+}
+
+int MachineObject::command_start_pa_calibration(const X1CCalibInfos &pa_data, int mode)
+{
+    CNumericLocalesSetter locales_setter;
+
+    pa_calib_results.clear();
+    json j;
+    j["print"]["command"]         = "extrusion_cali";
+    j["print"]["sequence_id"]     = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["nozzle_diameter"] = to_string_nozzle_diameter(pa_data.calib_datas[0].nozzle_diameter);
+    j["print"]["mode"]            = mode;
+
+    std::string filament_ids;
+    for (int i = 0; i < pa_data.calib_datas.size(); ++i) {
+        j["print"]["filaments"][i]["tray_id"]              = pa_data.calib_datas[i].tray_id;
+        j["print"]["filaments"][i]["extruder_id"]          = pa_data.calib_datas[i].extruder_id;
+        j["print"]["filaments"][i]["bed_temp"]             = pa_data.calib_datas[i].bed_temp;
+        j["print"]["filaments"][i]["filament_id"]          = pa_data.calib_datas[i].filament_id;
+        j["print"]["filaments"][i]["setting_id"]           = pa_data.calib_datas[i].setting_id;
+        j["print"]["filaments"][i]["nozzle_temp"]          = pa_data.calib_datas[i].nozzle_temp;
+        j["print"]["filaments"][i]["ams_id"]               = pa_data.calib_datas[i].ams_id;
+        j["print"]["filaments"][i]["slot_id"]              = pa_data.calib_datas[i].slot_id;
+        j["print"]["filaments"][i]["nozzle_id"]            = _generate_nozzle_id(pa_data.calib_datas[i].nozzle_volume_type,to_string_nozzle_diameter(pa_data.calib_datas[i].nozzle_diameter)).ToStdString();
+        j["print"]["filaments"][i]["nozzle_diameter"]      = to_string_nozzle_diameter(pa_data.calib_datas[i].nozzle_diameter);
+        j["print"]["filaments"][i]["max_volumetric_speed"] = std::to_string(pa_data.calib_datas[i].max_volumetric_speed);
+
+        if (i > 0) filament_ids += ",";
+        filament_ids += pa_data.calib_datas[i].filament_id;
+    }
+
+    try {
+        json js;
+        js["cali_type"]       = "cali_pa_auto";
+        js["nozzle_diameter"] = pa_data.calib_datas[0].nozzle_diameter;
+        js["filament_id"]     = filament_ids;
+        js["printer_type"]    = this->printer_type;
+        NetworkAgent *agent   = GUI::wxGetApp().getAgent();
+        if (agent) agent->track_event("cali", js.dump());
+    } catch (...) {}
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_set_pa_calibration(const std::vector<PACalibResult> &pa_calib_values, bool is_auto_cali)
+{
+    CNumericLocalesSetter locales_setter;
+
+    if (pa_calib_values.size() > 0) {
+        json j;
+        j["print"]["command"]     = "extrusion_cali_set";
+        j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+        j["print"]["nozzle_diameter"] = to_string_nozzle_diameter(pa_calib_values[0].nozzle_diameter);
+
+        for (int i = 0; i < pa_calib_values.size(); ++i) {
+            if (pa_calib_values[i].tray_id >= 0)
+                j["print"]["filaments"][i]["tray_id"] = pa_calib_values[i].tray_id;
+            if (pa_calib_values[i].cali_idx >= 0)
+                j["print"]["filaments"][i]["cali_idx"] = pa_calib_values[i].cali_idx;
+            j["print"]["filaments"][i]["tray_id"]     = pa_calib_values[i].tray_id;
+            j["print"]["filaments"][i]["extruder_id"] = pa_calib_values[i].extruder_id;
+            j["print"]["filaments"][i]["nozzle_id"]   = _generate_nozzle_id(pa_calib_values[i].nozzle_volume_type, to_string_nozzle_diameter(pa_calib_values[i].nozzle_diameter)).ToStdString();
+            j["print"]["filaments"][i]["nozzle_diameter"] = to_string_nozzle_diameter(pa_calib_values[i].nozzle_diameter);
+            j["print"]["filaments"][i]["ams_id"]      = pa_calib_values[i].ams_id;
+            j["print"]["filaments"][i]["slot_id"]     = pa_calib_values[i].slot_id;
+            j["print"]["filaments"][i]["filament_id"] = pa_calib_values[i].filament_id;
+            j["print"]["filaments"][i]["setting_id"]  = pa_calib_values[i].setting_id;
+            j["print"]["filaments"][i]["name"]        = pa_calib_values[i].name;
+            j["print"]["filaments"][i]["k_value"]     = std::to_string(pa_calib_values[i].k_value);
+            if (is_auto_cali)
+                j["print"]["filaments"][i]["n_coef"] = std::to_string(pa_calib_values[i].n_coef);
+            else
+                j["print"]["filaments"][i]["n_coef"]  = "0.0";
+            if (pa_calib_values[i].nozzle_pos_id >= 0) {
+                j["print"]["filaments"][i]["nozzle_pos"]  = pa_calib_values[i].nozzle_pos_id;
+                j["print"]["filaments"][i]["nozzle_sn"]   = pa_calib_values[i].nozzle_sn;
+            }
+        }
+
+        return this->publish_json(j);
+    }
+
+    return -1;
+}
+
+int MachineObject::command_delete_pa_calibration(const PACalibIndexInfo& pa_calib)
+{
+    json j;
+    j["print"]["command"]         = "extrusion_cali_del";
+    j["print"]["sequence_id"]     = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["extruder_id"]     = pa_calib.extruder_id;
+    j["print"]["nozzle_id"]       = _generate_nozzle_id(pa_calib.nozzle_volume_type, to_string_nozzle_diameter(pa_calib.nozzle_diameter)).ToStdString();
+    j["print"]["filament_id"]     = pa_calib.filament_id;
+    j["print"]["cali_idx"]        = pa_calib.cali_idx;
+    if (pa_calib.nozzle_pos_id >= 0) {
+        j["print"]["nozzle_pos"] = pa_calib.nozzle_pos_id;
+        j["print"]["nozzle_sn"]  = pa_calib.nozzle_sn;
+    }
+    j["print"]["nozzle_diameter"] = to_string_nozzle_diameter(pa_calib.nozzle_diameter);
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_get_pa_calibration_tab(const PACalibExtruderInfo &calib_info)
+{
+    reset_pa_cali_history_result();
+
+    json j;
+    j["print"]["command"]         = "extrusion_cali_get";
+    j["print"]["sequence_id"]     = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["filament_id"]     = calib_info.filament_id;
+    if (calib_info.use_extruder_id)
+        j["print"]["extruder_id"] = calib_info.extruder_id;
+    if (calib_info.use_nozzle_volume_type)
+        j["print"]["nozzle_id"] = _generate_nozzle_id(calib_info.nozzle_volume_type, to_string_nozzle_diameter(calib_info.nozzle_diameter)).ToStdString();
+    j["print"]["nozzle_diameter"] = to_string_nozzle_diameter(calib_info.nozzle_diameter);
+
+    if (calib_info.nozzle_pos_id >= 0) {
+        j["print"]["nozzle_pos"] = calib_info.nozzle_pos_id;
+        j["print"]["nozzle_sn"]  = calib_info.nozzle_sn;
+    }
+
+    request_tab_from_bbs = true;
+    return this->publish_json(j);
+}
+
+int MachineObject::command_get_pa_calibration_result(float nozzle_diameter)
+{
+    json j;
+    j["print"]["command"]         = "extrusion_cali_get_result";
+    j["print"]["sequence_id"]     = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["nozzle_diameter"] = to_string_nozzle_diameter(nozzle_diameter);
+
+    return this->publish_json(j);
+}
+
+int MachineObject::commnad_select_pa_calibration(const PACalibIndexInfo& pa_calib_info)
+{
+    json j;
+    j["print"]["command"]         = "extrusion_cali_sel";
+    j["print"]["sequence_id"]     = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["tray_id"]         = pa_calib_info.tray_id;
+    j["print"]["ams_id"]          = pa_calib_info.ams_id;
+    j["print"]["slot_id"]         = pa_calib_info.slot_id;
+    j["print"]["cali_idx"]        = pa_calib_info.cali_idx;
+    j["print"]["filament_id"]     = pa_calib_info.filament_id;
+    if (pa_calib_info.nozzle_pos_id >= 0) {
+        j["print"]["nozzle_pos"]  = pa_calib_info.nozzle_pos_id;
+        j["print"]["nozzle_sn"]   = pa_calib_info.nozzle_sn;
+    }
+    j["print"]["nozzle_diameter"] = to_string_nozzle_diameter(pa_calib_info.nozzle_diameter);
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_start_flow_ratio_calibration(const X1CCalibInfos& calib_data)
+{
+    CNumericLocalesSetter locales_setter;
+
+    if (calib_data.calib_datas.size() > 0) {
+        json j;
+        j["print"]["command"]     = "flowrate_cali";
+        j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+        j["print"]["tray_id"] = calib_data.calib_datas[0].tray_id;
+        j["print"]["nozzle_diameter"] = to_string_nozzle_diameter(calib_data.calib_datas[0].nozzle_diameter);
+
+        std::string filament_ids;
+        for (int i = 0; i < calib_data.calib_datas.size(); ++i) {
+            j["print"]["filaments"][i]["tray_id"]              = calib_data.calib_datas[i].tray_id;
+            j["print"]["filaments"][i]["bed_temp"]             = calib_data.calib_datas[i].bed_temp;
+            j["print"]["filaments"][i]["filament_id"]          = calib_data.calib_datas[i].filament_id;
+            j["print"]["filaments"][i]["setting_id"]           = calib_data.calib_datas[i].setting_id;
+            j["print"]["filaments"][i]["nozzle_temp"]          = calib_data.calib_datas[i].nozzle_temp;
+            j["print"]["filaments"][i]["def_flow_ratio"]       = std::to_string(calib_data.calib_datas[i].flow_rate);
+            j["print"]["filaments"][i]["max_volumetric_speed"] = std::to_string(calib_data.calib_datas[i].max_volumetric_speed);
+            j["print"]["filaments"][i]["extruder_id"]          = calib_data.calib_datas[i].extruder_id;
+            j["print"]["filaments"][i]["ams_id"]               = calib_data.calib_datas[i].ams_id;
+            j["print"]["filaments"][i]["slot_id"]              = calib_data.calib_datas[i].slot_id;
+
+            if (i > 0)
+                filament_ids += ",";
+            filament_ids += calib_data.calib_datas[i].filament_id;
+        }
+
+        try {
+            json js;
+            js["cali_type"]     = "cali_flow_rate_auto";
+            js["nozzle_diameter"] = calib_data.calib_datas[0].nozzle_diameter;
+            js["filament_id"]     = filament_ids;
+            js["printer_type"]    = this->printer_type;
+            NetworkAgent *agent = GUI::wxGetApp().getAgent();
+            if (agent) agent->track_event("cali", js.dump());
+        } catch (...) {}
+
+        return this->publish_json(j);
+    }
+    return -1;
+}
+
+int MachineObject::command_get_flow_ratio_calibration_result(float nozzle_diameter)
+{
+    json j;
+    j["print"]["command"]         = "flowrate_get_result";
+    j["print"]["sequence_id"]     = std::to_string(MachineObject::m_sequence_id++);
+    j["print"]["nozzle_diameter"] = to_string_nozzle_diameter(nozzle_diameter);
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_ipcam_record(bool on_off)
+{
+    json j;
+    j["camera"]["command"] = "ipcam_record_set";
+    j["camera"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["camera"]["control"] = on_off ? "enable" : "disable";
+    camera_recording_ctl_start          = time(nullptr);
+    this->camera_recording_when_printing = on_off;
+    return this->publish_json(j);
+}
+
+int MachineObject::command_ipcam_timelapse(bool on_off)
+{
+    json j;
+    j["camera"]["command"] = "ipcam_timelapse";
+    j["camera"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["camera"]["control"] = on_off ? "enable" : "disable";
+    camera_timelapse_hold_count = HOLD_COUNT_CAMERA;
+    this->camera_timelapse = on_off;
+    return this->publish_json(j);
+}
+
+int MachineObject::command_ipcam_resolution_set(std::string resolution)
+{
+    json j;
+    j["camera"]["command"] = "ipcam_resolution_set";
+    j["camera"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["camera"]["resolution"] = resolution;
+    camera_resolution_hold_count = HOLD_COUNT_CAMERA;
+    camera_recording_ctl_start = time(nullptr);
+    this->camera_resolution = resolution;
+    return this->publish_json(j);
+}
+
+int MachineObject::command_xcam_control(std::string module_name, bool on_off, std::string lvl)
+{
+    json j;
+    j["xcam"]["command"] = "xcam_control_set";
+    j["xcam"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+    j["xcam"]["module_name"] = module_name;
+    j["xcam"]["control"] = on_off;
+    j["xcam"]["enable"] = on_off;       //old protocol
+    j["xcam"]["print_halt"]  = true;    //old protocol
+    if (!lvl.empty()) {
+        j["xcam"]["halt_print_sensitivity"] = lvl;
+    }
+
+    return this->publish_json(j);
+}
+
+int MachineObject::command_ack_proceed(json& proceed) {
+    if (proceed["command"].empty()) return -1;
+
+    proceed["err_code"] = 0;
+    if (proceed.contains("err_ignored")) {
+        proceed["err_ignored"].push_back(proceed["err_index"]);
+    } else {
+        proceed["err_ignored"] = std::vector<int>{proceed["err_index"]};
+    }
+    proceed["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+
+    json j;
+    j["print"] = proceed;
+    return this->publish_json(j);
+}
+
+int MachineObject::command_xcam_control_ai_monitoring(bool on_off, std::string lvl)
+{
+    bool print_halt = (lvl == "never_halt") ? false:true;
+
+    xcam_ai_monitoring = on_off;
+    xcam_ai_monitoring_hold_start  = time(nullptr);
+    xcam_ai_monitoring_sensitivity = lvl;
+    return command_xcam_control("printing_monitor", on_off, lvl);
+}
+
+// refine printer function options
+int MachineObject::command_xcam_control_spaghetti_detection(bool on_off, std::string lvl)
+{
+    bool print_halt = (lvl == "never_halt") ? false : true;
+
+    xcam_spaghetti_detection       = on_off;
+    xcam_ai_monitoring_hold_start  = time(nullptr);
+    xcam_spaghetti_detection_sensitivity = lvl;
+    return command_xcam_control("spaghetti_detector", on_off, lvl);
+}
+
+int MachineObject::command_xcam_control_purgechutepileup_detection(bool on_off, std::string lvl)
+{
+    bool print_halt = (lvl == "never_halt") ? false : true;
+
+    xcam_purgechutepileup_detection = on_off;
+    xcam_ai_monitoring_hold_start  = time(nullptr);
+    xcam_purgechutepileup_detection_sensitivity = lvl;
+    return command_xcam_control("pileup_detector", on_off, lvl);
+}
+
+int MachineObject::command_xcam_control_nozzleclumping_detection(bool on_off, std::string lvl)
+{
+    bool print_halt = (lvl == "never_halt") ? false : true;
+
+    xcam_nozzleclumping_detection  = on_off;
+    xcam_ai_monitoring_hold_start  = time(nullptr);
+    xcam_nozzleclumping_detection_sensitivity = lvl;
+    return command_xcam_control("clump_detector", on_off, lvl);
+}
+
+int MachineObject::command_xcam_control_airprinting_detection(bool on_off, std::string lvl)
+{
+    bool print_halt = (lvl == "never_halt") ? false : true;
+
+    xcam_airprinting_detection     = on_off;
+    xcam_ai_monitoring_hold_start  = time(nullptr);
+    xcam_airprinting_detection_sensitivity = lvl;
+    return command_xcam_control("airprint_detector", on_off, lvl);
+}
+
+int MachineObject::command_xcam_control_buildplate_marker_detector(bool on_off)
+{
+    xcam_buildplate_marker_detector = on_off;
+    xcam_buildplate_marker_hold_start = time(nullptr);
+    return command_xcam_control("buildplate_marker_detector", on_off);
+}
+
+int MachineObject::command_xcam_control_build_plate_type_detector(bool on_off)
+{
+    xcam_build_plate_type_detect.SetOptimisticValue(on_off);
+    return command_xcam_control("buildplate_marker_detector", on_off);
+}
+
+int MachineObject::command_xcam_control_build_plate_align_detector(bool on_off)
+{
+    xcam_build_plate_align_detect.SetOptimisticValue(on_off);
+    return command_xcam_control("plate_offset_switch", on_off);
+}
+
+int MachineObject::command_xcam_control_first_layer_inspector(bool on_off, bool print_halt)
+{
+    xcam_first_layer_inspector = on_off;
+    xcam_first_layer_hold_start = time(nullptr);
+    return command_xcam_control("first_layer_inspector", on_off);
+}
+
+int MachineObject::command_xcam_control_auto_recovery_step_loss(bool on_off)
+{
+    xcam_auto_recovery_step_loss = on_off;
+    xcam_auto_recovery_hold_start = time(nullptr);
+    return command_set_printing_option(on_off);
+}
+
+int MachineObject::command_xcam_control_allow_prompt_sound(bool on_off)
+{
+    xcam_allow_prompt_sound = on_off;
+    xcam_prompt_sound_hold_start = time(nullptr);
+    return command_set_prompt_sound(on_off);
+}
+
+int MachineObject::command_xcam_control_filament_tangle_detect(bool on_off)
+{
+    xcam_filament_tangle_detect = on_off;
+    xcam_filament_tangle_detect_hold_start = time(nullptr);
+    return command_set_filament_tangle_detect(on_off);
+}
+
+void MachineObject::set_bind_status(std::string status)
+{
+    bind_user_name = status;
+}
+
+std::string MachineObject::get_bind_str()
+{
+    std::string default_result = "N/A";
+    if (bind_user_name.compare("null") == 0) {
+        return "Free";
+    }
+    else if (!bind_user_name.empty()) {
+        return bind_user_name;
+    }
+    return default_result;
+}
+
+bool MachineObject::can_print()
+{
+    if (print_status.compare("RUNNING") == 0) {
+        return false;
+    }
+    if (print_status.compare("IDLE") == 0 || print_status.compare("FINISH") == 0) {
+        return true;
+    }
+    return true;
+}
+
+bool MachineObject::can_resume()
+{
+    if (print_status.compare("PAUSE") == 0)
+        return true;
+    return false;
+}
+
+bool MachineObject::can_pause()
+{
+    if (print_status.compare("RUNNING") == 0)
+        return true;
+    return false;
+}
+
+bool MachineObject::can_abort()
+{
+    return MachineObject::is_in_printing_status(print_status);
+}
+
+bool MachineObject::is_in_printing_status(std::string status)
+{
+    if (status.compare("PAUSE") == 0
+        || status.compare("RUNNING") == 0
+        || status.compare("SLICING") == 0
+        || status.compare("PREPARE") == 0) {
+        return true;
+    }
+    return false;
+}
+
+
+bool MachineObject::is_in_printing()
+{
+    /* use print_status if print_status is valid */
+    if (!print_status.empty())
+        return MachineObject::is_in_printing_status(print_status);
+    else {
+        return MachineObject::is_in_printing_status(iot_print_status);
+    }
+    return false;
+}
+
+bool MachineObject::is_in_prepare()
+{
+    return print_status == "PREPARE";
+}
+
+bool MachineObject::is_in_printing_pause() const
+{
+    return print_status == "PAUSE";
+}
+
+bool MachineObject::is_printing_finished()
+{
+    if (print_status.compare("FINISH") == 0
+        || print_status.compare("FAILED") == 0) {
+        return true;
+    }
+    return false;
+}
+
+void MachineObject::reset_update_time()
+{
+    BOOST_LOG_TRIVIAL(trace) << "reset reset_update_time, dev_id =" << BBLCrossTalk::Crosstalk_DevId(get_dev_id());
+    last_update_time = std::chrono::system_clock::now();
+    subscribe_counter = SUBSCRIBE_RETRY_COUNT;
+}
+
+void MachineObject::reset()
+{
+    BOOST_LOG_TRIVIAL(trace) << "reset dev_id=" << BBLCrossTalk::Crosstalk_DevId(get_dev_id());
+    last_update_time = std::chrono::system_clock::now();
+    subscribe_counter = SUBSCRIBE_RETRY_COUNT;
+    m_push_count = 0;
+    m_full_msg_count = 0;
+    is_220V_voltage = false;
+    get_version_retry = 0;
+    camera_recording = false;
+    camera_recording_when_printing = false;
+    camera_timelapse = false;
+    //camera_resolution = "";
+    printing_speed_mag = 100;
+    gcode_file_prepare_percent = 0;
+    iot_print_status = "";
+    print_status = "";
+    last_mc_print_stage = -1;
+    network_wired = false;
+    dev_connection_name = "";
+    job_id_ = "";
+    jobState_ = 0;
+    m_plate_index = -1;
+    device_cert_installed = false;
+    clear_auto_nozzle_mapping();// reset nozzle mapping
+
+    // reset print_json
+    json empty_j;
+    print_json.diff2all_base_reset(empty_j);
+
+    for (auto i = 0; i < vt_slot.size(); i++) {
+        vt_slot[i].reset();
+
+        if (i == 1) {
+            vt_slot.erase(vt_slot.begin() + 1);
+        }
+    }
+    subtask_ = nullptr;
+    has_extra_flow_type = false;
+    m_partskip_ids.clear();
+}
+
+void MachineObject::set_print_state(std::string status)
+{
+    print_status = status;
+}
+
+int MachineObject::connect(bool use_openssl)
+{
+    if (get_dev_ip().empty()) return -1;
+    std::string username = "bblp";
+    std::string password = get_access_code();
+
+    if (m_agent) {
+        try {
+            return m_agent->connect_printer(get_dev_id(), get_dev_ip(), username, password, use_openssl);
+        } catch (...) {
+            ;
+        }
+    }
+    return -1;
+}
+
+int MachineObject::disconnect()
+{
+    if (m_agent) {
+        return m_agent->disconnect_printer();
+    }
+    return -1;
+}
+
+bool MachineObject::is_connected()
+{
+    std::chrono::system_clock::time_point curr_time = std::chrono::system_clock::now();
+    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(curr_time - last_update_time);
+    if (diff.count() > DISCONNECT_TIMEOUT) {
+        BOOST_LOG_TRIVIAL(trace) << "machine_object: dev_id=" << BBLCrossTalk::Crosstalk_DevId(get_dev_id()) <<", diff count = " << diff.count();
+        return false;
+    }
+
+    if (!is_lan_mode_printer()) {
+        NetworkAgent* m_agent = Slic3r::GUI::wxGetApp().getAgent();
+        if (m_agent) {
+            return m_agent->is_server_connected();
+        }
+    }
+    return true;
+}
+
+bool MachineObject::is_connecting()
+{
+    return is_connected() && m_push_count == 0;
+}
+
+void MachineObject::set_online_state(bool on_off)
+{
+    m_is_online = on_off;
+    if (!on_off) m_active_state = NotActive;
+}
+
+bool MachineObject::is_info_ready(bool check_version) const
+{
+    if (check_version && module_vers.empty())
+    {
+        BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << ": not ready, failed to check version";
+        return false;
+    }
+
+    std::chrono::system_clock::time_point curr_time = std::chrono::system_clock::now();
+    auto diff = std::chrono::duration_cast<std::chrono::microseconds>(last_push_time - curr_time);
+    if (m_full_msg_count > 0 && m_push_count > 0 && diff.count() < PUSHINFO_TIMEOUT) {
+        return true;
+    }
+
+    BOOST_LOG_TRIVIAL(info) << __FUNCTION__
+        << ": not ready, m_full_msg_count=" << m_full_msg_count
+        << ", m_push_count=" << m_push_count
+        << ", diff.count()=" << diff.count()
+        << ", dev_id=" << BBLCrossTalk::Crosstalk_DevId(get_dev_id());
+    return false;
+}
+
+
+bool MachineObject::is_security_control_ready() const
+{
+    return device_cert_installed;
+}
+
+std::vector<std::string> MachineObject::get_resolution_supported()
+{
+    return camera_resolution_supported;
+}
+
+std::vector<std::string> MachineObject::get_compatible_machine()
+{
+    return DevPrinterConfigUtil::get_compatible_machine(printer_type);
+}
+
+bool MachineObject::is_camera_busy_off()
+{
+    if (get_printer_series() == PrinterSeries::SERIES_P1P)
+        return is_in_prepare() || is_in_upgrading();
+    return false;
+}
+
+int MachineObject::publish_json(const json& json_item, int qos, int flag)
+{
+    int rtn = 0;
+    if (is_lan_mode_printer()) {
+        rtn = local_publish_json(json_item.dump(), qos, flag);
+    } else {
+        rtn = cloud_publish_json(json_item.dump(), qos, flag);
+    }
+
+    if (rtn == 0) {
+        BOOST_LOG_TRIVIAL(info) << "publish_json: " << BBLCrossTalk::Crosstalk_JsonLog(json_item) << " code: " << rtn;
+    } else {
+        BOOST_LOG_TRIVIAL(error) << "publish_json: " << BBLCrossTalk::Crosstalk_JsonLog(json_item) << " code: " << rtn;
+    }
+
+    return rtn;
+}
+
+int MachineObject::cloud_publish_json(std::string json_str, int qos, int flag)
+{
+    int result = -1;
+    if (m_agent)
+        result = m_agent->send_message(get_dev_id(), json_str, qos, flag);
+
+    return result;
+}
+
+int MachineObject::local_publish_json(std::string json_str, int qos, int flag)
+{
+    int result = -1;
+    if (m_agent) {
+        result = m_agent->send_message_to_printer(get_dev_id(), json_str, qos, flag);
+    }
+    return result;
+}
+
+std::string MachineObject::setting_id_to_type(std::string setting_id, std::string tray_type)
+{
+    std::string type;
+    PresetBundle* preset_bundle = GUI::wxGetApp().preset_bundle;
+    if (preset_bundle) {
+        for (auto it = preset_bundle->filaments.begin(); it != preset_bundle->filaments.end(); it++) {
+
+            if (it->filament_id.compare(setting_id) == 0 && it->is_system) {
+                std::string display_filament_type;
+                it->config.get_filament_type(display_filament_type);
+                type = display_filament_type;
+                break;
+            }
+        }
+    }
+
+    if (tray_type != type || type.empty()) {
+        if (type.empty()) { type = tray_type; }
+        BOOST_LOG_TRIVIAL(info) << "The values of tray_info_idx and tray_type do not match tray_info_idx " << setting_id << " tray_type " << tray_type << " system_type" << type;
+    }
+    return type;
+}
+
+template <class ENUM>
+static ENUM enum_index_of(char const *key, char const **enum_names, int enum_count, ENUM defl = static_cast<ENUM>(0))
+{
+    for (int i = 0; i < enum_count; ++i)
+        if (strcmp(enum_names[i], key) == 0) return static_cast<ENUM>(i);
+    return defl;
+}
+
+int MachineObject::parse_json(std::string tunnel, std::string payload, bool key_field_only)
+{
+    if (tunnel == "lan") last_lan_msg_time_ = std::chrono::system_clock::now();
+    if (tunnel == "cloud") last_cloud_msg_time_ = std::chrono::system_clock::now();
+
+    parse_msg_count++;
+    std::chrono::system_clock::time_point clock_start = std::chrono::system_clock::now();
+    this->set_online_state(true);
+
+    std::chrono::system_clock::time_point curr_time = std::chrono::system_clock::now();
+    auto diff1 = std::chrono::duration_cast<std::chrono::microseconds>(curr_time - last_update_time);
+
+    /* update last received time */
+    last_update_time = std::chrono::system_clock::now();
+
+    json j_pre;
+    bool parse_ok = false;
+    try {
+        j_pre = json::parse(payload);
+        parse_ok = true;
+    }
+    catch(...) {
+        parse_ok = false;
+        /* post process payload */
+        sanitizeToUtf8(payload);
+        BOOST_LOG_TRIVIAL(info) << "parse_json: sanitize to utf8";
+    }
+
+    try {
+        bool restored_json = false;
+        json j;
+        if (!parse_ok)
+            j_pre = json::parse(payload);
+        CNumericLocalesSetter locales_setter;
+        if (j_pre.empty()) {
+            return 0;
+        }
+        if (j_pre.contains("print")) {
+            if (m_active_state == NotActive) m_active_state = Active;
+            if (j_pre["print"].contains("command")) {
+                if (j_pre["print"]["command"].get<std::string>() == "push_status") {
+                    if (j_pre["print"].contains("msg")) {
+                        if (j_pre["print"]["msg"].get<int>() == 0) {           //all message
+                            BOOST_LOG_TRIVIAL(trace) << "static: get push_all msg, dev_id=" << BBLCrossTalk::Crosstalk_DevId(get_dev_id());
+                            m_push_count++;
+                            m_full_msg_count++;
+
+                            if (!printer_type.empty())
+                                print_json.load_compatible_settings(printer_type, "");
+                            print_json.diff2all_base_reset(j_pre);
+                        } else if (j_pre["print"]["msg"].get<int>() == 1) {    //diff message
+                            if (print_json.diff2all(j_pre, j) == 0) {
+                                restored_json = true;
+                            } else {
+                                BOOST_LOG_TRIVIAL(trace) << "parse_json: restore failed! count = " << parse_msg_count;
+                                if (print_json.is_need_request()) {
+                                    BOOST_LOG_TRIVIAL(trace) << "parse_json: need request pushall, count = " << parse_msg_count;
+                                    // request new push
+                                    GUI::wxGetApp().CallAfter([this]{
+                                        this->command_request_push_all();
+                                    });
+                                    return -1;
+                                }
+                                return -1;
+                            }
+                        } else {
+                            BOOST_LOG_TRIVIAL(warning) << "unsupported msg_type=" << j_pre["print"]["msg"].get<std::string>();
+                        }
+                    }
+                    else {
+                        if (!printer_type.empty()) {
+                            m_full_msg_count++;/* all message package is full at LAN mode*/
+                            print_json.load_compatible_settings(printer_type, "");
+                        }
+
+                        print_json.diff2all_base_reset(j_pre);
+                    }
+
+                    if (j_pre["print"].contains("s_obj")){
+                        if(j_pre["print"]["s_obj"].is_array()){
+                            m_partskip_ids.clear();
+                            for(auto it=j_pre["print"]["s_obj"].begin(); it!=j_pre["print"]["s_obj"].end(); it++){
+                                m_partskip_ids.push_back(it.value().get<int>());
+                            }
+                        }
+                    }
+                }
+            }
+            if (j_pre["print"].contains("plate_idx")){ // && m_plate_index == -1
+                if (j_pre["print"]["plate_idx"].is_number())
+                {
+                    m_plate_index = j_pre["print"]["plate_idx"].get<int>();
+                }
+                else if (j_pre["print"]["plate_idx"].is_string())
+                {
+                    try
+                    {
+                        m_plate_index = std::stoi(j_pre["print"]["plate_idx"].get<std::string>());
+                    }
+                    catch (...) { BOOST_LOG_TRIVIAL(error) << "parse_json: failed to convert plate_idx to int"; }
+                }
+            }
+        }
+        if (j_pre.contains("system")) {
+            if (j_pre["system"].contains("command")) {
+                if (j_pre["system"]["command"].get<std::string>() == "get_access_code") {
+                    if (j_pre["system"].contains("access_code")) {
+                        std::string access_code = j_pre["system"]["access_code"].get<std::string>();
+                        if (!access_code.empty()) {
+                            set_access_code(access_code);
+                            set_user_access_code(access_code);
+                        }
+                    }
+                }
+            }
+        }
+        if (!restored_json) {
+            j = j_pre;
+        }
+
+        uint64_t t_utc = j.value("t_utc", 0ULL);
+        if (t_utc > 0) {
+            last_utc_time = std::chrono::system_clock::time_point(t_utc * 1ms);
+            std::chrono::system_clock::time_point now = std::chrono::system_clock::now();
+            auto millisec_since_epoch = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
+            auto delay = millisec_since_epoch - t_utc;  //ms
+
+            std::string message_type = is_lan_mode_printer() ? "Local Mqtt" : is_tunnel_mqtt ? "Tunnel Mqtt" : "Cloud Mqtt";
+            if (!message_delay.empty()) {
+                const auto& [first_type, first_time_stamp, first_delay] = message_delay.front();
+                const auto& [last_type, last_time_stap, last_delay] = message_delay.back();
+
+                BOOST_LOG_TRIVIAL(debug) << __FUNCTION__ << ", message delay, last time stamp: " << last_time_stap;
+                if (last_time_stap - first_time_stamp >= MINUTE_30) {
+                    // record, excluding current data
+                    int total = message_delay.size();
+                    int local_mqtt = 0;
+                    int tunnel_mqtt = 0;
+                    int cloud_mqtt = 0;
+
+                    int local_mqtt_timeout = 0;
+                    int tunnel_mqtt_timeout = 0;
+                    int cloud_mqtt_timeout = 0;
+
+                    for (const auto& [type, time_stamp, delay] : message_delay) {
+                        if (type == "Local Mqtt") {
+                            local_mqtt++;
+                            if (delay >= TIME_OUT) {
+                                local_mqtt_timeout++;
+                            }
+                        }
+                        else if (type == "Tunnel Mqtt") {
+                            tunnel_mqtt++;
+                            if (delay >= TIME_OUT) {
+                                tunnel_mqtt_timeout++;
+                            }
+                        }
+                        else if (type == "Cloud Mqtt"){
+                            cloud_mqtt++;
+                            if (delay >= TIME_OUT) {
+                                cloud_mqtt_timeout++;
+                            }
+                        }
+                    }
+
+                    BOOST_LOG_TRIVIAL(debug) << __FUNCTION__ << ", message delay, message total: " << total;
+                    try {
+                        if (m_agent) {
+                            json j_message;
+
+                            // Convert timestamp to time
+                            std::time_t t = time_t(last_time_stap / 1000);  //s
+                            std::tm* now_tm = std::localtime(&t);
+                            char buffer[80];
+                            std::strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", now_tm);
+
+                            std::string time_str = std::string(buffer);
+                            j_message["time"] = time_str;
+                            j_message["total"] = total;
+                            j_message["local_mqtt"] = std::to_string(local_mqtt_timeout) + "/" + std::to_string(local_mqtt);
+                            j_message["tunnel_mqtt"] = std::to_string(tunnel_mqtt_timeout) + "/" + std::to_string(tunnel_mqtt);
+                            j_message["cloud_mqtt"] = std::to_string(cloud_mqtt_timeout) + "/" + std::to_string(cloud_mqtt);
+
+                            m_agent->track_event("message_delay", j_message.dump());
+                        }
+                    }
+                    catch (...) {}
+
+                    message_delay.clear();
+                    message_delay.shrink_to_fit();
+                }
+            }
+            message_delay.push_back(std::make_tuple(message_type, t_utc, delay));
+        }
+        else
+        {
+            last_utc_time = last_update_time;
+        }
+
+#if !BBL_RELEASE_TO_PUBLIC
+        BOOST_LOG_TRIVIAL(trace) << "parse_json: dev_id=" << BBLCrossTalk::Crosstalk_DevId(get_dev_id()) << ", tunnel=" << tunnel << ", merged playload=" << BBLCrossTalk::Crosstalk_JsonLog(j);
+#else
+        if (Slic3r::get_logging_level() >= level_string_to_boost("trace")) {
+            BOOST_LOG_TRIVIAL(trace) << __FUNCTION__ << ": dev_id=" << BBLCrossTalk::Crosstalk_DevId(get_dev_id()) << ", origin playload=" << BBLCrossTalk::Crosstalk_JsonLog(j_pre);
+        } else {
+            if (j_pre.contains("print")) {
+                BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << ": dev_id=" << BBLCrossTalk::Crosstalk_DevId(get_dev_id()) << ", print playload=" << BBLCrossTalk::Crosstalk_JsonLog(j_pre["print"]);
+            };
+        }
+#endif
+
+        // Parse version info first, as if version arrive or change, 'print' need parse again with new compatible settings
+        try {
+            if (j.contains("info")) {
+                if (j["info"].contains("command") && j["info"]["command"].get<std::string>() == "get_version") {
+                    json j_module = j["info"]["module"];
+                    clear_version_info();
+                    for (auto it = j_module.begin(); it != j_module.end(); it++) {
+                        DevFirmwareVersionInfo ver_info;
+                        ver_info.name = (*it)["name"].get<std::string>();
+                        if ((*it).contains("product_name"))
+                            ver_info.product_name = wxString::FromUTF8((*it)["product_name"].get<string>());
+                        if ((*it).contains("sw_ver"))
+                            ver_info.sw_ver = (*it)["sw_ver"].get<std::string>();
+                        if ((*it).contains("sw_new_ver"))
+                            ver_info.sw_new_ver = (*it)["sw_new_ver"].get<std::string>();
+                        if ((*it).contains("visible") && (*it).contains("new_ver")) {
+                            ver_info.sw_new_ver = (*it)["new_ver"].get<std::string>();
+                        }
+                        if ((*it).contains("sn"))
+                            ver_info.sn = (*it)["sn"].get<std::string>();
+                        if ((*it).contains("hw_ver"))
+                            ver_info.hw_ver = (*it)["hw_ver"].get<std::string>();
+                        if((*it).contains("flag"))
+                            ver_info.firmware_flag= (*it)["flag"].get<int>();
+
+                        store_version_info(ver_info);
+                        if (ver_info.name == "ota") {
+                            NetworkAgent* agent = GUI::wxGetApp().getAgent();
+                            if (agent) {
+                                std::string dev_ota_str = "dev_ota_ver:" + this->get_dev_id();
+                                agent->track_update_property(dev_ota_str, ver_info.sw_ver);
+                            }
+                        }
+                    }
+
+                    parse_version_func();
+
+                    bool get_version_result = true;
+                    if (j["info"].contains("result"))
+                        if (j["info"]["result"].get<std::string>() == "fail")
+                            get_version_result = false;
+                    if ((!check_version_valid() && get_version_retry-- >= 0)
+                        && get_version_result) {
+                            BOOST_LOG_TRIVIAL(info) << "get_version_retry = " << get_version_retry;
+                            boost::thread retry = boost::thread([this] {
+                                boost::this_thread::sleep_for(boost::chrono::milliseconds(RETRY_INTERNAL));
+                                GUI::wxGetApp().CallAfter([this] {
+                                    this->command_get_version(false);
+                            });
+                        });
+                    }
+                }
+                std::string version = parse_version();
+                if (!version.empty() && print_json.load_compatible_settings(printer_type, version)) {
+                    // reload because compatible settings changed
+                    j.clear();
+                    print_json.diff2all(json{}, j);
+                }
+
+            }
+        } catch (...) {}
+
+        try {
+            if (auto ptr = m_fila_system->GetAmsFirmwareSwitch().lock()) {
+                ptr->ParseFirmwareSwitch(j);
+            }
+        } catch (...) {
+            BOOST_LOG_TRIVIAL(error) << "parse_json: failed to parse firmware switch info";
+        }
+
+        if (j.contains("print")) {
+            json jj = j["print"];
+            int sequence_id = 0;
+            if (jj.contains("sequence_id")) {
+                if (jj["sequence_id"].is_string()) {
+                    std::string str_seq = jj["sequence_id"].get<std::string>();
+                    try {
+                        sequence_id = stoi(str_seq);
+                    }
+                    catch(...) {
+                        ;
+                    }
+                }
+            }
+
+            if (!key_field_only) {
+                if (!m_manager->IsMultiMachineEnabled() && !is_support_agora) {
+                    if (jj.contains("support_tunnel_mqtt")) {
+                        if (jj["support_tunnel_mqtt"].is_boolean()) {
+                            is_support_tunnel_mqtt = jj["support_tunnel_mqtt"].get<bool>();
+                        }
+                    }
+                }
+
+                //nozzle temp range
+                if (jj.contains("nozzle_temp_range")) {
+                    if (jj["nozzle_temp_range"].is_array()) {
+                        nozzle_temp_range.clear();
+                        for (auto it = jj["nozzle_temp_range"].begin(); it != jj["nozzle_temp_range"].end(); it++) {
+                            nozzle_temp_range.push_back(it.value().get<int>());
+                        }
+                    }
+                }
+
+                // bed temp range
+                if (jj.contains("bed_temp_range")) {
+                    if (jj["bed_temp_range"].is_array()) {
+                        bed_temp_range.clear();
+                        for (auto it = jj["bed_temp_range"].begin(); it != jj["bed_temp_range"].end(); it++) {
+                            bed_temp_range.push_back(it.value().get<int>());
+                        }
+                    }
+                }
+
+                //supported function
+                m_config->ParseConfig(jj);
+
+                if (jj.contains("support_build_plate_marker_detect")) {
+                    if (jj["support_build_plate_marker_detect"].is_boolean()) {
+                        is_support_build_plate_marker_detect = jj["support_build_plate_marker_detect"].get<bool>();
+                    }
+                }
+
+                if(jj.contains("support_build_plate_marker_detect_type") && jj["support_build_plate_marker_detect_type"].is_number()) {
+                    m_plate_maker_detect_type = (PlateMakerDectect)jj["support_build_plate_marker_detect_type"].get<int>();
+                }
+
+                if (jj.contains("support_flow_calibration") && jj["support_flow_calibration"].is_boolean())
+                {
+                    is_support_pa_calibration = jj["support_flow_calibration"].get<bool>();
+                }
+
+                if (jj.contains("support_send_to_sd")) {
+                    if (jj["support_send_to_sd"].is_boolean()) {
+                        is_support_send_to_sdcard = jj["support_send_to_sd"].get<bool>();
+                    }
+                }
+
+              m_fan->ParseV2_0(jj);
+
+                if (jj.contains("support_filament_backup")) {
+                    if (jj["support_filament_backup"].is_boolean()) {
+                        is_support_filament_backup = jj["support_filament_backup"].get<bool>();
+                    }
+                }
+
+                if (jj.contains("support_update_remain")) {
+                    if (jj["support_update_remain"].is_boolean()) {
+                        is_support_update_remain = jj["support_update_remain"].get<bool>();
+                        if (auto ptr = m_fila_system->GetAmsFirmwareSwitch().lock();
+                            ptr->GetCurrentFirmwareIdxRun() == DevAmsSystemFirmwareSwitch::IDX_AMS_AMS2_AMSHT) {
+                            is_support_update_remain = true;// special case, for the firmware, remain is supported
+                        }
+                    }
+                }
+
+                if (jj.contains("support_bed_leveling")) {
+                    if (jj["support_bed_leveling"].is_number_integer()) {
+                        is_support_bed_leveling = jj["support_bed_leveling"].get<int>();
+                    }
+                }
+
+                if (jj.contains("support_auto_recovery_step_loss")) {
+                    if (jj["support_auto_recovery_step_loss"].is_boolean()) {
+                        is_support_auto_recovery_step_loss = jj["support_auto_recovery_step_loss"].get<bool>();
+                    }
+                }
+
+                if (jj.contains("support_ams_humidity")) {
+                    if (jj["support_ams_humidity"].is_boolean()) {
+                        is_support_ams_humidity = jj["support_ams_humidity"].get<bool>();
+                    }
+                }
+
+                if (jj.contains("support_prompt_sound")) {
+                    if (jj["support_prompt_sound"].is_boolean()) {
+                        is_support_prompt_sound = jj["support_prompt_sound"].get<bool>();
+                    }
+                }
+
+                if (jj.contains("support_filament_tangle_detect")) {
+                    if (jj["support_filament_tangle_detect"].is_boolean()) {
+                        is_support_filament_tangle_detect = jj["support_filament_tangle_detect"].get<bool>();
+                    }
+                }
+
+                if (jj.contains("support_1080dpi")) {
+                    if (jj["support_1080dpi"].is_boolean()) {
+                        is_support_1080dpi = jj["support_1080dpi"].get<bool>();
+                    }
+                }
+
+                if (jj.contains("support_cloud_print_only")) {
+                    if (jj["support_cloud_print_only"].is_boolean()) {
+                        is_support_cloud_print_only = jj["support_cloud_print_only"].get<bool>();
+                    }
+                }
+
+                if (jj.contains("support_command_ams_switch")) {
+                    if (jj["support_command_ams_switch"].is_boolean()) {
+                        is_support_command_ams_switch = jj["support_command_ams_switch"].get<bool>();
+                    }
+                }
+
+                if (jj.contains("support_mqtt_alive")) {
+                    if (jj["support_mqtt_alive"].is_boolean()) {
+                        is_support_mqtt_alive = jj["support_mqtt_alive"].get<bool>();
+                    }
+                }
+
+                if (jj.contains("support_motor_noise_cali")) {
+                    if (jj["support_motor_noise_cali"].is_boolean()) {
+                        is_support_motor_noise_cali = jj["support_motor_noise_cali"].get<bool>();
+                    }
+                }
+
+                if (jj.contains("support_timelapse")) {
+                    if (jj["support_timelapse"].is_boolean()) {
+                        is_support_timelapse = jj["support_timelapse"].get<bool>();
+                    }
+                }
+
+                if (jj.contains("support_user_preset")) {
+                    if (jj["support_user_preset"].is_boolean()) {
+                        is_support_user_preset = jj["support_user_preset"].get<bool>();
+                    }
+                }
+
+                if (jj.contains("bed_temperature_limit")) {
+                    if (jj["bed_temperature_limit"].is_number_integer()) {
+                        bed_temperature_limit = jj["bed_temperature_limit"].get<int>();
+                    }
+                }
+
+                if (jj.contains("support_refresh_nozzle")) {
+                    if (jj["support_refresh_nozzle"].is_boolean()) {
+                        is_support_refresh_nozzle = jj["support_refresh_nozzle"].get<bool>();
+                    }
+                }
+            }
+
+
+            if (jj.contains("command")) {
+                m_auto_nozzle_mapping.ParseAutoNozzleMapping(this, jj);
+
+                if (jj["command"].get<std::string>() == "ams_change_filament") {
+                    if (jj.contains("errno")) {
+                        if (jj["errno"].is_number()) {
+                            if (jj.contains("soft_temp")) {
+                                int soft_temp = jj["soft_temp"].get<int>();
+                                if (jj["errno"].get<int>() == -2) {
+                                    wxString text = wxString::Format(_L("The chamber temperature is too high, which may cause the filament to soften. Please wait until the chamber temperature drops below %d\u2103. You may open the front door or enable fans to cool down."), soft_temp);
+                                    GUI::wxGetApp().push_notification(this, text);
+                                } else if (jj["errno"].get<int>() == -4) {
+                                    wxString text = wxString::Format(_L("AMS temperature is too high, which may cause the filament to soften. Please wait until the AMS temperature drops below %d\u2103."), soft_temp);
+                                    GUI::wxGetApp().push_notification(this, text);
+                                }
+                            } else {
+                                if (jj["errno"].get<int>() == -2) {
+                                    wxString text = _L("The current chamber temperature or the target chamber temperature exceeds 45\u2103.In order to avoid extruder clogging,low temperature filament(PLA/PETG/TPU) is not allowed to be loaded.");
+                                    GUI::wxGetApp().push_notification(this, text);
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (jj["command"].get<std::string>() == "set_ctt") {
+                    if (m_agent && DevUtil::is_studio_cmd(sequence_id)) {
+                        if (jj["errno"].is_number()) {
+                            wxString text;
+                            if (jj["errno"].get<int>() == -2) {
+                                 text = _L("Low temperature filament(PLA/PETG/TPU) is loaded in the extruder.In order to avoid extruder clogging,it is not allowed to set the chamber temperature.");
+                            }
+                            else if (jj["errno"].get<int>() == -4) {
+                                 text = _L("When you set the chamber temperature below 40\u2103, the chamber temperature control will not be activated. And the target chamber temperature will automatically be set to 0\u2103.");
+                            }
+                            if(!text.empty()){
+#if __WXOSX__
+                            set_ctt_dlg(text);
+#else
+                            GUI::wxGetApp().push_notification(this, text);
+#endif
+                            }
+                        }
+                    }
+                }
+
+                if (!key_field_only)
+                {
+                    // add DevUtil::is_cloud_cmd for cloud print error code
+                    if ((DevUtil::is_studio_cmd(sequence_id) || DevUtil::is_cloud_cmd(sequence_id)) && jj.contains("command") && jj.contains("err_code")) {
+                        if (jj["err_code"].is_number()) {
+                            json action_json = jj.contains("err_index") ? jj : json();/* proceed action*/
+                            add_command_error_code_dlg(jj["err_code"].get<int>(), action_json);
+                        }
+                    }
+                }
+
+                if (jj["command"].get<std::string>() == "push_status") {
+                    m_push_count++;
+                    last_push_time = last_update_time;
+#pragma region printing
+                    // U0 firmware
+                    if (jj.contains("print_type")) {
+                        print_type = jj["print_type"].get<std::string>();
+                    }
+                    if (jj.contains("mc_percent")) {
+                        if (jj["mc_percent"].is_string())
+                            mc_print_percent = stoi(j["print"]["mc_percent"].get<std::string>());
+                        else if (jj["mc_percent"].is_number_integer())
+                            mc_print_percent = j["print"]["mc_percent"].get<int>();
+                    }
+                    if (jj.contains("mc_print_sub_stage")) {
+                        if (jj["mc_print_sub_stage"].is_number_integer())
+                            mc_print_sub_stage = j["print"]["mc_print_sub_stage"].get<int>();
+                    }
+                    /* printing */
+                    if (jj.contains("mc_print_stage")) {
+                        if (jj["mc_print_stage"].is_string())
+                            mc_print_stage = atoi(jj["mc_print_stage"].get<std::string>().c_str());
+                        if (jj["mc_print_stage"].is_number())
+                            mc_print_stage = jj["mc_print_stage"].get<int>();
+                    }
+                    if (jj.contains("mc_print_error_code")) {
+                        if (jj["mc_print_error_code"].is_number())
+                            mc_print_error_code = jj["mc_print_error_code"].get<int>();
+                    }
+                    if (jj.contains("mc_remaining_time")) {
+                        if (jj["mc_remaining_time"].is_string())
+                            mc_left_time = stoi(j["print"]["mc_remaining_time"].get<std::string>()) * 60;
+                        else if (jj["mc_remaining_time"].is_number_integer())
+                            mc_left_time = j["print"]["mc_remaining_time"].get<int>() * 60;
+                    }
+                    if (jj.contains("print_error")) {
+                        if (jj["print_error"].is_number())
+                            print_error = jj["print_error"].get<int>();
+                    }
+
+                     DevStorage::ParseV1_0(jj, m_storage);
+
+                    if (!key_field_only) {
+                        if (jj.contains("home_flag")) { parse_home_flag(jj["home_flag"].get<int>());}
+
+                        /*the param is invalid in np for Yeshu*/
+                        if (jj.contains("hw_switch_state")) {
+                            hw_switch_state = jj["hw_switch_state"].get<int>();
+                            m_extder_system->m_extders[MAIN_EXTRUDER_ID].m_ext_has_filament = hw_switch_state;
+                        }
+                        if (jj.contains("mc_print_line_number")) {
+                            if (jj["mc_print_line_number"].is_string() && !jj["mc_print_line_number"].is_null())
+                                mc_print_line_number = atoi(jj["mc_print_line_number"].get<std::string>().c_str());
+                        }
+                    }
+                    if (!key_field_only) {
+                        if (jj.contains("flag3")) {
+                            int flag3 = jj["flag3"].get<int>();
+                            is_support_filament_setting_inprinting =  get_flag_bits(flag3, 3);
+                            is_enable_ams_np =  get_flag_bits(flag3, 9);
+                        }
+                    }
+                    if (!key_field_only) {
+                        if (jj.contains("net")) {
+                            if (jj["net"].contains("conf")) {
+                                network_wired = (jj["net"]["conf"].get<int>() & (0x1)) != 0;
+                            }
+                            if (jj["net"].contains("info")) {
+                                for (auto info_item = jj["net"]["info"].begin(); info_item != jj["net"]["info"].end(); info_item++) {
+
+                                    if (info_item->contains("ip")) {
+                                        auto tmp_dev_ip = (*info_item)["ip"].get<int64_t>();
+                                        if (tmp_dev_ip == 0)
+                                            continue ;
+                                        else {
+                                           set_dev_ip(DevUtil::convertToIp(tmp_dev_ip));
+                                        }
+                                    } else {
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+
+#pragma endregion
+
+#pragma region online
+                    if (!key_field_only) {
+                        // parse online info
+                        try {
+                            if (jj.contains("online")) {
+                                if (jj["online"].contains("ahb")) {
+                                    if (jj["online"]["ahb"].get<bool>()) {
+                                        online_ahb = true;
+                                    } else {
+                                        online_ahb = false;
+                                    }
+                                }
+                                if (jj["online"].contains("rfid")) {
+                                    if (jj["online"]["rfid"].get<bool>()) {
+                                        online_rfid = true;
+                                    } else {
+                                        online_rfid = false;
+                                    }
+                                }
+                                std::string str = jj.dump();
+                                if (jj["online"].contains("version")) {
+                                    online_version = jj["online"]["version"].get<int>();
+                                }
+                                if (last_online_version != online_version) {
+                                    last_online_version = online_version;
+                                    GUI::wxGetApp().CallAfter([this] {
+                                        this->command_get_version();
+                                        });
+                                }
+                            }
+                        } catch (...) {
+                            ;
+                        }
+                    }
+#pragma endregion
+
+#pragma region print_task
+                    if (jj.contains("gcode_state")) {
+                        this->set_print_state(jj["gcode_state"].get<std::string>());
+                    }
+                    if (jj.contains("job_id")) {
+                        is_support_wait_sending_finish = true;
+                        this->job_id_ = DevJsonValParser::get_longlong_val(jj["job_id"]);
+                    }
+                    else {
+                        is_support_wait_sending_finish = false;
+                    }
+
+                    if (jj.contains("subtask_name")) {
+                        subtask_name = jj["subtask_name"].get<std::string>();
+                    }
+
+                    if (!key_field_only) {
+                        if (jj.contains("printer_type")) {
+                            printer_type = _parse_printer_type(jj["printer_type"].get<std::string>());
+                        }
+
+                        if (jj.contains("layer_num")) {
+                            curr_layer = jj["layer_num"].get<int>();
+                        }
+                        if (jj.contains("total_layer_num")) {
+                            total_layers = jj["total_layer_num"].get<int>();
+                            if (total_layers == 0)
+                                is_support_layer_num = false;
+                            else
+                                is_support_layer_num = true;
+                        }
+                        else {
+                            is_support_layer_num = false;
+                        }
+                        if (jj.contains("queue_number")) {
+                            this->queue_number = jj["queue_number"].get<int>();
+                        }
+                        else {
+                            this->queue_number = 0;
+                        }
+
+                        if (jj.contains("task_id")) {
+                            this->task_id_ = jj["task_id"].get<std::string>();
+                        }
+
+                        if (jj.contains("job_attr")) {
+                            int jobAttr = jj["job_attr"].get<int>();
+                            jobState_ =  get_flag_bits(jobAttr, 4, 4);
+                        }
+
+                        if (jj.contains("gcode_file"))
+                            this->m_gcode_file = jj["gcode_file"].get<std::string>();
+                        if (jj.contains("gcode_file_prepare_percent")) {
+                            std::string percent_str = jj["gcode_file_prepare_percent"].get<std::string>();
+                            if (!percent_str.empty()) {
+                                try {
+                                    this->gcode_file_prepare_percent = atoi(percent_str.c_str());
+                                }
+                                catch (...) {}
+                            }
+                        }
+                    }
+
+                    if (jj.contains("project_id")
+                        && jj.contains("profile_id")
+                        && jj.contains("subtask_id")
+                        ) {
+                        obj_subtask_id = jj["subtask_id"].get<std::string>();
+
+                        int plate_index = -1;
+                        /* parse local plate_index from task */
+                        if (obj_subtask_id.compare("0") == 0 && jj["profile_id"].get<std::string>() != "0") {
+                            if (jj.contains("gcode_file")) {
+                                m_gcode_file = jj["gcode_file"].get<std::string>();
+                                int idx_start = m_gcode_file.find_last_of("_") + 1;
+                                int idx_end = m_gcode_file.find_last_of(".");
+                                if (idx_start > 0 && idx_end > idx_start) {
+                                    try {
+                                        plate_index = atoi(m_gcode_file.substr(idx_start, idx_end - idx_start).c_str());
+                                        this->m_plate_index = plate_index;
+                                    }
+                                    catch (...) {
+                                        ;
+                                    }
+                                }
+                            }
+                        }
+                        update_slice_info(jj["project_id"].get<std::string>(), jj["profile_id"].get<std::string>(), jj["subtask_id"].get<std::string>(), plate_index);
+                        BBLSubTask* curr_task = get_subtask();
+                        if (curr_task) {
+                            curr_task->task_progress = mc_print_percent;
+                            curr_task->printing_status = print_status;
+                            curr_task->task_id = jj["subtask_id"].get<std::string>();
+                        }
+                    }
+
+#pragma endregion
+
+#pragma region status
+                    if (!key_field_only) {
+                        /* temperature */
+
+                        m_axis->ParseAxis(jj);
+                        DevBed::ParseV1_0(jj, m_bed);
+                        m_chamber->ParseChamber(jj);
+
+                        if (jj.contains("frame_temper")) {
+                            if (jj["frame_temper"].is_number()) {
+                                frame_temp = jj["frame_temper"].get<float>();
+                            }
+                        }
+
+                        ExtderSystemParser::ParseV1_0(jj, m_extder_system);
+
+                        /* signals */
+                        if (jj.contains("link_th_state"))
+                            link_th = jj["link_th_state"].get<std::string>();
+                        if (jj.contains("link_ams_state"))
+                            link_ams = jj["link_ams_state"].get<std::string>();
+                        if (jj.contains("wifi_signal"))
+                            wifi_signal = jj["wifi_signal"].get<std::string>();
+
+                        /* cooling */
+                        m_fan->ParseV1_0(jj);
+
+                        /* parse speed */
+                        DevPrintOptionsParser::Parse(m_print_options, jj);
+
+                        try {
+                            if (jj.contains("spd_mag")) {
+                                printing_speed_mag = jj["spd_mag"].get<int>();
+                            }
+                        }
+                        catch (...) {
+                            ;
+                        }
+                    }
+
+                    try {
+                        if (jj.contains("stg")) {
+                            stage_list_info.clear();
+                            if (jj["stg"].is_array()) {
+                                for (auto it = jj["stg"].begin(); it != jj["stg"].end(); it++) {
+                                    for (auto kv = (*it).begin(); kv != (*it).end(); kv++) {
+                                        stage_list_info.push_back(kv.value().get<int>());
+                                    }
+                                }
+                            }
+                        }
+                        if (jj.contains("stg_cur")) {
+                           stage_curr = jj["stg_cur"].get<int>();
+                        }
+
+                        if (jj.contains("stg_cd")) {
+                            stage_remaining_seconds = jj["stg_cd"].get<int>();
+                        }
+                    }
+                    catch (...) {
+                        ;
+                    }
+
+                    if (!key_field_only) {
+                        /*get filam_bak*/
+                        try {
+                            m_extder_system->m_extders[MAIN_EXTRUDER_ID].m_filam_bak.clear();
+
+                            if (jj.contains("filam_bak")) {
+                                if (jj["filam_bak"].is_array()) {
+                                    for (auto it = jj["filam_bak"].begin(); it != jj["filam_bak"].end(); it++) {
+                                        const auto& filam_bak_val = it.value().get<int>();
+                                        m_extder_system->m_extders[MAIN_EXTRUDER_ID].m_filam_bak.push_back(filam_bak_val);
+                                    }
+                                }
+                            }
+                        }
+                        catch (...) {
+                            ;
+                        }
+                    }
+                    if (!key_field_only) {
+                        try {
+                            if (jj.contains("lights_report") && jj["lights_report"].is_array()) {
+                                for (auto it = jj["lights_report"].begin(); it != jj["lights_report"].end(); it++) {
+                                    if ((*it)["node"].get<std::string>().compare("chamber_light") == 0)
+                                    {
+                                        m_lamp->SetChamberLight((*it)["mode"].get<std::string>());
+                                    }
+                                }
+                            }
+                        }
+                        catch (...) {
+                            ;
+                        }
+                    }
+#pragma endregion
+                    if (!key_field_only) {
+
+                        if (jj.contains("nozzle_diameter") && jj.contains("nozzle_type"))
+                        {
+                            std::optional<int> flag_e3d;
+                            if (jj.contains("flag3")) {
+                                int flag3           = jj["flag3"].get<int>();
+                                flag_e3d            = std::make_optional(get_flag_bits(flag3, 10, 3));
+                                has_extra_flow_type = true;
+                            }
+
+                            DevNozzleSystemParser::ParseV1_0(jj["nozzle_type"], jj["nozzle_diameter"], m_nozzle_system, flag_e3d);
+                        }
+                    }
+
+#pragma region upgrade
+                    m_upgrade->ParseUpgrade_V1_0(jj);
+
+                    try {
+                        if (jj.contains("upgrade_state")) {
+                            if (!check_enable_np(jj) && jj["upgrade_state"].contains("ams_new_version_number"))/* is not used in new np, by AP*/
+                                ams_new_version_number = jj["upgrade_state"]["ams_new_version_number"].get<std::string>();
+                            if (jj["upgrade_state"].contains("ahb_new_version_number"))
+                                ahb_new_version_number = jj["upgrade_state"]["ahb_new_version_number"].get<std::string>();
+                        }
+                    }
+                    catch (...) {
+                        ;
+                    }
+#pragma endregion
+
+#pragma region  camera
+                    if (!key_field_only) {
+                        // parse camera info
+                        try {
+                            if (jj.contains("ipcam")) {
+                                json const & ipcam = jj["ipcam"];
+                                if (ipcam.contains("ipcam_record")) {
+                                    if (time(nullptr) - camera_recording_ctl_start > HOLD_TIME_3SEC) {
+                                        if (ipcam["ipcam_record"].get<std::string>() == "enable") {
+                                            camera_recording_when_printing = true;
+                                        }
+                                        else {
+                                            camera_recording_when_printing = false;
+                                        }
+                                    }
+                                }
+                                if (ipcam.contains("timelapse")) {
+                                    if (camera_timelapse_hold_count > 0)
+                                        camera_timelapse_hold_count--;
+                                    else {
+                                        if (ipcam["timelapse"].get<std::string>() == "enable") {
+                                            camera_timelapse = true;
+                                        }
+                                        else {
+                                            camera_timelapse = false;
+                                        }
+                                    }
+                                }
+                                if (ipcam.contains("ipcam_dev")) {
+                                    if (ipcam["ipcam_dev"].get<std::string>() == "1") {
+                                        has_ipcam = true;
+                                    } else {
+                                        has_ipcam = false;
+                                    }
+                                }
+                                if (ipcam.contains("resolution")) {
+                                    if (camera_resolution_hold_count > 0)
+                                        camera_resolution_hold_count--;
+                                    else {
+                                        camera_resolution = ipcam["resolution"].get<std::string>();
+                                    }
+                                }
+                                if (ipcam.contains("resolution_supported")) {
+                                    std::vector<std::string> resolution_supported;
+                                    for (auto res : ipcam["resolution_supported"])
+                                        resolution_supported.emplace_back(res.get<std::string>());
+                                    camera_resolution_supported.swap(resolution_supported);
+                                }
+                                if (ipcam.contains("liveview")) {
+                                    char const *local_protos[] = {"none", "disabled", "local", "rtsps", "rtsp"};
+                                    liveview_local = enum_index_of(ipcam["liveview"].value<std::string>("local", "none").c_str(), local_protos, 5, LiveviewLocal::LVL_None);
+                                    char const *remote_protos[] = {"none", "tutk", "agora", "tutk_agaro"};
+                                    liveview_remote = enum_index_of(ipcam["liveview"].value<std::string>("remote", "none").c_str(), remote_protos, 4, LiveviewRemote::LVR_None);
+                                }
+                                if (ipcam.contains("file")) {
+                                    char const *local_protos[] = {"none", "local"};
+                                    file_local  = enum_index_of(ipcam["file"].value<std::string>("local", "none").c_str(), local_protos, 2, FileLocal::FL_None);
+                                    char const *remote_protos[] = {"none", "tutk", "agora", "tutk_agaro"};
+                                    file_remote = enum_index_of(ipcam["file"].value<std::string>("remote", "none").c_str(), remote_protos, 4, FileRemote::FR_None);
+                                    file_model_download = ipcam["file"].value<std::string>("model_download", "disabled") == "enabled";
+                                }
+                                virtual_camera = ipcam.value<std::string>("virtual_camera", "disabled") == "enabled";
+                                if (ipcam.contains("rtsp_url")) {
+                                    local_rtsp_url = ipcam["rtsp_url"].get<std::string>();
+                                    liveview_local = local_rtsp_url.empty() ? LVL_None : local_rtsp_url == "disable"
+                                            ? LVL_Disable : boost::algorithm::starts_with(local_rtsp_url, "rtsps") ? LVL_Rtsps : LVL_Rtsp;
+                                }
+                                if (ipcam.contains("tutk_server")) {
+                                    tutk_state = ipcam["tutk_server"].get<std::string>();
+                                }
+                            }
+                        }
+                        catch (...) {
+                            ;
+                        }
+
+                        try {
+                            if (jj.contains("xcam")) {
+                                if (time(nullptr) - xcam_ai_monitoring_hold_start > HOLD_TIME_3SEC) {
+
+                                    if (jj["xcam"].contains("cfg")) {
+                                        xcam_disable_ai_detection_display = true;
+                                       //  std::string cfg    = jj["xcam"]["cfg"].get<std::string>();
+
+                                        int cfg                  = jj["xcam"]["cfg"].get<int>();
+                                         xcam_spaghetti_detection = get_flag_bits(cfg,7);
+                                         switch (get_flag_bits(cfg, 8, 2)) {
+                                             case 0: xcam_spaghetti_detection_sensitivity = "low"; break;
+                                             case 1: xcam_spaghetti_detection_sensitivity = "medium"; break;
+                                             case 2: xcam_spaghetti_detection_sensitivity = "high"; break;
+                                             default: break;
+                                         }
+
+                                         xcam_purgechutepileup_detection = get_flag_bits(cfg, 10);
+                                         switch (get_flag_bits(cfg, 11, 2)) {
+
+                                         case 0: xcam_purgechutepileup_detection_sensitivity = "low"; break;
+                                         case 1: xcam_purgechutepileup_detection_sensitivity = "medium"; break;
+                                         case 2: xcam_purgechutepileup_detection_sensitivity = "high"; break;
+                                         default: break;
+                                         }
+
+                                         xcam_nozzleclumping_detection = get_flag_bits(cfg, 13);
+                                         switch (get_flag_bits(cfg, 14, 2)) {
+
+                                         case 0: xcam_nozzleclumping_detection_sensitivity = "low"; break;
+                                         case 1: xcam_nozzleclumping_detection_sensitivity = "medium"; break;
+                                         case 2: xcam_nozzleclumping_detection_sensitivity = "high"; break;
+                                         default: break;
+                                         }
+
+                                         xcam_airprinting_detection    = get_flag_bits(cfg, 16);
+                                         switch (get_flag_bits(cfg, 17, 2)) {
+
+                                         case 0: xcam_airprinting_detection_sensitivity = "low"; break;
+                                         case 1: xcam_airprinting_detection_sensitivity = "medium"; break;
+                                         case 2: xcam_airprinting_detection_sensitivity = "high"; break;
+                                         default: break;
+                                         }
+
+                                         is_support_build_plate_type_detect = true;
+
+                                         xcam_build_plate_align_detect.UpdateValue(get_flag_bits(cfg, 20));
+                                    }
+                                    else if (jj["xcam"].contains("printing_monitor")) {
+                                        // new protocol
+                                        xcam_ai_monitoring = jj["xcam"]["printing_monitor"].get<bool>();
+                                    } else {
+                                        // old version protocol
+                                        if (jj["xcam"].contains("spaghetti_detector")) {
+                                            xcam_ai_monitoring = jj["xcam"]["spaghetti_detector"].get<bool>();
+                                            if (jj["xcam"].contains("print_halt")) {
+                                                bool print_halt = jj["xcam"]["print_halt"].get<bool>();
+                                                if (print_halt) { xcam_ai_monitoring_sensitivity = "medium"; }
+                                            }
+                                        }
+                                    }
+
+                                    if (jj["xcam"].contains("halt_print_sensitivity")) {
+                                        xcam_ai_monitoring_sensitivity = jj["xcam"]["halt_print_sensitivity"].get<std::string>();
+                                    }
+
+                                }
+
+                                if (time(nullptr) - xcam_first_layer_hold_start > HOLD_TIME_3SEC) {
+                                    if (jj["xcam"].contains("first_layer_inspector")) {
+                                        xcam_first_layer_inspector = jj["xcam"]["first_layer_inspector"].get<bool>();
+                                    }
+                                }
+
+                                if (time(nullptr) - xcam_buildplate_marker_hold_start > HOLD_TIME_3SEC) {
+                                    if (jj["xcam"].contains("buildplate_marker_detector")) {
+                                        xcam_buildplate_marker_detector = jj["xcam"]["buildplate_marker_detector"].get<bool>();
+                                        is_support_build_plate_marker_detect = true;
+                                    } else {
+                                        is_support_build_plate_marker_detect = false;
+                                    }
+                                }
+                                if (jj["xcam"].contains("buildplate_marker_detector")){
+                                    xcam_build_plate_type_detect.UpdateValue(jj["xcam"]["buildplate_marker_detector"].get<bool>());
+                                }
+                            }
+                        }
+                        catch (...) {
+                            ;
+                        }
+                    }
+#pragma endregion
+
+#pragma region hms
+                    if (!key_field_only && jj.contains("hms")) {
+                        m_hms_system->ParseHMSItems(jj["hms"]);
+                    }
+#pragma endregion
+
+
+#pragma region push_ams
+                    /* ams status */
+                    try {
+                        if (jj.contains("ams_status")) {
+                            int ams_status = jj["ams_status"].get<int>();
+                            this->_parse_ams_status(ams_status);
+                        }
+                        std::string str_j = jj.dump();
+                        if (jj.contains("cali_version")) {
+                            cali_version = jj["cali_version"].get<int>();
+                        }
+                        else {
+                            cali_version = -1;
+                        }
+                        std::string str = jj.dump();
+                    }
+                    catch (...) {
+                        ;
+                    }
+                    update_printer_preset_name();
+                    update_filament_list();
+                    if (jj.contains("ams")) {
+                        DevFilaSystemParser::ParseV1_0(jj, this, m_fila_system, key_field_only);
+                    }
+
+                    /* vitrual tray*/
+                    if (!key_field_only) {
+                        try {
+                            if (jj.contains("vir_slot") && jj["vir_slot"].is_array()) {
+
+                                for (auto it = jj["vir_slot"].begin(); it != jj["vir_slot"].end(); it++) {
+                                    auto vslot = parse_vt_tray(it.value().get<json>());
+
+                                    if (vslot.id == std::to_string(VIRTUAL_TRAY_MAIN_ID)) {
+                                        auto it = std::next(vt_slot.begin(), 0);
+                                        if (it != vt_slot.end()) {
+                                            vt_slot[0] = vslot;
+                                        }
+                                        else {
+                                            vt_slot.push_back(vslot);
+                                        }
+                                    }
+                                    else if (vslot.id == std::to_string(VIRTUAL_TRAY_DEPUTY_ID)) {
+                                        auto it = std::next(vt_slot.begin(), 1);
+                                        if (it != vt_slot.end()) {
+                                            vt_slot[1] = vslot;
+                                        }
+                                        else {
+                                            vt_slot.push_back(vslot);
+                                        }
+                                    }
+                                }
+
+                            }
+                            else if (jj.contains("vt_tray")) {
+                                auto main_slot = parse_vt_tray(jj["vt_tray"].get<json>());
+                                main_slot.id = std::to_string(VIRTUAL_TRAY_MAIN_ID);
+
+
+                                auto it = std::next(vt_slot.begin(), 0);
+                                if (it != vt_slot.end()) {
+                                    vt_slot[0] = main_slot;
+                                }
+                                else {
+                                    vt_slot.push_back(main_slot);
+                                }
+                            }
+                            else {
+                                ams_support_virtual_tray = false;
+                            }
+                        }
+                        catch (...) {
+                            ;
+                        }
+                    }
+
+                    /*parse new print data*/
+                    try {
+                        parse_new_info(jj);
+                    } catch (...) {}
+#pragma endregion
+                } else if (jj["command"].get<std::string>() == "gcode_line") {
+                    if (m_agent && DevUtil::is_studio_cmd(sequence_id)) {
+                        json t;
+                        //t["dev_id"] = this->get_dev_id();
+                        t["dev_id"] = "";
+                        t["signal"] = this->wifi_signal;
+                        t["gcode"] = j.dump();
+                        m_agent->track_event("ack_cmd_gcode_line", t.dump());
+                    }
+                } else if (jj["command"].get<std::string>() == "project_prepare") {
+                    if (m_agent) {
+                        if (jj.contains("job_id")) {
+                            this->job_id_ = DevJsonValParser::get_longlong_val(jj["job_id"]);
+                        }
+                    }
+
+                } else if (jj["command"].get<std::string>() == "project_file") {
+                    if (m_agent) {
+                        json t;
+                        //t["dev_id"] = this->get_dev_id();
+                        t["dev_id"] = "";
+                        t["signal"] = this->wifi_signal;
+                        m_agent->track_event("ack_cmd_project_file", t.dump());
+                    }
+                    std::string result;
+                    if (jj.contains("result")) {
+                        result = jj["result"].get<std::string>();
+                        if (result == "FAIL") {
+                            wxString text = _L("Failed to start printing job");
+                            GUI::wxGetApp().push_notification(this, text);
+                        }
+                    }
+                } else if (jj["command"].get<std::string>() == "ams_filament_setting" && !key_field_only) {
+                    // BBS trigger ams UI update
+                    ams_version = -1;
+
+                    if (jj["ams_id"].is_number()) {
+                        int ams_id = jj["ams_id"].get<int>();
+                        int tray_id = 0;
+                        if (jj.contains("tray_id")) {
+                            tray_id = jj["tray_id"].get<int>();
+                        }
+                        if (ams_id == 255 && tray_id == VIRTUAL_TRAY_MAIN_ID) {
+                            BOOST_LOG_TRIVIAL(info) << "ams_filament_setting, parse tray info";
+                            vt_slot[0].nozzle_temp_max = std::to_string(jj["nozzle_temp_max"].get<int>());
+                            vt_slot[0].nozzle_temp_min = std::to_string(jj["nozzle_temp_min"].get<int>());
+                            vt_slot[0].color = jj["tray_color"].get<std::string>();
+                            vt_slot[0].setting_id = jj["tray_info_idx"].get<std::string>();
+                            //vt_tray.type = jj["tray_type"].get<std::string>();
+                            vt_slot[0].m_fila_type = setting_id_to_type(vt_slot[0].setting_id, jj["tray_type"].get<std::string>());
+                            // delay update
+                            vt_slot[0].set_hold_count();
+                        } else {
+                            auto ams = m_fila_system->GetAmsById(std::to_string(ams_id));
+                            if (ams) {
+                                tray_id = jj["tray_id"].get<int>();
+                                auto tray_it = ams->GetTrays().find(std::to_string(tray_id));
+                                if (tray_it != ams->GetTrays().end()) {
+                                    BOOST_LOG_TRIVIAL(trace) << "ams_filament_setting, parse tray info";
+                                    tray_it->second->nozzle_temp_max = std::to_string(jj["nozzle_temp_max"].get<int>());
+                                    tray_it->second->nozzle_temp_min = std::to_string(jj["nozzle_temp_min"].get<int>());
+                                    //tray_it->second->type = jj["tray_type"].get<std::string>();
+                                    tray_it->second->color = jj["tray_color"].get<std::string>();
+
+                                    /*tray_it->second->cols.clear();
+                                    if (jj.contains("cols")) {
+                                        if (jj["cols"].is_array()) {
+                                            for (auto it = jj["cols"].begin(); it != jj["cols"].end(); it++) {
+                                                tray_it->second->cols.push_back(it.value().get<std::string>());
+                                            }
+                                        }
+                                    }*/
+
+                                    tray_it->second->setting_id = jj["tray_info_idx"].get<std::string>();
+                                    tray_it->second->m_fila_type = setting_id_to_type(tray_it->second->setting_id, jj["tray_type"].get<std::string>());
+                                    // delay update
+                                    tray_it->second->set_hold_count();
+                                } else {
+                                    BOOST_LOG_TRIVIAL(warning) << "ams_filament_setting, can not find in trayList, tray_id=" << tray_id;
+                                }
+                            } else {
+                                BOOST_LOG_TRIVIAL(warning) << "ams_filament_setting, can not find in amsList, ams_id=" << ams_id;
+                            }
+                        }
+                    }
+                } else if (jj["command"].get<std::string>() == "xcam_control_set" && !key_field_only) {
+                    if (jj.contains("module_name")) {
+                        if (jj.contains("enable") || jj.contains("control")) {
+                            bool enable = false;
+                            if (jj.contains("enable"))
+                                enable = jj["enable"].get<bool>();
+                            else if (jj.contains("control"))
+                                enable = jj["control"].get<bool>();
+                            else {
+                                ;
+                            }
+
+                            if (jj["module_name"].get<std::string>() == "first_layer_inspector") {
+                                if (time(nullptr) - xcam_first_layer_hold_start > HOLD_TIME_3SEC) {
+                                    xcam_first_layer_inspector = enable;
+                                }
+                            }
+                            else if (jj["module_name"].get<std::string>() == "buildplate_marker_detector") {
+                                if (time(nullptr) - xcam_buildplate_marker_hold_start > HOLD_TIME_3SEC) {
+                                    xcam_buildplate_marker_detector = enable;
+                                }
+                                xcam_build_plate_type_detect.UpdateValue(enable);
+                            }
+                            else if (jj["module_name"].get<std::string>() == "plate_offset_switch") {
+                                xcam_build_plate_align_detect.UpdateValue(enable);
+                            }
+                            else if (jj["module_name"].get<std::string>() == "printing_monitor") {
+                                if (time(nullptr) - xcam_ai_monitoring_hold_start > HOLD_TIME_3SEC) {
+                                    xcam_ai_monitoring = enable;
+                                    if (jj.contains("halt_print_sensitivity")) {
+                                        xcam_ai_monitoring_sensitivity = jj["halt_print_sensitivity"].get<std::string>();
+                                    }
+                                }
+                            }
+                            else if (jj["module_name"].get<std::string>() == "spaghetti_detector") {
+                                if (time(nullptr) - xcam_ai_monitoring_hold_start > HOLD_TIME_3SEC) {
+                                    // old protocol
+                                    xcam_ai_monitoring = enable;
+                                    if (jj.contains("print_halt")) {
+                                        if (jj["print_halt"].get<bool>()) {
+                                            xcam_ai_monitoring_sensitivity = "medium";
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                } else if(jj["command"].get<std::string>() == "print_option") {
+                     try {
+                          if (jj.contains("option")) {
+                              if (jj["option"].is_number()) {
+                                  int option = jj["option"].get<int>();
+                                  if (time(nullptr) - xcam_auto_recovery_hold_start > HOLD_TIME_3SEC) {
+                                      xcam_auto_recovery_step_loss = ((option >> (int)PRINT_OP_AUTO_RECOVERY) & 0x01) != 0;
+                                  }
+                              }
+                          }
+
+                          if (time(nullptr) - xcam_auto_recovery_hold_start > HOLD_TIME_3SEC) {
+                              if (jj.contains("auto_recovery")) {
+                                  xcam_auto_recovery_step_loss = jj["auto_recovery"].get<bool>();
+                              }
+                          }
+                     }
+                     catch(...) {
+                     }
+                } else if (jj["command"].get<std::string>() == "extrusion_cali" || jj["command"].get<std::string>() == "flowrate_cali") {
+                    if (jj.contains("result")) {
+                        if (jj["result"].get<std::string>() == "success") {
+                            ;
+                        }
+                        else if (jj["result"].get<std::string>() == "fail") {
+                            std::string cali_mode = jj["command"].get<std::string>();
+                            std::string reason = jj["reason"].get<std::string>();
+                            wxString info = "";
+                            if (reason == "invalid nozzle_diameter" || reason == "nozzle_diameter is not supported") {
+                                info = _L("This calibration does not support the currently selected nozzle diameter");
+                            }
+                            else if (reason == "invalid handle_flowrate_cali param") {
+                                info = _L("Current flowrate cali param is invalid");
+                            }
+                            else if (reason == "nozzle_diameter is not matched") {
+                                info = _L("Selected diameter and machine diameter do not match");
+                            }
+                            else if (reason == "generate auto filament cali gcode failure") {
+                                info = _L("Failed to generate cali gcode");
+                            }
+                            else {
+                                info = reason;
+                            }
+                            GUI::wxGetApp().push_notification(this, info, _L("Calibration error"), UserNotificationStyle::UNS_WARNING_CONFIRM);
+                            BOOST_LOG_TRIVIAL(info) << cali_mode << " result fail, reason = " << reason;
+                        }
+                    }
+                } else if (jj["command"].get<std::string>() == "extrusion_cali_set") {
+                    int ams_id = -1;
+                    int tray_id = -1;
+                    int curr_tray_id = -1;
+                    if (jj.contains("tray_id")) {
+                        try {
+                            curr_tray_id = jj["tray_id"].get<int>();
+                            if (curr_tray_id == VIRTUAL_TRAY_MAIN_ID)
+                                tray_id = curr_tray_id;
+                            else if (curr_tray_id >= 0 && curr_tray_id < 16){
+                                ams_id = curr_tray_id / 4;
+                                tray_id = curr_tray_id % 4;
+                            } else {
+                                BOOST_LOG_TRIVIAL(trace) << "extrusion_cali_set: unsupported tray_id = " << curr_tray_id;
+                            }
+                        }
+                        catch(...) {
+                            ;
+                        }
+                    }
+                    if (tray_id == VIRTUAL_TRAY_MAIN_ID) {
+                        if (jj.contains("k_value"))
+                            vt_slot[0].k = jj["k_value"].get<float>();
+                        if (jj.contains("n_coef"))
+                            vt_slot[0].n = jj["n_coef"].get<float>();
+                    } else {
+
+                        auto ams_item = m_fila_system->GetAmsById(std::to_string(ams_id));
+                        if (ams_item) {
+                            auto tray_item = ams_item->GetTrays().find(std::to_string(tray_id));
+                            if (tray_item != ams_item->GetTrays().end()) {
+                                if (jj.contains("k_value"))
+                                    tray_item->second->k = jj["k_value"].get<float>();
+                                if (jj.contains("n_coef"))
+                                    tray_item->second->n = jj["n_coef"].get<float>();
+                            }
+                        }
+                    }
+                    extrusion_cali_set_tray_id = curr_tray_id;
+                    extrusion_cali_set_hold_start = std::chrono::system_clock::now();
+                }
+                else if (jj["command"].get<std::string>() == "extrusion_cali_sel") {
+                    int ams_id       = -1;
+                    int slot_id      = -1;
+                    int tray_id      = -1;
+
+                    if (jj.contains("ams_id")) {
+                        try {
+                            ams_id  = jj["ams_id"].get<int>();
+                            slot_id = jj["slot_id"].get<int>();
+                        } catch (...) {
+                            ;
+                        }
+                    }
+                    else {
+                        tray_id = jj["tray_id"].get<int>();
+                        if(tray_id >= 0 && tray_id < 16)
+                        {
+                            ams_id  = tray_id / 4;
+                            slot_id = tray_id % 4;
+                        }
+                        else if(tray_id == VIRTUAL_TRAY_MAIN_ID || tray_id == VIRTUAL_TRAY_DEPUTY_ID){
+                            ams_id  = tray_id;
+                            slot_id = 0;
+                        }
+                    }
+
+                    BOOST_LOG_TRIVIAL(trace) << "extrusion_cali_sel: unsupported ams_id = " << ams_id << "slot_id = " << slot_id;
+
+                    if (jj.contains("cali_idx")) {
+                        if (ams_id == VIRTUAL_TRAY_MAIN_ID || ams_id == VIRTUAL_TRAY_DEPUTY_ID) {
+
+                            if (ams_id == VIRTUAL_TRAY_MAIN_ID && vt_slot.size() > 0) {
+
+                                vt_slot[MAIN_EXTRUDER_ID].cali_idx = jj["cali_idx"].get<int>();
+                                vt_slot[MAIN_EXTRUDER_ID].set_hold_count();
+
+                            } else if (ams_id == VIRTUAL_TRAY_DEPUTY_ID && vt_slot.size() > 1) {
+
+                                vt_slot[DEPUTY_EXTRUDER_ID].cali_idx = jj["cali_idx"].get<int>();
+                                vt_slot[DEPUTY_EXTRUDER_ID].set_hold_count();
+
+                            }
+
+                        }
+                        else {
+                            auto tray_item = m_fila_system->GetAmsTray(std::to_string(ams_id), std::to_string(slot_id));
+                            if (tray_item)
+                            {
+                                tray_item->cali_idx = jj["cali_idx"].get<int>();
+                                tray_item->set_hold_count();
+                            }
+                        }
+                    }
+
+                }
+                else if (jj["command"].get<std::string>() == "extrusion_cali_get") {
+                    if (request_tab_from_bbs) {
+                        request_tab_from_bbs = false;
+                        reset_pa_cali_history_result();
+                        bool is_succeed = true;
+                        if (jj.contains("result") && jj.contains("reason")) {
+                            if (jj["result"].get<std::string>() == "fail") {
+                                is_succeed = false;
+                            }
+                        }
+
+                        if (is_succeed) {
+                            last_cali_version = cali_version;
+                            has_get_pa_calib_tab = true;
+                        }
+
+                        if (jj.contains("filaments") && jj["filaments"].is_array()) {
+                            try {
+                                for (auto it = jj["filaments"].begin(); it != jj["filaments"].end(); it++) {
+                                    PACalibResult pa_calib_result;
+                                    pa_calib_result.filament_id = (*it)["filament_id"].get<std::string>();
+                                    pa_calib_result.name        = (*it)["name"].get<std::string>();
+                                    pa_calib_result.cali_idx    = (*it)["cali_idx"].get<int>();
+
+                                    if ((*it).contains("setting_id")) {
+                                        pa_calib_result.setting_id  = (*it)["setting_id"].get<std::string>();
+                                    }
+
+                                    if ((*it).contains("extruder_id")) {
+                                        pa_calib_result.extruder_id = (*it)["extruder_id"].get<int>();
+                                    }
+
+                                    if ((*it).contains("nozzle_id")) {
+                                        pa_calib_result.nozzle_volume_type = convert_to_nozzle_type((*it)["nozzle_id"].get<std::string>());
+                                    }
+
+                                    if ((*it).contains("nozzle_pos")) {
+                                        pa_calib_result.nozzle_pos_id = (*it)["nozzle_pos"].get<int>();
+                                    }
+
+                                    if ((*it).contains("nozzle_sn")) {
+                                        pa_calib_result.nozzle_sn = (*it)["nozzle_sn"].get<std::string>();
+                                    }
+
+                                    if (jj["nozzle_diameter"].is_number_float()) {
+                                        pa_calib_result.nozzle_diameter = jj["nozzle_diameter"].get<float>();
+                                    } else if (jj["nozzle_diameter"].is_string()) {
+                                        pa_calib_result.nozzle_diameter = string_to_float(jj["nozzle_diameter"].get<std::string>());
+                                    }
+
+                                    if ((*it)["k_value"].is_number_float())
+                                        pa_calib_result.k_value = (*it)["k_value"].get<float>();
+                                    else if ((*it)["k_value"].is_string())
+                                        pa_calib_result.k_value = string_to_float((*it)["k_value"].get<std::string>());
+
+                                    if ((*it)["n_coef"].is_number_float())
+                                        pa_calib_result.n_coef = (*it)["n_coef"].get<float>();
+                                    else if ((*it)["n_coef"].is_string())
+                                        pa_calib_result.n_coef = string_to_float((*it)["n_coef"].get<std::string>());
+
+                                    if (check_pa_result_validation(pa_calib_result))
+                                        pa_calib_tab.push_back(pa_calib_result);
+                                    else {
+                                        BOOST_LOG_TRIVIAL(info) << "pa result is invalid";
+                                    }
+                                }
+
+                            }
+                            catch (...) {
+
+                            }
+                        }
+                        // notify cali history to update
+                    }
+                }
+                else if (jj["command"].get<std::string>() == "extrusion_cali_get_result") {
+                    reset_pa_cali_result();
+                    bool is_succeed = true;
+                    if (jj.contains("result") && jj.contains("reason")) {
+                        if (jj["result"].get<std::string>() == "fail") {
+                            if (jj.contains("err_code")) {
+                                is_succeed    = false;
+                            }
+                        }
+                    }
+
+                    if (is_succeed)
+                        get_pa_calib_result = true;
+
+                    if (jj.contains("filaments") && jj["filaments"].is_array()) {
+                        try {
+                            for (auto it = jj["filaments"].begin(); it != jj["filaments"].end(); it++) {
+                                PACalibResult pa_calib_result;
+                                pa_calib_result.filament_id = (*it)["filament_id"].get<std::string>();
+
+                                if ((*it).contains("setting_id")) {
+                                    pa_calib_result.setting_id  = (*it)["setting_id"].get<std::string>();
+                                }
+
+                                // old
+                                if (jj["nozzle_diameter"].is_number_float()) {
+                                    pa_calib_result.nozzle_diameter = jj["nozzle_diameter"].get<float>();
+                                } else if (jj["nozzle_diameter"].is_string()) {
+                                    pa_calib_result.nozzle_diameter = string_to_float(jj["nozzle_diameter"].get<std::string>());
+                                }
+
+                                // new: should get nozzle diameter from filament item
+                                if ((*it).contains("setting_id")) {
+                                    if ((*it)["nozzle_diameter"].is_number_float()) {
+                                        pa_calib_result.nozzle_diameter = (*it)["nozzle_diameter"].get<float>();
+                                    } else if ((*it)["nozzle_diameter"].is_string()) {
+                                        pa_calib_result.nozzle_diameter = string_to_float((*it)["nozzle_diameter"].get<std::string>());
+                                    }
+                                }
+
+                                if (it->contains("ams_id")) {
+                                    pa_calib_result.ams_id = (*it)["ams_id"].get<int>();
+                                } else {
+                                    pa_calib_result.ams_id = 0;
+                                }
+
+                                if (it->contains("slot_id")) {
+                                    pa_calib_result.slot_id = (*it)["slot_id"].get<int>();
+                                } else {
+                                    pa_calib_result.slot_id = 0;
+                                }
+
+                                if (it->contains("extruder_id")) {
+                                    pa_calib_result.extruder_id = (*it)["extruder_id"].get<int>();
+                                } else {
+                                    pa_calib_result.extruder_id = -1;
+                                }
+
+                                if (it->contains("nozzle_id")) {
+                                    pa_calib_result.nozzle_volume_type = convert_to_nozzle_type((*it)["nozzle_id"].get<std::string>());
+                                } else {
+                                    pa_calib_result.nozzle_volume_type = NozzleVolumeType::nvtStandard;
+                                }
+
+                                if (it->contains("nozzle_pos")) {
+                                    pa_calib_result.nozzle_pos_id = (*it)["nozzle_pos"].get<int>();
+                                }
+
+                                if (it->contains("nozzle_sn")) {
+                                    pa_calib_result.nozzle_sn = (*it)["nozzle_sn"].get<std::string>();
+                                }
+
+                                if ((*it)["k_value"].is_number_float())
+                                    pa_calib_result.k_value = (*it)["k_value"].get<float>();
+                                else if ((*it)["k_value"].is_string())
+                                    pa_calib_result.k_value = string_to_float((*it)["k_value"].get<std::string>());
+
+                                if ((*it)["n_coef"].is_number_float())
+                                    pa_calib_result.n_coef = (*it)["n_coef"].get<float>();
+                                else if ((*it)["n_coef"].is_string())
+                                    pa_calib_result.n_coef = string_to_float((*it)["n_coef"].get<std::string>());
+
+                                if (it->contains("confidence")) {
+                                    pa_calib_result.confidence = (*it)["confidence"].get<int>();
+                                } else {
+                                    pa_calib_result.confidence = 0;
+                                }
+
+                                if (this->is_support_new_auto_cali_method)
+                                    pa_calib_result.tray_id = get_tray_id_by_ams_id_and_slot_id(pa_calib_result.ams_id, pa_calib_result.slot_id);
+                                else
+                                    pa_calib_result.tray_id = (*it)["tray_id"].get<int>();
+
+                                if (check_pa_result_validation(pa_calib_result))
+                                    pa_calib_results.push_back(pa_calib_result);
+                                else {
+                                    BOOST_LOG_TRIVIAL(info) << "pa result is invalid";
+                                }
+                            }
+                        } catch (...) {}
+                    }
+
+                    if (pa_calib_results.empty()) {
+                        BOOST_LOG_TRIVIAL(info) << "no pa calib result";
+                    }
+                }
+                else if (jj["command"].get<std::string>() == "flowrate_get_result" && !key_field_only) {
+                    this->reset_flow_rate_cali_result();
+
+                    get_flow_calib_result = true;
+                    if (jj.contains("filaments") && jj["filaments"].is_array()) {
+                        try {
+                            for (auto it = jj["filaments"].begin(); it != jj["filaments"].end(); it++) {
+                                FlowRatioCalibResult flow_ratio_calib_result;
+                                flow_ratio_calib_result.tray_id     = (*it)["tray_id"].get<int>();
+                                flow_ratio_calib_result.filament_id = (*it)["filament_id"].get<std::string>();
+                                flow_ratio_calib_result.setting_id  = (*it)["setting_id"].get<std::string>();
+                                flow_ratio_calib_result.nozzle_diameter = string_to_float(jj["nozzle_diameter"].get<std::string>());
+                                flow_ratio_calib_result.flow_ratio      = string_to_float((*it)["flow_ratio"].get<std::string>());
+                                if (it->contains("confidence")) {
+                                    flow_ratio_calib_result.confidence = (*it)["confidence"].get<int>();
+                                } else {
+                                    flow_ratio_calib_result.confidence = 0;
+                                }
+
+                                flow_ratio_results.push_back(flow_ratio_calib_result);
+                            }
+
+                        } catch (...) {}
+                    }
+                }
+               m_fan->command_handle_response(jj);
+            }
+        }
+
+        if (!key_field_only) {
+            try {
+                if (j.contains("camera")) {
+                    if (j["camera"].contains("command")) {
+                        if (j["camera"]["command"].get<std::string>() == "ipcam_timelapse") {
+                            if (camera_timelapse_hold_count > 0) {
+                                camera_timelapse_hold_count--;
+                            }
+                            else
+                            {
+                                if (j["camera"]["control"].get<std::string>() == "enable") this->camera_timelapse = true;
+                                if (j["camera"]["control"].get<std::string>() == "disable") this->camera_timelapse = false;
+                                BOOST_LOG_TRIVIAL(info) << "ack of timelapse = " << camera_timelapse;
+                            }
+                        } else if (j["camera"]["command"].get<std::string>() == "ipcam_record_set") {
+                            if (time(nullptr) - camera_recording_ctl_start > HOLD_TIME_3SEC) {
+                                if (j["camera"]["control"].get<std::string>() == "enable") this->camera_recording_when_printing = true;
+                                if (j["camera"]["control"].get<std::string>() == "disable") this->camera_recording_when_printing = false;
+                                BOOST_LOG_TRIVIAL(info) << "ack of ipcam_record_set " << camera_recording_when_printing;
+                            }
+                        } else if (j["camera"]["command"].get<std::string>() == "ipcam_resolution_set") {
+                            if (camera_resolution_hold_count > 0) {
+                                camera_resolution_hold_count--;
+                            }
+                            else
+                            {
+                                this->camera_resolution = j["camera"]["resolution"].get<std::string>();
+                                BOOST_LOG_TRIVIAL(info) << "ack of resolution = " << camera_resolution;
+                            }
+                        }
+                    }
+                }
+            } catch (...) {}
+        }
+
+        if (!key_field_only) {
+            // upgrade
+            try {
+                if (j.contains("upgrade")) {
+                    if (j["upgrade"].contains("command")) {
+                        bool check_studio_cmd = true;
+                        if (j["upgrade"].contains("sequence_id")) {
+                            try
+                            {
+                                std::string str_seq = j["upgrade"]["sequence_id"].get<std::string>();
+                                check_studio_cmd = DevUtil::is_studio_cmd(stoi(str_seq));
+                            }
+                            catch (...) { }
+                        }
+
+                        if (check_studio_cmd && j["upgrade"].contains("err_code")) {
+                            if (j["upgrade"]["err_code"].is_number()) {
+                                add_command_error_code_dlg(j["upgrade"]["err_code"].get<int>());
+                            }
+                        }
+                    }
+                }
+            }
+            catch (...) {
+                ;
+            }
+        }
+
+        // event info
+        try {
+            if (j.contains("event")) {
+                if (j["event"].contains("event")) {
+                    if (j["event"]["event"].get<std::string>() == "client.disconnected")
+                        set_online_state(false);
+                    else if (j["event"]["event"].get<std::string>() == "client.connected")
+                        set_online_state(true);
+                }
+            }
+        }
+        catch (...)  {}
+
+        if (!key_field_only) {
+            BOOST_LOG_TRIVIAL(trace) << "parse_json  m_active_state =" << m_active_state;
+            parse_state_changed_event();
+        }
+    }
+    catch (const nlohmann::json::exception& e) {
+        // Handle JSON parsing exceptions if necessary
+        BOOST_LOG_TRIVIAL(trace) << "parse_json failed! dev_id=" << BBLCrossTalk::Crosstalk_DevId(this->get_dev_id()) <<", ewhat = " << e.what();
+    } catch (...) {
+        BOOST_LOG_TRIVIAL(trace) << "parse_json failed! dev_id=" << BBLCrossTalk::Crosstalk_DevId(this->get_dev_id());
+    }
+
+    std::chrono::system_clock::time_point clock_stop = std::chrono::system_clock::now();
+    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(clock_stop - clock_start);
+    if (diff.count() > 10.0f) {
+        BOOST_LOG_TRIVIAL(trace) << "parse_json timeout = " << diff.count();
+    }
+
+    return 0;
+}
+
+void MachineObject::set_ctt_dlg( wxString text){
+    if (!m_set_ctt_dlg) {
+        m_set_ctt_dlg = true;
+        auto print_error_dlg = new GUI::SecondaryCheckDialog(nullptr, wxID_ANY, _L("Warning"), GUI::SecondaryCheckDialog::ButtonStyle::ONLY_CONFIRM);
+        print_error_dlg->update_text(text);
+        print_error_dlg->Bind(wxEVT_SHOW, [this](auto& e) {
+            if (!e.IsShown()) {
+                m_set_ctt_dlg = false;
+            }
+            });
+        print_error_dlg->Bind(wxEVT_CLOSE_WINDOW, [this](auto& e) {
+            e.Skip();
+            m_set_ctt_dlg = false;
+            });
+        print_error_dlg->on_show();
+
+    }
+}
+
+int MachineObject::publish_gcode(std::string gcode_str)
+{
+    json j;
+    j["print"]["command"] = "gcode_line";
+    j["print"]["param"] = gcode_str;
+    j["print"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+
+    if (m_agent) {
+        j["print"]["user_id"] = m_agent->get_user_id();
+        json t;
+        //t["dev_id"] = this->get_dev_id();
+        t["dev_id"] = "";
+        t["signal"] = this->wifi_signal;
+        t["gcode"] = j.dump();
+        m_agent->track_event("cmd_gcode_line", t.dump());
+    }
+
+    return publish_json(j);
+}
+
+void MachineObject::update_device_cert_state(bool ready)
+{
+    device_cert_installed = ready;
+}
+
+BBLSubTask* MachineObject::get_subtask()
+{
+    if (!subtask_)
+        subtask_ = new BBLSubTask(nullptr);
+    return subtask_;
+}
+
+BBLModelTask* MachineObject::get_modeltask()
+{
+    return model_task;
+}
+
+void MachineObject::set_modeltask(BBLModelTask* task)
+{
+    model_task = task;
+}
+
+void MachineObject::update_model_task()
+{
+    if (request_model_result > 10) return;
+    if (!m_agent) return;
+    if (!model_task) return;
+    if (!subtask_) return;
+    if (model_task->task_id != subtask_->task_id) {
+        BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " times: " << request_model_result << " model_task_id !=subtask_id";
+        return;
+    }
+    if (model_task->instance_id <= 0) {
+        BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " times: " << request_model_result << " instance_id <= 0";
+        return;
+    }
+
+    if ((!subtask_id_.empty() && last_subtask_id_ != subtask_id_) || get_model_mall_result_need_retry) {
+        if (!subtask_id_.empty() && last_subtask_id_ != subtask_id_) {
+            BOOST_LOG_TRIVIAL(info) << "update_model_task: last=" << last_subtask_id_ << ", curr=" << subtask_id_;
+            last_subtask_id_     = subtask_id_;
+            request_model_result = 0;
+        }
+        if (get_model_mall_result_need_retry) {
+            BOOST_LOG_TRIVIAL(info) << "need retry";
+            get_model_mall_result_need_retry = false;
+        }
+    } else {
+        BOOST_LOG_TRIVIAL(info) << "subtask_id_ no change and do not need retry";
+        return;
+    }
+
+    int curr_instance_id = model_task->instance_id;
+    if (rating_info) {
+        delete rating_info;
+        rating_info = nullptr;
+    }
+    get_model_task_thread = new boost::thread([this, curr_instance_id, token = std::weak_ptr<int>(m_token)]{
+        if (token.expired()) { return; }
+        try {
+            std::string  rating_result;
+            unsigned int http_code = 404;
+            std::string  http_error;
+            int          res = -1;
+            res = m_agent->get_model_mall_rating_result(curr_instance_id, rating_result, http_code, http_error);
+            request_model_result++;
+            BOOST_LOG_TRIVIAL(info) << "request times: " << request_model_result << " http code: " << http_code;
+            auto rating_info = new DevPrintTaskRatingInfo();
+            rating_info->http_code = http_code;
+            if (0 == res && 200 == http_code) {
+                try {
+                    json rating_json = json::parse(rating_result);
+                    if (rating_json.contains("id")) {
+                        rating_info->rating_id = rating_json["id"].get<unsigned int>();
+                        //rating id is necessary info, so rating id must have
+                        request_model_result            = 0;
+                        rating_info->request_successful = true;
+                        BOOST_LOG_TRIVIAL(info) << "get rating id";
+                    } else {
+                        rating_info->request_successful = false;
+                        BOOST_LOG_TRIVIAL(info) << "can not get rating id";
+                        Slic3r::GUI::wxGetApp().CallAfter([this, token, rating_info]() {
+                            if (!token.expired()) this->rating_info = rating_info;
+                        });
+                        return;
+                    }
+                    if (rating_json.contains("score")) {
+                            rating_info->start_count = rating_json["score"].get<int>();
+                        }
+                    if (rating_json.contains("content"))
+                        rating_info->content = rating_json["content"].get<std::string>();
+                    if (rating_json.contains("successPrinted"))
+                        rating_info->success_printed = rating_json["successPrinted"].get<bool>();
+                    if (rating_json.contains("images")) {
+                        rating_info->image_url_paths = rating_json["images"].get<std::vector<std::string>>();
+                    }
+                    Slic3r::GUI::wxGetApp().CallAfter([this, token, rating_info]() {
+                        if (!token.expired()) this->rating_info = rating_info;
+                    });
+                } catch (...) {
+                    BOOST_LOG_TRIVIAL(info) << "parse model mall result json failed";
+                }
+            }
+            else {
+                rating_info->request_successful = false;
+                Slic3r::GUI::wxGetApp().CallAfter([this, token, rating_info]() {
+                    if (!token.expired()) this->rating_info = rating_info;
+                });
+                BOOST_LOG_TRIVIAL(info) << "model mall result request failed, request time: " << request_model_result << " http_code: " << http_code
+                                        << " error msg: " << http_error;
+                return;
+            }
+        }
+        catch (...) {
+            BOOST_LOG_TRIVIAL(info) << "get mall model rating id failed and hide scoring page";
+        }
+    });
+}
+
+void MachineObject::free_slice_info()
+{
+    if (get_slice_info_thread)
+    {
+        if (get_slice_info_thread->joinable())
+        {
+            get_slice_info_thread->interrupt();
+            get_slice_info_thread->join();
+        }
+
+        delete get_slice_info_thread;
+        get_slice_info_thread = nullptr;
+    }
+
+    if (slice_info)
+    {
+        delete slice_info;
+        slice_info = nullptr;
+    }
+}
+
+void MachineObject::update_slice_info(std::string project_id, std::string profile_id, std::string subtask_id, int plate_idx)
+{
+    if (!m_agent) return;
+
+    if (project_id_ != project_id || profile_id_ != profile_id || slice_info == nullptr || subtask_id_ != subtask_id) {
+        project_id_ = project_id;
+        profile_id_ = profile_id;
+        subtask_id_ = subtask_id;
+
+        if (project_id.empty()
+            || profile_id.empty()
+            || subtask_id.empty()) {
+            return;
+        }
+
+        if (project_id.compare("0") == 0
+            || profile_id.compare("0") == 0
+            || subtask_id.compare("0") == 0) return;
+
+        BOOST_LOG_TRIVIAL(trace) << "slice_info: start";
+        slice_info = new BBLSliceInfo();
+        get_slice_info_thread = new boost::thread([this, project_id, profile_id, subtask_id, plate_idx] {
+            int plate_index = -1;
+
+            if (!m_agent) return;
+            if (!slice_info) return;
+            if (!get_slice_info_thread) return;/*STUDIO-12264*/
+            if (get_slice_info_thread->interruption_requested()) { return;}
+
+            if (plate_idx >= 0) {
+                plate_index = plate_idx;
+                this->m_plate_index = plate_idx;
+            }
+            else {
+                std::string subtask_json;
+                unsigned http_code = 0;
+                std::string http_body;
+                if (m_agent->get_subtask_info(subtask_id, &subtask_json, &http_code, &http_body) == 0) {
+                    try {
+                        if (!subtask_json.empty()) {
+
+                            json task_j = json::parse(subtask_json);
+                            if (task_j.contains("content")) {
+                                std::string content_str = task_j["content"].get<std::string>();
+                                json content_j = json::parse(content_str);
+                                plate_index = content_j["info"]["plate_idx"].get<int>();
+                            }
+
+                            if (task_j.contains("context") && task_j["context"].contains("plates")) {
+                                for (int i = 0; i < task_j["context"]["plates"].size(); i++) {
+                                    if (task_j["context"]["plates"][i].contains("index") && task_j["context"]["plates"][i]["index"].get<int>() == plate_index) {
+                                        if (task_j["context"]["plates"][i].contains("thumbnail") && task_j["context"]["plates"][i]["thumbnail"].contains("url")) {
+                                            slice_info->thumbnail_url = task_j["context"]["plates"][i]["thumbnail"]["url"].get<std::string>();
+                                        }
+                                        if (task_j["context"]["plates"][i].contains("prediction")) {
+                                            slice_info->prediction = task_j["context"]["plates"][i]["prediction"].get<int>();
+                                        }
+                                        if (task_j["context"]["plates"][i].contains("weight")) {
+                                            slice_info->weight = task_j["context"]["plates"][i]["weight"].get<float>();
+                                        }
+                                        if (!task_j["context"]["plates"][i]["filaments"].is_null()) {
+                                            for (auto filament : task_j["context"]["plates"][i]["filaments"]) {
+                                                FilamentInfo f;
+                                                if(filament.contains("color")){
+                                                    f.color = filament["color"].get<std::string>();
+                                                }
+                                                if (filament.contains("type")) {
+                                                    f.type = filament["type"].get<std::string>();
+                                                }
+                                                if (filament.contains("used_g")) {
+                                                    f.used_g = stof(filament["used_g"].get<std::string>());
+                                                }
+                                                if (filament.contains("used_m")) {
+                                                    f.used_m = stof(filament["used_m"].get<std::string>());
+                                                }
+                                                slice_info->filaments_info.push_back(f);
+                                            }
+                                        }
+
+                                        #if !BBL_RELEASE_TO_PUBLIC
+                                        BOOST_LOG_TRIVIAL(trace) << "task_info: thumbnail url=" << slice_info->thumbnail_url;
+                                        #endif
+                                    }
+                                }
+                            }
+                            else {
+                                BOOST_LOG_TRIVIAL(error) << "task_info: no context or plates";
+                            }
+                        }
+                    }
+                    catch (...) {
+                    }
+                }
+                else {
+                    BOOST_LOG_TRIVIAL(error) << "task_info: get subtask id failed!";
+                }
+            }
+            // this->m_plate_index = plate_index;
+            });
+    }
+}
+
+void MachineObject::get_firmware_info()
+{
+    m_firmware_valid = false;
+    if (m_firmware_thread_started)
+        return;
+
+    boost::thread update_info_thread = Slic3r::create_thread(
+        [&] {
+            m_firmware_thread_started = true;
+            int          result = 0;
+            unsigned int http_code;
+            std::string  http_body;
+            if (!m_agent) return;
+            result = m_agent->get_printer_firmware(get_dev_id(), &http_code, &http_body);
+            if (result < 0) {
+                // get upgrade list failed
+                return;
+            }
+            try {
+                json j = json::parse(http_body);
+                if (j.contains("devices") && !j["devices"].is_null()) {
+                    firmware_list.clear();
+                    for (json::iterator it = j["devices"].begin(); it != j["devices"].end(); it++) {
+                        if ((*it)["dev_id"].get<std::string>() == this->get_dev_id()) {
+                            try {
+                                json firmware = (*it)["firmware"];
+                                for (json::iterator firmware_it = firmware.begin(); firmware_it != firmware.end(); firmware_it++) {
+                                    FirmwareInfo item;
+                                    item.version = (*firmware_it)["version"].get<std::string>();
+                                    item.url = (*firmware_it)["url"].get<std::string>();
+                                    if ((*firmware_it).contains("description"))
+                                        item.description = (*firmware_it)["description"].get<std::string>();
+                                    item.module_type = "ota";
+                                    int name_start = item.url.find_last_of('/') + 1;
+                                    if (name_start > 0) {
+                                        item.name = item.url.substr(name_start, item.url.length() - name_start);
+                                        firmware_list.push_back(item);
+                                    }
+                                    else {
+                                        BOOST_LOG_TRIVIAL(trace) << "skip";
+                                    }
+                                }
+                            }
+                            catch (...) {}
+                            try {
+                                if ((*it).contains("ams")) {
+                                    json ams_list = (*it)["ams"];
+                                    if (ams_list.size() > 0) {
+                                        auto ams_front = ams_list.front();
+                                        json firmware_ams = (ams_front)["firmware"];
+                                        for (json::iterator ams_it = firmware_ams.begin(); ams_it != firmware_ams.end(); ams_it++) {
+                                            FirmwareInfo item;
+                                            item.version = (*ams_it)["version"].get<std::string>();
+                                            item.url = (*ams_it)["url"].get<std::string>();
+                                            if ((*ams_it).contains("description"))
+                                                item.description = (*ams_it)["description"].get<std::string>();
+                                            item.module_type = "ams";
+                                            int name_start = item.url.find_last_of('/') + 1;
+                                            if (name_start > 0) {
+                                                item.name = item.url.substr(name_start, item.url.length() - name_start);
+                                                firmware_list.push_back(item);
+                                            }
+                                            else {
+                                                BOOST_LOG_TRIVIAL(trace) << "skip";
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                            catch (...) {
+                                ;
+                            }
+                        }
+                    }
+                }
+            }
+            catch (...) {
+                return;
+            }
+            m_firmware_thread_started = false;
+            m_firmware_valid = true;
+        }
+    );
+    return;
+}
+
+bool MachineObject::is_firmware_info_valid()
+{
+    return m_firmware_valid;
+}
+
+
+DevAmsTray MachineObject::parse_vt_tray(json vtray)
+{
+    auto vt_tray = DevAmsTray(std::to_string(VIRTUAL_TRAY_MAIN_ID));
+
+    if (vtray.contains("id"))
+        vt_tray.id = vtray["id"].get<std::string>();
+    auto curr_time = std::chrono::system_clock::now();
+    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(curr_time - extrusion_cali_set_hold_start);
+    if (diff.count() > HOLD_TIMEOUT || diff.count() < 0
+        || extrusion_cali_set_tray_id != VIRTUAL_TRAY_MAIN_ID) {
+        if (vtray.contains("k"))
+            vt_tray.k = vtray["k"].get<float>();
+        if (vtray.contains("n"))
+            vt_tray.n = vtray["n"].get<float>();
+    }
+    ams_support_virtual_tray = true;
+
+    if (vt_tray.hold_count > 0) {
+        vt_tray.hold_count--;
+    }
+    else {
+        if (vtray.contains("tag_uid"))
+            vt_tray.tag_uid = vtray["tag_uid"].get<std::string>();
+        else
+            vt_tray.tag_uid = "0";
+        if (vtray.contains("tray_info_idx") && vtray.contains("tray_type")) {
+            vt_tray.setting_id = vtray["tray_info_idx"].get<std::string>();
+            //std::string type = vtray["tray_type"].get<std::string>();
+            std::string type = setting_id_to_type(vt_tray.setting_id, vtray["tray_type"].get<std::string>());
+            if (vt_tray.setting_id == "GFS00") {
+                vt_tray.m_fila_type = "PLA-S";
+            }
+            else if (vt_tray.setting_id == "GFS01") {
+                vt_tray.m_fila_type = "PA-S";
+            }
+            else {
+                vt_tray.m_fila_type = type;
+            }
+        }
+        else {
+            vt_tray.setting_id = "";
+            vt_tray.m_fila_type = "";
+        }
+        if (vtray.contains("tray_sub_brands"))
+            vt_tray.sub_brands = vtray["tray_sub_brands"].get<std::string>();
+        else
+            vt_tray.sub_brands = "";
+        if (vtray.contains("tray_weight"))
+            vt_tray.weight = vtray["tray_weight"].get<std::string>();
+        else
+            vt_tray.weight = "";
+        if (vtray.contains("tray_diameter"))
+            vt_tray.diameter = vtray["tray_diameter"].get<std::string>();
+        else
+            vt_tray.diameter = "";
+        if (vtray.contains("tray_temp"))
+            vt_tray.temp = vtray["tray_temp"].get<std::string>();
+        else
+            vt_tray.temp = "";
+        if (vtray.contains("tray_time"))
+            vt_tray.time = vtray["tray_time"].get<std::string>();
+        else
+            vt_tray.time = "";
+        if (vtray.contains("bed_temp_type"))
+            vt_tray.bed_temp_type = vtray["bed_temp_type"].get<std::string>();
+        else
+            vt_tray.bed_temp_type = "";
+        if (vtray.contains("bed_temp"))
+            vt_tray.bed_temp = vtray["bed_temp"].get<std::string>();
+        else
+            vt_tray.bed_temp = "";
+        if (vtray.contains("tray_color")) {
+            auto color = vtray["tray_color"].get<std::string>();
+            vt_tray.UpdateColorFromStr(color);
+        }
+        else {
+            vt_tray.color = "";
+        }
+        if (vtray.contains("ctype")) {
+            vt_tray.ctype = vtray["ctype"].get<int>();
+        }
+        else {
+            vt_tray.ctype = 1;
+        }
+        if (vtray.contains("nozzle_temp_max"))
+            vt_tray.nozzle_temp_max = vtray["nozzle_temp_max"].get<std::string>();
+        else
+            vt_tray.nozzle_temp_max = "";
+        if (vtray.contains("nozzle_temp_min"))
+            vt_tray.nozzle_temp_min = vtray["nozzle_temp_min"].get<std::string>();
+        else
+            vt_tray.nozzle_temp_min = "";
+        if (vtray.contains("xcam_info"))
+            vt_tray.xcam_info = vtray["xcam_info"].get<std::string>();
+        else
+            vt_tray.xcam_info = "";
+        if (vtray.contains("tray_uuid"))
+            vt_tray.uuid = vtray["tray_uuid"].get<std::string>();
+        else
+            vt_tray.uuid = "0";
+
+        if (vtray.contains("cali_idx"))
+            vt_tray.cali_idx = vtray["cali_idx"].get<int>();
+        else
+            vt_tray.cali_idx = -1;
+        vt_tray.cols.clear();
+        if (vtray.contains("cols")) {
+            if (vtray["cols"].is_array()) {
+                for (auto it = vtray["cols"].begin(); it != vtray["cols"].end(); it++) {
+                    vt_tray.cols.push_back(it.value().get<std::string>());
+                }
+            }
+        } else {
+            vt_tray.cols.push_back(vt_tray.color);
+        }
+
+        if (vtray.contains("remain")) {
+            vt_tray.remain = vtray["remain"].get<int>();
+        }
+        else {
+            vt_tray.remain = -1;
+        }
+    }
+
+    return vt_tray;
+}
+
+bool MachineObject::contains_tray(const std::string &ams_id, const std::string &tray_id) const
+{
+    if (ams_id != VIRTUAL_AMS_MAIN_ID_STR && ams_id != VIRTUAL_AMS_DEPUTY_ID_STR) {
+
+        return m_fila_system->GetAmsTray(ams_id, tray_id) != nullptr;
+    } else {
+        for (const auto& tray : vt_slot) {
+            if (tray.id == ams_id) { return true; }
+        }
+    }
+
+    return false;
+}
+
+/*use contains_tray or is_tray_info_ready to check*/
+DevAmsTray MachineObject::get_tray(const std::string &ams_id, const std::string &tray_id) const
+{
+    if (ams_id.empty() && tray_id.empty()) {
+        return DevAmsTray(tray_id);
+    }
+
+    if (ams_id != VIRTUAL_AMS_MAIN_ID_STR && ams_id != VIRTUAL_AMS_DEPUTY_ID_STR) {
+        auto tray = m_fila_system->GetAmsTray(ams_id, tray_id);
+        if (tray) { return *tray;};
+    }
+    else {
+        for (const auto &tray : vt_slot) {
+            if (tray.id == ams_id) { return tray; }
+        }
+    }
+
+    return DevAmsTray(tray_id);
+}
+
+bool MachineObject::check_enable_np(const json& print) const
+{
+    if (print.contains("cfg") && print.contains("fun") && print.contains("aux") && print.contains("stat"))
+    {
+        return true;
+    }
+
+    return false;
+}
+
+void MachineObject::parse_new_info(json print)
+{
+    is_enable_np = check_enable_np(print);
+    if (!is_enable_np)
+    {
+        return;
+    }
+
+    BOOST_LOG_TRIVIAL(info) << "using new print data for parsing";
+
+    /*cfg*/
+    std::string cfg = print["cfg"].get<std::string>();
+
+    BOOST_LOG_TRIVIAL(info) << "new print data cfg = " << cfg;
+
+    if(!cfg.empty()){
+        if (camera_resolution_hold_count > 0) camera_resolution_hold_count--;
+        if (camera_timelapse_hold_count > 0) camera_timelapse_hold_count--;
+
+
+        if (time(nullptr) - ams_user_setting_start > HOLD_COUNT_MAX)
+        {
+            m_fila_system->GetAmsSystemSetting().SetDetectOnInsertEnabled(get_flag_bits(cfg, 0));
+            m_fila_system->GetAmsSystemSetting().SetDetectOnPowerupEnabled(get_flag_bits(cfg, 1));
+        }
+
+        if (time(nullptr) - camera_recording_ctl_start > HOLD_COUNT_MAX)
+        {
+            camera_recording_when_printing = get_flag_bits(cfg, 3);
+        }
+
+        if (camera_resolution_hold_count > 0)
+        {
+            camera_resolution_hold_count--;
+        }
+        else
+        {
+            camera_resolution = get_flag_bits(cfg, 4) == 0 ? "720p" : "1080p";
+        }
+
+        if (camera_timelapse_hold_count > 0)
+        {
+            camera_timelapse_hold_count--;
+        }
+        else
+        {
+            camera_timelapse = get_flag_bits(cfg, 5);
+        }
+
+        tutk_state = get_flag_bits(cfg, 6) == 1 ? "disable" : "";
+        m_lamp->SetChamberLight(get_flag_bits(cfg, 7) == 1 ? DevLamp::LIGHT_EFFECT_ON : DevLamp::LIGHT_EFFECT_OFF);
+        //is_support_build_plate_marker_detect = get_flag_bits(cfg, 12); todo yangcong
+        if (time(nullptr) - xcam_first_layer_hold_start > HOLD_TIME_3SEC) { xcam_first_layer_inspector = get_flag_bits(cfg, 12); }
+
+        if (time(nullptr) - xcam_ai_monitoring_hold_start > HOLD_COUNT_MAX) {
+            xcam_ai_monitoring = get_flag_bits(cfg, 15);
+
+            switch (get_flag_bits(cfg, 13, 2)) {
+            case 0: xcam_ai_monitoring_sensitivity = "never_halt"; break;
+            case 1: xcam_ai_monitoring_sensitivity = "low"; break;
+            case 2: xcam_ai_monitoring_sensitivity = "medium"; break;
+            case 3: xcam_ai_monitoring_sensitivity = "high"; break;
+            default: break;
+            }
+        }
+
+        if (time(nullptr) - xcam_auto_recovery_hold_start > HOLD_COUNT_MAX) {
+            xcam_auto_recovery_step_loss = get_flag_bits(cfg, 16);
+        }
+
+        if (time(nullptr) - ams_user_setting_start > HOLD_COUNT_MAX){
+            m_fila_system->GetAmsSystemSetting().SetDetectRemainEnabled(get_flag_bits(cfg, 17));
+        }
+
+        if (time(nullptr) - ams_switch_filament_start > HOLD_TIME_3SEC){
+            m_fila_system->GetAmsSystemSetting().SetAutoRefillEnabled(get_flag_bits(cfg, 18));
+        }
+
+        if (time(nullptr) - xcam__save_remote_print_file_to_storage_start_time > HOLD_TIME_3SEC){
+            xcam__save_remote_print_file_to_storage = get_flag_bits(cfg, 19);
+        }
+
+        if (time(nullptr) - xcam_door_open_check_start_time > HOLD_TIME_3SEC){
+            xcam_door_open_check = (DoorOpenCheckState) get_flag_bits(cfg, 20, 2);
+        }
+
+        if (time(nullptr) - xcam_prompt_sound_hold_start > HOLD_TIME_3SEC) {
+            xcam_allow_prompt_sound = get_flag_bits(cfg, 22);
+        }
+
+        if (time(nullptr) - xcam_filament_tangle_detect_hold_start > HOLD_TIME_3SEC){
+            xcam_filament_tangle_detect = get_flag_bits(cfg, 23);
+        }
+
+        if (time(nullptr) - nozzle_blob_detection_hold_start > HOLD_TIME_3SEC) {
+            nozzle_blob_detection_enabled = get_flag_bits(cfg, 24);
+        }
+
+        installed_upgrade_kit = get_flag_bits(cfg, 25);
+
+        DevPrintOptionsParser::ParseDetectionV2_1(m_print_options, cfg);
+    }
+
+    /*fun*/
+    std::string fun = print["fun"].get<std::string>();
+    BOOST_LOG_TRIVIAL(info) << "new print data fun = " << fun;
+
+    if (!fun.empty()) {
+
+        is_support_agora    = get_flag_bits(fun, 1);
+        if (is_support_agora) is_support_tunnel_mqtt = false;
+
+        is_220V_voltage  = get_flag_bits(fun, 2) == 0?false:true;
+        is_support_flow_calibration = get_flag_bits(fun, 6);
+        if (this->is_series_o()) { is_support_flow_calibration = false; } // todo: Temp modification due to incorrect machine push message for H2D
+        is_support_pa_calibration = get_flag_bits(fun, 7);
+        if (this->is_series_p()) { is_support_pa_calibration = false; } // todo: Temp modification due to incorrect machine push message for P
+        is_support_prompt_sound = get_flag_bits(fun, 8);
+        is_support_filament_tangle_detect = get_flag_bits(fun, 9);
+        is_support_motor_noise_cali = get_flag_bits(fun, 10);
+        is_support_user_preset = get_flag_bits(fun, 11);
+        is_support_door_open_check = get_flag_bits(fun, 12);
+        is_support_nozzle_blob_detection = get_flag_bits(fun, 13);
+        is_support_upgrade_kit = get_flag_bits(fun, 14);
+        is_support_internal_timelapse = get_flag_bits(fun, 28);
+        is_support_brtc = get_flag_bits(fun, 31);
+        m_support_mqtt_bet_ctrl = get_flag_bits(fun, 39);
+        is_support_new_auto_cali_method = get_flag_bits(fun, 40);
+        is_support_spaghetti_detection = get_flag_bits(fun, 42);
+        is_support_purgechutepileup_detection = get_flag_bits(fun, 43);
+        is_support_nozzleclumping_detection = get_flag_bits(fun, 44);
+        is_support_airprinting_detection = get_flag_bits(fun, 45);
+        m_fan->SetSupportCoolingFilter(get_flag_bits(fun, 46));
+        is_support_ext_change_assist = get_flag_bits(fun, 48);
+        is_support_partskip = get_flag_bits(fun, 49);
+        is_support_idelheadingprotect_detection = get_flag_bits(fun, 62);
+        m_nozzle_system->SetSupportNozzleRack(get_flag_bits(fun, 60));
+    }
+
+    /*fun2*/
+    std::string fun2;
+    if (print.contains("fun2") && print["fun2"].is_string()) {
+        fun2 = print["fun2"].get<std::string>();
+        BOOST_LOG_TRIVIAL(info) << "new print data fun2 = " << fun2;
+    }
+
+    // fun2 may have infinite length, use get_flag_bits_no_border
+    if (!fun2.empty()) {
+        is_support_print_with_emmc = get_flag_bits_no_border(fun2, 0) == 1;
+        is_support_build_plate_align_detect = get_flag_bits_no_border(fun2, 2) == 1;
+        is_support_pa_mode = (get_flag_bits_no_border(fun2, 3) == 1);
+    }
+
+    /*aux*/
+    std::string aux = print["aux"].get<std::string>();
+
+    BOOST_LOG_TRIVIAL(info) << "new print data aux = " << aux;
+
+    if (!aux.empty()) {
+        m_storage->set_sdcard_state(get_flag_bits(aux, 12, 2));
+    }
+
+    /*stat*/
+    std::string stat = print["stat"].get<std::string>();
+
+    BOOST_LOG_TRIVIAL(info) << "new print data stat = " << stat;
+
+    if (!stat.empty()) {
+        camera_recording = get_flag_bits(stat, 7);
+        m_lamp->SetLampCloseRecheck((get_flag_bits(stat, 36) == 1));
+    }
+
+    m_dev_info->ParseInfo(print);
+
+    /*device*/
+    if (print.contains("device")) {
+        json const& device = print["device"];
+
+        //new fan data
+        m_fan->ParseV3_0(device);
+
+        DevBed::ParseV2_0(device, m_bed);
+        DevNozzleSystemParser::ParseV2_0(device, m_nozzle_system);
+
+        if (device.contains("extruder")) { ExtderSystemParser::ParseV2_0(device["extruder"], m_extder_system);}
+        if (device.contains("ext_tool")) { DevExtensionToolParser::ParseV2_0(device["ext_tool"], m_extension_tool); }
+    }
+}
+
+static bool is_hex_digit(char c) {
+    return std::isxdigit(static_cast<unsigned char>(c)) != 0;
+}
+
+int MachineObject::get_flag_bits(std::string str, int start, int count) const
+{
+    try {
+        unsigned long long decimal_value = std::stoull(str, nullptr, 16);
+        unsigned long long mask = (1ULL << count) - 1;
+        int flag = (decimal_value >> start) & mask;
+        return flag;
+    }
+    catch (...) {
+        return 0;
+    }
+}
+
+uint32_t MachineObject::get_flag_bits_no_border(std::string str, int start_idx, int count) const
+{
+    if (start_idx < 0 || count <= 0) return 0;
+
+    try {
+        // --- 1) trim ---
+        auto ltrim = [](std::string& s) {
+            s.erase(s.begin(), std::find_if(s.begin(), s.end(),
+                [](unsigned char ch) { return !std::isspace(ch); }));
+            };
+        auto rtrim = [](std::string& s) {
+            s.erase(std::find_if(s.rbegin(), s.rend(),
+                [](unsigned char ch) { return !std::isspace(ch); }).base(), s.end());
+            };
+        ltrim(str); rtrim(str);
+
+        // --- 2) remove 0x/0X prefix ---
+        if (str.size() >= 2 && str[0] == '0' && (str[1] == 'x' || str[1] == 'X')) {
+            str.erase(0, 2);
+        }
+
+        // --- 3) keep only hex digits ---
+        std::string hex;
+        hex.reserve(str.size());
+        for (char c : str) {
+            if (std::isxdigit(static_cast<unsigned char>(c))) hex.push_back(c);
+        }
+        if (hex.empty()) return 0;
+
+        // --- 4) use size_t for all index/bit math ---
+        const size_t total_bits = hex.size() * 4ULL;
+
+        const size_t ustart = static_cast<size_t>(start_idx);
+        if (ustart >= total_bits) return 0;
+
+        const int int_bits = std::numeric_limits<uint32_t>::digits; // typically 32
+        const size_t need_bits = static_cast<size_t>(std::min(count, int_bits));
+
+        // [first_bit, last_bit]
+        const size_t first_bit = ustart;
+        const size_t last_bit = std::min(ustart + need_bits, total_bits) - 1ULL;
+        if (last_bit < first_bit) return 0;
+
+
+        const size_t right_index = hex.size() - 1ULL;
+
+        const size_t first_nibble = first_bit / 4ULL;
+        const size_t last_nibble = last_bit / 4ULL;
+
+        const size_t start_idx = right_index - last_nibble;
+        const size_t end_idx = right_index - first_nibble;
+        if (end_idx < start_idx) return 0;
+
+        const size_t sub_len = end_idx - start_idx + 1ULL;
+        if (end_idx >= hex.size()) return 0;
+
+        const std::string sub_hex = hex.substr(start_idx, sub_len);
+
+        unsigned long long chunk = std::stoull(sub_hex, nullptr, 16);
+
+        const unsigned nibble_offset = static_cast<unsigned>(first_bit % 4ULL);
+        const unsigned long long shifted =
+            (nibble_offset == 0U) ? chunk : (chunk >> nibble_offset);
+
+        uint32_t mask;
+        if (need_bits >= static_cast<size_t>(std::numeric_limits<uint32_t>::digits)) {
+            mask = std::numeric_limits<uint32_t>::max();
+        }
+        else {
+            mask = static_cast<uint32_t>((1ULL << need_bits) - 1ULL);
+        }
+
+        const uint32_t val = static_cast<uint32_t>(shifted & mask);
+        return val;
+    }
+    catch (const std::invalid_argument&) {
+        return 0;
+    }
+    catch (const std::out_of_range&) {
+        return 0;
+    }
+    catch (...) {
+        return 0;
+    }
+}
+
+int MachineObject::get_flag_bits(int num, int start, int count, int base) const
+{
+    try {
+        unsigned long long mask = (1ULL << count) - 1;
+        unsigned long long value;
+        if (base == 10) {
+            value = static_cast<unsigned long long>(num);
+        } else if (base == 16) {
+            value = static_cast<unsigned long long>(std::stoul(std::to_string(num), nullptr, 16));
+        } else {
+            throw std::invalid_argument("Unsupported base");
+        }
+
+        int flag = (value >> start) & mask;
+        return flag;
+    } catch (...) {
+        return 0;
+    }
+}
+
+void MachineObject::update_filament_list()
+{
+    PresetBundle *preset_bundle = Slic3r::GUI::wxGetApp().preset_bundle;
+
+    // custom filament
+    typedef std::map<std::string, std::pair<int, int>> map_pair;
+    std::map<std::string, map_pair>                    map_list;
+    for (auto &pair : m_nozzle_filament_data) {
+        map_list[pair.second.printer_preset_name] = map_pair{};
+    }
+    for (auto &preset : preset_bundle->filaments()) {
+        if (preset.is_user() && preset.inherits() == "") {
+            ConfigOption *       printer_opt  = const_cast<Preset &>(preset).config.option("compatible_printers");
+            ConfigOptionStrings *printer_strs = dynamic_cast<ConfigOptionStrings *>(printer_opt);
+            for (const std::string &printer_str : printer_strs->values) {
+                if (map_list.find(printer_str) != map_list.end()) {
+                    auto &        filament_list = map_list[printer_str];
+                    ConfigOption *opt_min  = const_cast<Preset &>(preset).config.option("nozzle_temperature_range_low");
+                    int           min_temp = -1;
+                    if (opt_min) {
+                        ConfigOptionInts *opt_min_ints = dynamic_cast<ConfigOptionInts *>(opt_min);
+                        min_temp                       = opt_min_ints->get_at(0);
+                    }
+                    ConfigOption *opt_max  = const_cast<Preset &>(preset).config.option("nozzle_temperature_range_high");
+                    int           max_temp = -1;
+                    if (opt_max) {
+                        ConfigOptionInts *opt_max_ints = dynamic_cast<ConfigOptionInts *>(opt_max);
+                        max_temp                       = opt_max_ints->get_at(0);
+                    }
+                    filament_list[preset.filament_id] = std::make_pair(min_temp, max_temp);
+                    break;
+                }
+            }
+        }
+    }
+
+    for (auto& pair : m_nozzle_filament_data) {
+        auto & m_printer_preset_name = pair.second.printer_preset_name;
+        auto & m_filament_list       = pair.second.filament_list;
+        auto & m_checked_filament    = pair.second.checked_filament;
+        auto & filament_list         = map_list[m_printer_preset_name];
+
+        for (auto it = filament_list.begin(); it != filament_list.end(); it++) {
+            if (m_filament_list.find(it->first) != m_filament_list.end()) {
+                assert(it->first.size() == 8 && it->first[0] == 'P');
+
+                if (it->second.first != m_filament_list[it->first].first) {
+                    BOOST_LOG_TRIVIAL(info) << "old min temp is not equal to new min temp and filament id: " << it->first;
+                    continue;
+                }
+
+                if (it->second.second != m_filament_list[it->first].second) {
+                    BOOST_LOG_TRIVIAL(info) << "old max temp is not equal to new max temp and filament id: " << it->first;
+                    continue;
+                }
+
+                m_filament_list.erase(it->first);
+            }
+        }
+
+        for (auto it = m_filament_list.begin(); it != m_filament_list.end(); it++) { m_checked_filament.insert(it->first); }
+
+        m_filament_list = filament_list;
+    }
+}
+
+void MachineObject::update_printer_preset_name()
+{
+    BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " " << __LINE__ << "start update preset_name";
+    PresetBundle *     preset_bundle = Slic3r::GUI::wxGetApp().preset_bundle;
+    if (!preset_bundle) return;
+    auto               printer_model = DevPrinterConfigUtil::get_printer_display_name(this->printer_type);
+    std::set<std::string> diameter_set;
+    for (auto &nozzle : m_extder_system->m_extders) {
+        float diameter = nozzle.GetNozzleDiameter();
+        std::ostringstream stream;
+        stream << std::fixed << std::setprecision(1) << diameter;
+        std::string nozzle_diameter_str = stream.str();
+        diameter_set.insert(nozzle_diameter_str);
+        if (m_nozzle_filament_data.find(nozzle_diameter_str) != m_nozzle_filament_data.end()) continue;
+        auto data = FilamentData();
+        auto printer_set = preset_bundle->get_printer_names_by_printer_type_and_nozzle(printer_model, nozzle_diameter_str);
+        if (printer_set.size() > 0) {
+            data.printer_preset_name = *printer_set.begin();
+            m_nozzle_filament_data[nozzle_diameter_str] = data;
+        }
+        else
+            BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " " << __LINE__ << " update printer preset name failed: "<< "printer_type: " << printer_type << "nozzle_diameter_str" << nozzle_diameter_str;
+    }
+
+    for (auto iter = m_nozzle_filament_data.begin(); iter != m_nozzle_filament_data.end();)
+    {
+        if (diameter_set.find(iter->first) == diameter_set.end())
+        {
+            iter = m_nozzle_filament_data.erase(iter);
+        }
+        else
+        {
+            ++iter;
+        }
+    }
+}
+
+void MachineObject::check_ams_filament_valid()
+{
+    PresetBundle * preset_bundle = Slic3r::GUI::wxGetApp().preset_bundle;
+    auto printer_model = DevPrinterConfigUtil::get_printer_display_name(this->printer_type);
+    std::map<std::string, std::set<std::string>> need_checked_filament_id;
+    for (auto &ams_pair : m_fila_system->GetAmsList()) {
+        auto ams_id = ams_pair.first;
+        auto &ams = ams_pair.second;
+        std::ostringstream stream;
+        if (ams->GetExtruderId() < 0 || ams->GetExtruderId() >= m_extder_system->GetTotalExtderCount()) {
+            return;
+        }
+        stream << std::fixed << std::setprecision(1) << m_extder_system->GetNozzleDiameter(ams->GetExtruderId());
+        std::string nozzle_diameter_str = stream.str();
+        assert(nozzle_diameter_str.size() == 3);
+        if (m_nozzle_filament_data.find(nozzle_diameter_str) == m_nozzle_filament_data.end()) {
+            //assert(false);
+            continue;
+        }
+        auto &data = m_nozzle_filament_data[nozzle_diameter_str];
+        auto &filament_list = data.filament_list;
+        auto &checked_filament = data.checked_filament;
+        for (const auto &[slot_id, curr_tray] : ams->GetTrays()) {
+
+            if (curr_tray->setting_id.size() == 8 && curr_tray->setting_id[0] == 'P' && filament_list.find(curr_tray->setting_id) == filament_list.end()) {
+                if (checked_filament.find(curr_tray->setting_id) != checked_filament.end()) {
+                    need_checked_filament_id[nozzle_diameter_str].insert(curr_tray->setting_id);
+                    wxColour color = *wxWHITE;
+                    char     col_buf[10];
+                    sprintf(col_buf, "%02X%02X%02XFF", (int) color.Red(), (int) color.Green(), (int) color.Blue());
+                    try {
+                        BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " " << __LINE__ << " ams settings_id is not exist in filament_list and reset, ams_id: " << ams_id << " tray_id"
+                                                << slot_id << "filament_id: " << curr_tray->setting_id;
+
+                        command_ams_filament_settings(std::stoi(ams_id), std::stoi(slot_id), "", "", std::string(col_buf), "", 0, 0);
+                        continue;
+                    } catch (...) {
+                        BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " " << __LINE__ << " stoi error and ams_id: " << ams_id << " tray_id" << slot_id;
+                    }
+                }
+            }
+            if (curr_tray->setting_id.size() == 8 && curr_tray->setting_id[0] == 'P' && curr_tray->nozzle_temp_min != "" && curr_tray->nozzle_temp_max != "") {
+                if (checked_filament.find(curr_tray->setting_id) != checked_filament.end()) {
+                    need_checked_filament_id[nozzle_diameter_str].insert(curr_tray->setting_id);
+                    try {
+                        std::string preset_setting_id;
+                        bool        is_equation = preset_bundle->check_filament_temp_equation_by_printer_type_and_nozzle_for_mas_tray(printer_model, nozzle_diameter_str,
+                                                                                                                               curr_tray->setting_id, curr_tray->tag_uid,
+                                                                                                                               curr_tray->nozzle_temp_min,
+                                                                                                                               curr_tray->nozzle_temp_max, preset_setting_id);
+                        if (!is_equation) {
+                            BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " " << __LINE__ << " ams filament is not match min max temp and reset, ams_id: " << ams_id << " tray_id"
+                                                    << slot_id << "filament_id: " << curr_tray->setting_id;
+
+
+                            command_ams_filament_settings(std::stoi(ams_id), std::stoi(slot_id), curr_tray->setting_id, preset_setting_id, curr_tray->color, curr_tray->m_fila_type,
+                                                          std::stoi(curr_tray->nozzle_temp_min), std::stoi(curr_tray->nozzle_temp_max));
+                        }
+                        continue;
+                    } catch (...) {
+                        BOOST_LOG_TRIVIAL(info) << "check fail and curr_tray ams_id" << ams_id << " curr_tray tray_id" << slot_id;
+                    }
+                }
+            }
+        }
+    }
+
+    for (auto vt_tray : vt_slot) {
+        int vt_id = std::stoi(vt_tray.id);
+        int index = 255 - vt_id;
+        if (index >= m_extder_system->GetTotalExtderCount()) {
+            BOOST_LOG_TRIVIAL(error) << " vt_tray id map for nozzle id is not exist, index is: " << index << " nozzle count" << m_extder_system->GetTotalExtderCount();
+            continue;
+        }
+        auto diameter = m_extder_system->GetNozzleDiameter(index);
+        std::ostringstream stream;
+        stream << std::fixed << std::setprecision(1) << diameter;
+        std::string nozzle_diameter_str = stream.str();
+        if (m_nozzle_filament_data.find(nozzle_diameter_str) == m_nozzle_filament_data.end()) {
+            continue;
+        }
+        auto &data = m_nozzle_filament_data[nozzle_diameter_str];
+        auto &checked_filament = data.checked_filament;
+        auto &filament_list    = data.filament_list;
+        if (vt_tray.setting_id.size() == 8 && vt_tray.setting_id[0] == 'P' && filament_list.find(vt_tray.setting_id) == filament_list.end()) {
+            if (checked_filament.find(vt_tray.setting_id) != checked_filament.end()) {
+                need_checked_filament_id[nozzle_diameter_str].insert(vt_tray.setting_id);
+                wxColour color = *wxWHITE;
+                char     col_buf[10];
+                sprintf(col_buf, "%02X%02X%02XFF", (int) color.Red(), (int) color.Green(), (int) color.Blue());
+                try {
+                    BOOST_LOG_TRIVIAL(info) << "vt_tray.setting_id is not exist in filament_list and reset vt_tray and the filament_id is: " << vt_tray.setting_id;
+                    command_ams_filament_settings(vt_id, 0, "", "", std::string(col_buf), "", 0, 0);
+                    continue;
+                } catch (...) {
+                    BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " " << __LINE__ << " stoi error and tray_id" << vt_tray.id;
+                }
+            }
+        }
+        if (vt_tray.setting_id.size() == 8 && vt_tray.setting_id[0] == 'P' && vt_tray.nozzle_temp_min != "" && vt_tray.nozzle_temp_max != "") {
+            if (checked_filament.find(vt_tray.setting_id) != checked_filament.end()) {
+                need_checked_filament_id[nozzle_diameter_str].insert(vt_tray.setting_id);
+                try {
+                    std::string        preset_setting_id;
+                    PresetBundle *     preset_bundle = Slic3r::GUI::wxGetApp().preset_bundle;
+                    std::ostringstream stream;
+                    stream << std::fixed << std::setprecision(1) << m_extder_system->GetNozzleDiameter(MAIN_EXTRUDER_ID);
+                    std::string nozzle_diameter_str = stream.str();
+                    bool        is_equation = preset_bundle->check_filament_temp_equation_by_printer_type_and_nozzle_for_mas_tray(DevPrinterConfigUtil::get_printer_display_name(
+                                                                                                                               this->printer_type),
+                                                                                                                           nozzle_diameter_str, vt_tray.setting_id,
+                                                                                                                           vt_tray.tag_uid, vt_tray.nozzle_temp_min,
+                                                                                                                           vt_tray.nozzle_temp_max, preset_setting_id);
+                    if (!is_equation) {
+                        BOOST_LOG_TRIVIAL(info) << __FUNCTION__ << " " << __LINE__
+                                                << " vt_tray filament is not match min max temp and reset, filament_id: " << vt_tray.setting_id;
+                        command_ams_filament_settings(vt_id, 0, vt_tray.setting_id, preset_setting_id, vt_tray.color, vt_tray.m_fila_type, std::stoi(vt_tray.nozzle_temp_min),
+                                                          std::stoi(vt_tray.nozzle_temp_max));
+
+                    }
+                } catch (...) {
+                    BOOST_LOG_TRIVIAL(info) << "check fail and vt_tray.id" << vt_tray.id;
+                }
+            }
+        }
+    }
+
+    for (auto &diameter_pair : m_nozzle_filament_data) {
+        auto &diameter = diameter_pair.first;
+        auto &data     = diameter_pair.second;
+        for (auto &filament_id : need_checked_filament_id[diameter]) {
+            data.checked_filament.erase(filament_id);
+        }
+    }
+}
+
+
+void MachineObject::command_set_door_open_check(DoorOpenCheckState state)
+{
+    json j;
+    j["system"]["command"]       = "set_door_stat";
+    j["system"]["sequence_id"]   = std::to_string(MachineObject::m_sequence_id++);
+    switch (state)
+    {
+         case Slic3r::MachineObject::DOOR_OPEN_CHECK_DISABLE:            j["system"]["config"] = 0; break;
+         case Slic3r::MachineObject::DOOR_OPEN_CHECK_ENABLE_WARNING:     j["system"]["config"] = 1; break;
+         case Slic3r::MachineObject::DOOR_OPEN_CHECK_ENABLE_PAUSE_PRINT: j["system"]["config"] = 2; break;
+         default: assert(0); return;
+    }
+
+    if (publish_json(j) == 0)
+    {
+        xcam_door_open_check = state;
+        xcam_door_open_check_start_time = time(nullptr);
+    }
+}
+
+
+void MachineObject::command_set_save_remote_print_file_to_storage(bool save)
+{
+    if (get_save_remote_print_file_to_storage() != save)
+    {
+        json j;
+        j["system"]["command"] = "print_cache_set";
+        j["system"]["sequence_id"] = std::to_string(MachineObject::m_sequence_id++);
+        j["system"]["config"] = save ? true : false;
+
+        if (publish_json(j) == 0)
+        {
+            xcam__save_remote_print_file_to_storage = save;
+            xcam__save_remote_print_file_to_storage_start_time = time(nullptr);
+        }
+    }
+}
+
+wxString MachineObject::get_nozzle_replace_url() const
+{
+    const wxString& strLanguage = GUI::wxGetApp().app_config->get("language");
+    const wxString& lan_code = strLanguage.BeforeFirst('_');
+
+    const json& link_map = DevPrinterConfigUtil::get_json_from_config(printer_type, "print", "nozzle_replace_wiki");
+    if (link_map.contains(lan_code.ToStdString())) {
+        return link_map[lan_code.ToStdString()].get<wxString>();
+    }
+
+    if (link_map.contains("en")){
+        return link_map["en"].get<wxString>();
+    }/*retry with en*/
+
+    return "https://wiki.bambulab.com/en/h2/maintenance/replace-hotend";
+}
+
+std::string MachineObject::get_error_code_str(int error_code)
+{
+    if (error_code < 0) { return std::string();}
+
+    char buf[32];
+    ::sprintf(buf, "%08X", error_code);
+    std::string print_error_str = std::string(buf);
+    if (print_error_str.size() > 4) { print_error_str.insert(4, "-"); }
+    return print_error_str;
+}
+
+void MachineObject::add_command_error_code_dlg(int command_err, json action_json)
+{
+    BOOST_LOG_TRIVIAL(error) << __FUNCTION__  << command_err;
+    if (command_err > 0 && !Slic3r::GUI::wxGetApp().get_hms_query()->is_internal_error(this, command_err))
+    {
+        GUI::wxGetApp().CallAfter([this, command_err, action_json, token = std::weak_ptr<int>(m_token)]
+        {
+            if (token.expired()) { return;}
+            GUI::DeviceErrorDialog* device_error_dialog = new GUI::DeviceErrorDialog(this, (wxWindow*)GUI::wxGetApp().mainframe);
+            device_error_dialog->Bind(wxEVT_DESTROY, [this, token = std::weak_ptr<int>(m_token)](auto& event)
+                {
+                    if (!token.expired()) { m_command_error_code_dlgs.erase((GUI::DeviceErrorDialog*)event.GetEventObject());}
+                    event.Skip();
+                });
+
+            if(!action_json.is_null()) device_error_dialog->set_action_json(action_json);
+            device_error_dialog->show_error_code(command_err);
+            m_command_error_code_dlgs.insert(device_error_dialog);
+        });
+    };
+}
+
+bool MachineObject::is_multi_extruders() const
+{
+    return m_extder_system->GetTotalExtderCount() > 1;
+}
+
+int MachineObject::get_extruder_id_by_ams_id(const std::string& ams_id)
+{
+    return m_fila_system->GetExtruderIdByAmsId(ams_id);
+}
+
+DevNozzle MachineObject::get_nozzle_by_id_code(int id_code) const
+{
+    /* toolhead nozzle*/
+    if (id_code == MAIN_EXTRUDER_ID || id_code == DEPUTY_EXTRUDER_ID) {
+        int nozzle_id = m_extder_system->GetExtderById(id_code)->GetNozzleId();
+        return m_nozzle_system->GetExtNozzle(nozzle_id);
+    } else if (id_code >= 0x10) {
+        /* rack nozzle*/
+        auto rack       = m_nozzle_system->GetNozzleRack();
+        auto nozzle_map = rack->GetRackNozzles();
+        return nozzle_map[id_code - 0x10];
+    } else {
+        BOOST_LOG_TRIVIAL(error) << "Invalid nozzle pos id: " << id_code << ", replace with main extuder nozzle";
+        return m_nozzle_system->GetExtNozzle(0);
+    }
+}
+
+DevNozzle MachineObject::get_nozzle_by_sn(const std::string& sn) const
+{
+    int nozzle_id;
+    DevNozzle nozzle;
+
+    nozzle_id = m_extder_system->GetExtderById(MAIN_EXTRUDER_ID)->GetNozzleId();
+    nozzle = m_nozzle_system->GetExtNozzle(nozzle_id);
+    if(nozzle.GetSerialNumber().compare(sn) == 0)
+        return nozzle;
+
+    nozzle_id = m_extder_system->GetExtderById(DEPUTY_EXTRUDER_ID)->GetNozzleId();
+    nozzle = m_nozzle_system->GetExtNozzle(nozzle_id);
+    if(nozzle.GetSerialNumber().compare(sn) == 0)
+        return nozzle;
+
+    auto rack = m_nozzle_system->GetNozzleRack();
+    auto nozzle_map = rack->GetRackNozzles();
+    for(auto& rack_nozzle : nozzle_map){
+        if(rack_nozzle.second.GetSerialNumber().compare(sn) == 0)
+            return rack_nozzle.second;
+    }
+    return nozzle;
+}
+
+Slic3r::DevPrintingSpeedLevel MachineObject::GetPrintingSpeedLevel() const
+{
+    return m_print_options->GetPrintingSpeedLevel();
+}
+
+bool MachineObject::is_target_slot_unload() const
+{
+    return m_extder_system->GetTargetSlotId().compare("255") == 0;
+}
+
+Slic3r::DevAms* MachineObject::get_curr_Ams()
+{
+    return m_fila_system->GetAmsById(m_extder_system->GetCurrentAmsId());
+}
+
+Slic3r::DevAmsTray* MachineObject::get_ams_tray(std::string ams_id, std::string tray_id)
+{
+    return m_fila_system->GetAmsTray(ams_id, tray_id);
+}
+
+bool MachineObject::HasAms() const
+{
+    return m_fila_system->HasAms();
+}
+
+std::optional<bool> MachineObject::IsDetectOnInsertEnabled() const
+{
+    return m_fila_system->GetAmsSystemSetting().IsDetectOnInsertEnabled();
+}
+
+std::shared_ptr<Slic3r::DevNozzleRack> MachineObject::GetNozzleRack() const
+{
+    return m_nozzle_system->GetNozzleRack();
+}
+
+std::string MachineObject::get_dev_id() const {
+    return m_dev_info->GetDevId();
+}
+
+void MachineObject::set_dev_id(std::string val) {
+    m_dev_info->SetDevId(val);
+}
+
+void change_the_opacity(wxColour& colour)
+{
+    if (colour.Alpha() == 255) {
+        colour = wxColour(colour.Red(), colour.Green(), colour.Blue(), 254);
+    }
+}
+
+} // namespace Slic3r
diff --git a/src/slic3r/GUI/DeviceManager.hpp b/src/slic3r/GUI/DeviceManager.hpp
new file mode 100644
index 0000000..e1a7b73
--- /dev/null
+++ b/src/slic3r/GUI/DeviceManager.hpp
@@ -0,0 +1,901 @@
+#ifndef slic3r_DeviceManager_hpp_
+#define slic3r_DeviceManager_hpp_
+
+#include <map>
+#include <mutex>
+#include <vector>
+#include <string>
+#include <memory>
+#include <chrono>
+#include <unordered_set>
+#include <boost/thread.hpp>
+#include <boost/nowide/fstream.hpp>
+#include "nlohmann/json.hpp"
+#include "libslic3r/ProjectTask.hpp"
+#include "slic3r/Utils/json_diff.hpp"
+#include "boost/bimap/bimap.hpp"
+#include "CameraPopup.hpp"
+#include "libslic3r/Calib.hpp"
+#include "libslic3r/Utils.hpp"
+
+#include "DeviceCore/DevDefs.h"
+#include "DeviceCore/DevConfigUtil.h"
+#include "DeviceCore/DevFirmware.h"
+#include "DeviceCore/DevUtil.h"
+
+#include "DeviceErrorDialog.hpp"
+
+#include <wx/object.h>
+
+#define USE_LOCAL_SOCKET_BIND 0
+
+#define DISCONNECT_TIMEOUT      30000.f     // milliseconds
+#define PUSHINFO_TIMEOUT        15000.f     // milliseconds
+#define TIMEOUT_FOR_STRAT       20000.f     // milliseconds
+#define TIMEOUT_FOR_KEEPALIVE   5* 60 * 1000.f     // milliseconds
+#define REQUEST_PUSH_MIN_TIME   3000.f     // milliseconds
+#define REQUEST_START_MIN_TIME  15000.f     // milliseconds
+#define EXTRUSION_OMIT_TIME     20000.f     // milliseconds
+#define HOLD_TIMEOUT            10000.f     // milliseconds
+
+#define BED_TEMP_LIMIT          120
+
+#define HOLD_COUNT_MAX          3
+#define HOLD_COUNT_CAMERA       6
+
+#define HOLD_TIME_3SEC     3 // 3 seconds
+#define HOLD_TIME_6SEC     6 // 6 seconds
+
+#define GET_VERSION_RETRYS      10
+#define RETRY_INTERNAL          2000
+
+#define SUBSCRIBE_RETRY_COUNT   5
+
+using namespace nlohmann;
+namespace Slic3r {
+class Print;
+
+namespace GUI
+{
+class DeviceErrorDialog; // Previous definitions
+class Plater;
+}
+
+class NetworkAgent;
+enum ManualPaCaliMethod {
+    PA_LINE = 0,
+    PA_PATTERN,
+};
+
+// Previous definitions
+class DevAms;
+class DevAmsTray;
+class DevAxis;
+class DevBed;
+class DevChamber;
+class DevConfig;
+class DevCtrl;
+class DevExtensionTool;
+class DevExtderSystem;
+class DevFan;
+class DevFilaSystem;
+class DevPrintOptions;
+class DevHMS;
+class DevInfo;
+class DevLamp;
+class DevNozzleSystem;
+class DevNozzleRack;
+class DeviceManager;
+class DevStorage;
+class DevUpgrade;
+struct DevPrintTaskRatingInfo;
+struct DevNozzle;
+
+
+class MachineObject
+{
+private:
+    NetworkAgent *    m_agent{nullptr};
+    DeviceManager*    m_manager{ nullptr };
+    std::shared_ptr<int> m_token = std::make_shared<int>(1);
+
+    /* properties */
+    std::string dev_name;
+    std::string dev_ip;
+    std::string access_code;
+    std::string user_access_code;
+    std::shared_ptr<DevInfo>  m_dev_info;
+
+    // type, time stamp, delay
+    std::vector<std::tuple<std::string, uint64_t, uint64_t>> message_delay;
+
+    // the latest nozzle mapping
+    DevNozzleMappingResult m_auto_nozzle_mapping;
+
+    /*parts*/
+    std::shared_ptr<DevAxis>    m_axis;
+    std::shared_ptr<DevChamber> m_chamber;
+    DevLamp*          m_lamp;
+    std::shared_ptr<DevExtensionTool> m_extension_tool;
+    DevExtderSystem*  m_extder_system;
+    DevNozzleSystem*  m_nozzle_system;
+    DevFilaSystem*    m_fila_system;
+    DevFan*           m_fan;
+    DevBed *          m_bed;
+    DevStorage*       m_storage;
+
+    /*Ctrl*/
+    DevCtrl* m_ctrl;
+
+    /*Print Options/Speed*/
+    DevPrintOptions* m_print_options;
+
+    /*Upgrade*/
+    std::shared_ptr<DevUpgrade> m_upgrade;
+
+    /*HMS*/
+    DevHMS* m_hms_system;
+
+    /*Config*/
+    DevConfig* m_config;
+
+public:
+    MachineObject(DeviceManager* manager, NetworkAgent* agent, std::string name, std::string id, std::string ip);
+    ~MachineObject();
+
+public:
+    enum ActiveState {
+        NotActive,
+        Active,
+        UpdateToDate
+    };
+
+    enum PrintOption {
+        PRINT_OP_AUTO_RECOVERY = 0,
+        PRINT_OP_MAX,
+    };
+
+public:
+
+    /* static members and functions */
+    static inline int m_sequence_id = STUDIO_START_SEQ_ID;
+
+    /* properties */
+    std::string get_dev_name() const { return dev_name; }
+    void set_dev_name(std::string val) { dev_name = val; }
+
+    std::string get_dev_ip() const { return dev_ip; }
+    void set_dev_ip(std::string ip) { dev_ip = ip;  }
+
+    std::string get_dev_id() const;
+    void set_dev_id(std::string val);
+
+    std::string connection_type() const;
+    bool        is_lan_mode_printer() const;
+    bool        is_cloud_mode_printer() const;
+
+    bool        local_use_ssl_for_mqtt { true };
+    bool        local_use_ssl_for_ftp { true };
+    std::string get_ftp_folder();
+
+    int         subscribe_counter{3};
+    std::string dev_connection_name;    /* lan | eth */
+
+    /* message time*/
+    std::chrono::system_clock::time_point last_cloud_msg_time_;
+    std::chrono::system_clock::time_point last_lan_msg_time_;
+
+    bool HasRecentCloudMessage();
+    bool HasRecentLanMessage();
+
+    /*access code*/
+    bool has_access_right() const { return !get_access_code().empty(); }
+    std::string get_access_code() const;
+    void set_access_code(std::string code, bool only_refresh = true);
+
+    /*user access code*/
+    void set_user_access_code(std::string code, bool only_refresh = true);
+    void erase_user_access_code();
+    std::string get_user_access_code() const;
+
+    /*local device nickname - for LAN devices*/
+    void set_local_dev_nickname(std::string name);
+    std::string get_local_dev_nickname() const;
+    bool has_local_dev_nickname() const;
+
+    //PRINTER_TYPE printer_type = PRINTER_3DPrinter_UKNOWN;
+    std::string printer_type;       /* model_id */
+    std::string   get_show_printer_type() const;
+    PrinterSeries get_printer_series() const;
+    PrinterArch get_printer_arch() const;
+    std::string get_printer_ams_type() const;
+    wxString get_printer_type_display_str() const;
+    std::string get_auto_pa_cali_thumbnail_img_str() const;
+
+    // check printer device series
+    std::string get_printer_series_str() const;
+
+    static bool is_series_n(const std::string& series_str);
+    static bool is_series_p(const std::string& series_str);
+    static bool is_series_x(const std::string& series_str);
+    static bool is_series_o(const std::string& series_str);
+
+    bool is_series_n() const;
+    bool is_series_p() const;
+    bool is_series_x() const;
+    bool is_series_o() const;
+
+    void reload_printer_settings();
+    std::string get_printer_thumbnail_img_str() const;
+
+    std::string bind_user_name;
+    std::string bind_user_id;
+    std::string bind_sec_link;
+    std::string bind_ssdp_version;
+    std::string bind_state;     /* free | occupied */
+    bool is_avaliable() { return bind_state == "free"; }
+
+    bool m_is_online;
+    bool m_set_ctt_dlg{ false };
+    void set_ctt_dlg( wxString text);
+    int  parse_msg_count = 0;
+    int  keep_alive_count = 0;
+    std::chrono::system_clock::time_point   last_update_time;   /* last received print data from machine */
+    std::chrono::system_clock::time_point   last_utc_time;   /* last received print data from machine */
+    std::chrono::system_clock::time_point   last_keep_alive;    /* last received print data from machine */
+    std::chrono::system_clock::time_point   last_push_time;     /* last received print push from machine */
+    std::chrono::system_clock::time_point   last_request_push;  /* last received print push from machine */
+    std::chrono::system_clock::time_point   last_request_start; /* last received print push from machine */
+
+    bool device_cert_installed = false;
+
+    int m_active_state = 0; // 0 - not active, 1 - active, 2 - update-to-date
+    bool is_tunnel_mqtt = false;
+
+    //AmsTray vt_tray;                        // virtual tray
+    long  ams_exist_bits = 0;
+    long  tray_exist_bits = 0;
+    long  tray_is_bbl_bits = 0;
+    long  tray_read_done_bits = 0;
+    long  tray_reading_bits = 0;
+    bool  ams_air_print_status { false };
+    bool  ams_support_virtual_tray { true };
+    time_t ams_user_setting_start = 0;
+    time_t ams_switch_filament_start = 0;
+    AmsStatusMain ams_status_main;
+    int   ams_status_sub;
+    int   ams_version = 0;
+
+    std::chrono::system_clock::time_point last_extrusion_cali_start_time;
+    int extrusion_cali_set_tray_id = -1;
+    std::chrono::system_clock::time_point extrusion_cali_set_hold_start;
+    std::string  extrusion_cali_filament_name;
+
+    bool is_in_extrusion_cali();
+    bool is_extrusion_cali_finished();
+
+    /* Networking */
+    NetworkAgent *get_agent() const { return m_agent; }
+
+    /* AMS */
+    DevAms*     get_curr_Ams();
+    DevAmsTray* get_curr_tray();
+    DevAmsTray* get_ams_tray(std::string ams_id, std::string tray_id);;
+
+    std::string  get_filament_id(std::string ams_id, std::string tray_id) const;
+    std::string  get_filament_type(const std::string& ams_id, const std::string& tray_id) const;
+    std::string  get_filament_display_type(const std::string& ams_id, const std::string& tray_id) const;
+
+    // parse amsStatusMain and ams_status_sub
+    void _parse_ams_status(int ams_status);
+
+    bool is_target_slot_unload() const;
+    bool can_unload_filament();
+
+    void get_ams_colors(std::vector<wxColour>& ams_colors);
+
+    /*extruder*/
+    bool is_main_extruder_on_left() const { return false;  } // only means the extruder is on the left hand when extruder id is 0
+    bool is_multi_extruders() const;
+    int  get_extruder_id_by_ams_id(const std::string& ams_id);
+
+    /* nozzle */
+    DevNozzle get_nozzle_by_id_code(int id_code) const;
+    DevNozzle get_nozzle_by_sn(const std::string& sn) const;
+
+    // auto nozzle mapping
+    DevNozzleMappingResult get_nozzle_mapping_result() const { return m_auto_nozzle_mapping; }
+    void set_manual_nozzle_mapping(int fila_id, int nozzle_pos_id) { m_auto_nozzle_mapping.SetManualNozzleMapping(this, fila_id, nozzle_pos_id); };// nozzle_pos_id is O\0x10\0x20\0x30...
+    void clear_auto_nozzle_mapping() { m_auto_nozzle_mapping.Clear(); }
+    int ctrl_get_auto_nozzle_mapping(Slic3r::GUI::Plater* plater, const std::vector<FilamentInfo>& ams_mapping, int flow_cali_opt, int pa_value);
+
+    /* ams settings*/
+    std::optional<bool> IsDetectOnInsertEnabled() const;
+    //bool IsDetectOnPowerupEnabled() const { return m_enable_detect_on_powerup; }
+    //bool IsDetectRemainEnabled() const { return m_enable_detect_remain; }
+    //bool IsAutoRefillEnabled() const { return m_enable_auto_refill; }
+
+    /* E3D has extra nozzle flow type info */
+    bool has_extra_flow_type{false};
+
+    [[nodiscard]] bool is_nozzle_flow_type_supported() const { return is_enable_np | has_extra_flow_type; }
+    [[nodiscard]] wxString get_nozzle_replace_url() const;
+
+    /*online*/
+    bool   online_rfid;
+    bool   online_ahb;
+    int    online_version = -1;
+    int    last_online_version = -1;
+
+    /* temperature */
+    float  frame_temp;
+
+    /* signals */
+    std::string wifi_signal;
+    std::string link_th;
+    std::string link_ams;
+    bool        network_wired { false };
+    std::shared_ptr<DevInfo> GetInfo() const { return m_dev_info; }
+
+    /* parts */
+    DevExtderSystem* GetExtderSystem() const { return m_extder_system; }
+    std::weak_ptr<DevExtensionTool> GetExtensionTool() const { return m_extension_tool; }
+
+    DevNozzleSystem*               GetNozzleSystem() const { return m_nozzle_system;}
+    std::shared_ptr<DevNozzleRack> GetNozzleRack() const;;
+
+    DevFilaSystem*   GetFilaSystem() const { return m_fila_system;}
+    bool             HasAms() const;
+
+    std::shared_ptr<DevAxis>    GetAxis() const { return m_axis; }
+    std::shared_ptr<DevChamber> GetChamber() const { return m_chamber; }
+    DevLamp*         GetLamp() const { return m_lamp; }
+    DevFan*          GetFan() const { return m_fan; }
+    DevBed *         GetBed() const { return m_bed; };
+    DevStorage      *GetStorage() const { return m_storage; }
+
+    DevCtrl*   GetCtrl() const { return m_ctrl; }       /* ctrl*/
+    DevHMS*    GetHMS() const { return m_hms_system; }   /* hms*/
+    DevConfig* GetConfig() const { return m_config; } /* config*/
+
+    DevPrintOptions*      GetPrintOptions() const { return m_print_options; } /* print options */
+    DevPrintingSpeedLevel GetPrintingSpeedLevel() const; /* print speed */
+
+    std::weak_ptr<DevUpgrade> GetUpgrade() const { return m_upgrade;}
+
+    /* upgrade */
+    std::string ams_new_version_number;
+    std::string ahb_new_version_number;
+    int get_version_retry = 0;
+
+    DevFirmwareVersionInfo air_pump_version_info;
+    DevFirmwareVersionInfo laser_version_info;
+    DevFirmwareVersionInfo cutting_module_version_info;
+    DevFirmwareVersionInfo extinguish_version_info;
+    std::map<std::string, DevFirmwareVersionInfo> module_vers;
+    std::vector<FirmwareInfo> firmware_list;
+
+    std::string get_firmware_type_str();
+    std::string get_lifecycle_type_str();
+    bool is_in_upgrading() const;
+    std::string get_ota_version();
+    bool check_version_valid();
+    // key: ams_id start as 0,1,2,3
+    std::map<int, DevFirmwareVersionInfo> get_ams_version();
+
+    void clear_version_info();
+    void store_version_info(const DevFirmwareVersionInfo& info);
+
+    /* printing */
+    std::string print_type;
+    //float   nozzle { 0.0f };        // default is 0.0f as initial value
+    bool    is_220V_voltage { false };
+
+    int     mc_print_stage;
+    int     mc_print_sub_stage;
+    int     mc_print_error_code;
+    int     mc_print_line_number;
+    int     mc_print_percent;       /* left print progess in percent */
+    int     mc_left_time;           /* left time in seconds */
+    int     last_mc_print_stage;
+    int     m_home_flag = 0;
+    int     hw_switch_state;
+    bool    is_system_printing();
+
+    int     print_error;
+    static std::string get_error_code_str(int error_code);
+    std::string get_print_error_str() const { return MachineObject::get_error_code_str(this->print_error); }
+
+    std::unordered_set<GUI::DeviceErrorDialog*> m_command_error_code_dlgs;
+    void  add_command_error_code_dlg(int command_err, json action_json=json{});
+
+    int     curr_layer = 0;
+    int     total_layers = 0;
+    bool    is_support_layer_num { false };
+    bool    nozzle_blob_detection_enabled{ false };
+    time_t  nozzle_blob_detection_hold_start = 0;
+
+    bool    is_support_new_auto_cali_method{false};
+    int last_cali_version = -1;
+    int cali_version = -1;
+    float                      cali_selected_nozzle_dia { 0.0 };
+    // 1: record when start calibration in preset page
+    // 2: reset when start calibration in start page
+    // 3: save tray_id, filament_id, setting_id, and name, nozzle_dia
+    std::vector<CaliPresetInfo> selected_cali_preset;
+    float                      cache_flow_ratio { 0.0 };
+    bool                       cali_finished = true;
+    FlowRatioCalibrationType   flow_ratio_calibration_type = FlowRatioCalibrationType::COMPLETE_CALIBRATION;
+
+    ManualPaCaliMethod         manual_pa_cali_method = ManualPaCaliMethod::PA_LINE;
+    bool                       has_get_pa_calib_tab{ false };
+    bool                       request_tab_from_bbs { false };
+    std::vector<PACalibResult> pa_calib_tab;
+    bool                       get_pa_calib_result { false };
+    std::vector<PACalibResult> pa_calib_results;
+    bool                       get_flow_calib_result { false };
+    std::vector<FlowRatioCalibResult> flow_ratio_results;
+    void reset_pa_cali_history_result()
+    {
+        has_get_pa_calib_tab = false;
+        pa_calib_tab.clear();
+    }
+
+    void reset_pa_cali_result() {
+        get_pa_calib_result = false;
+        pa_calib_results.clear();
+    }
+
+    void reset_flow_rate_cali_result() {
+        get_flow_calib_result = false;
+        flow_ratio_results.clear();
+    }
+
+    bool check_pa_result_validation(PACalibResult& result);
+
+    std::vector<int> stage_list_info;
+    int stage_curr = 0;
+    int stage_remaining_seconds = -1;
+    int m_push_count = 0;
+    int m_full_msg_count = 0; /*the full message count, there are full or diff messages from network*/
+    bool calibration_done { false };
+
+    bool is_filament_at_extruder();
+
+    wxString get_curr_stage();
+    int get_curr_stage_idx();
+    int get_stage_remaining_seconds() const { return stage_remaining_seconds; }
+
+    bool is_in_calibration();
+    bool is_calibration_running();
+    bool is_calibration_done();
+
+    void parse_state_changed_event();
+    void parse_home_flag(int flag);
+
+    /* printing status */
+    std::string print_status;      /* enum string: FINISH, SLICING, RUNNING, PAUSE, INIT, FAILED */
+    int queue_number = 0;
+    std::string iot_print_status;  /* iot */
+    int                printing_speed_mag = 100;
+    int get_bed_temperature_limit();
+    bool is_filament_installed();
+
+    /* camera */
+    bool has_ipcam { false };
+    bool camera_recording { false };
+    bool camera_recording_when_printing { false };
+    bool camera_timelapse { false };
+    time_t  camera_recording_ctl_start = 0;
+    int  camera_timelapse_hold_count = 0;
+    int  camera_resolution_hold_count = 0;
+    std::string camera_resolution            = "";
+    std::vector<std::string> camera_resolution_supported;
+    bool xcam_first_layer_inspector { false };
+    time_t  xcam_first_layer_hold_start = 0;
+    std::string local_rtsp_url;
+    std::string tutk_state;
+    enum LiveviewLocal {
+        LVL_None,
+        LVL_Disable,
+        LVL_Local,
+        LVL_Rtsps,
+        LVL_Rtsp
+    } liveview_local{ LVL_None };
+    enum LiveviewRemote {
+        LVR_None,
+        LVR_Tutk,
+        LVR_Agora,
+        LVR_TutkAgora
+    } liveview_remote{ LVR_None };
+    enum FileLocal {
+        FL_None,
+        FL_Local
+    } file_local{ FL_None };
+    enum FileRemote {
+        FR_None,
+        FR_Tutk,
+        FR_Agora,
+        FR_TutkAgora
+    } file_remote{ FR_None };
+
+    enum PlateMakerDectect : int
+    {
+        POS_CHECK      = 1,
+        TYPE_POS_CHECK = 2,
+    };
+
+    enum DoorOpenCheckState : int
+    {
+        DOOR_OPEN_CHECK_DISABLE            = 0,/*do nothing*/
+        DOOR_OPEN_CHECK_ENABLE_WARNING     = 1,/*warning*/
+        DOOR_OPEN_CHECK_ENABLE_PAUSE_PRINT = 2,/*pause print*/
+    };
+
+    bool        file_model_download{false};
+    bool        virtual_camera{false};
+
+    bool xcam_ai_monitoring{ false };
+    bool xcam_disable_ai_detection_display{false};
+    bool xcam_spaghetti_detection{false};
+    bool xcam_purgechutepileup_detection{false};
+    bool xcam_nozzleclumping_detection{false};
+    bool xcam_airprinting_detection{false};
+
+    time_t xcam_ai_monitoring_hold_start = 0;
+    std::string xcam_ai_monitoring_sensitivity;
+    std::string xcam_spaghetti_detection_sensitivity;
+    std::string xcam_purgechutepileup_detection_sensitivity;
+    std::string xcam_nozzleclumping_detection_sensitivity;
+    std::string xcam_airprinting_detection_sensitivity;
+
+    bool xcam_buildplate_marker_detector{ false };
+    time_t  xcam_buildplate_marker_hold_start = 0;
+    bool xcam_auto_recovery_step_loss{ false };
+    bool xcam_allow_prompt_sound{ false };
+    bool xcam_filament_tangle_detect{ false };
+    time_t  xcam_auto_recovery_hold_start = 0;
+    time_t  xcam_prompt_sound_hold_start = 0;
+    time_t  xcam_filament_tangle_detect_hold_start = 0;
+
+    // part skip
+    std::vector<int> m_partskip_ids;
+
+    /*target from Studio-SwitchBoard, default to INVALID_NOZZLE_ID if no switching control from PC*/
+    int targ_nozzle_id_from_pc = INVALID_EXTRUDER_ID;
+
+    //supported features
+
+    bool is_support_build_plate_marker_detect{false};
+    PlateMakerDectect m_plate_maker_detect_type{ POS_CHECK };
+
+    /* plate build type & align detect*/
+    DevDirtyHandler<bool> xcam_build_plate_type_detect{true, HOLD_TIME_3SEC, DirtyMode::TIMER};
+    DevDirtyHandler<bool> xcam_build_plate_align_detect{true, HOLD_TIME_3SEC, DirtyMode::TIMER};
+
+    bool is_support_build_plate_type_detect{false};
+    bool is_support_build_plate_align_detect{false};
+
+    /*PA flow calibration is using in sending print*/
+    bool is_support_pa_calibration{false};
+    bool is_support_flow_calibration{false};
+
+    bool is_support_send_to_sdcard {false};
+
+    bool is_support_filament_backup{false};
+    bool is_support_timelapse{false};
+    bool is_support_update_remain{false};
+    int  is_support_bed_leveling = 0;/*0: false; 1; on/off 2: auto/on/off*/
+    bool is_support_auto_recovery_step_loss{false};
+    bool is_support_ams_humidity {false};
+    bool is_support_prompt_sound{false};
+    bool is_support_filament_tangle_detect{false};
+    bool is_support_1080dpi {false};
+    bool is_support_cloud_print_only {false};
+    bool is_support_command_ams_switch{false};
+    bool is_support_mqtt_alive {false};
+    bool is_support_tunnel_mqtt{false};
+    bool is_support_motor_noise_cali{false};
+    bool is_support_wait_sending_finish{false};
+    bool is_support_user_preset{false};
+    bool is_support_nozzle_blob_detection{false};
+    bool is_support_air_print_detection{false};
+    bool is_support_agora{false};
+    bool is_support_upgrade_kit{false};
+    bool is_support_filament_setting_inprinting{false};
+    bool is_support_internal_timelapse { false };// fun[28], support timelapse without SD card
+    bool is_support_brtc{false};                 // fun[31], support tcp and upload protocol
+    bool is_support_ext_change_assist{false};
+    bool is_support_partskip{false};
+    bool is_support_refresh_nozzle{false};
+
+      // refine printer function options
+    bool is_support_spaghetti_detection{false};
+    bool is_support_purgechutepileup_detection{false};
+    bool is_support_nozzleclumping_detection{false};
+    bool is_support_airprinting_detection{false};
+    bool is_support_idelheadingprotect_detection{false};
+
+    // fun2
+    bool is_support_print_with_emmc{false};
+    bool is_support_pa_mode{false};
+
+    bool installed_upgrade_kit{false};
+    int  bed_temperature_limit = -1;
+
+    /*nozzle temp range*/
+    std::vector<int>    nozzle_temp_range;
+
+    /*temp temp range*/
+    std::vector<int>    bed_temp_range;
+
+    /* machine mqtt apis */
+    int connect(bool use_openssl = true);
+    int disconnect();
+
+    json_diff print_json;
+
+    /* Project Task and Sub Task */
+    std::string  project_id_;
+    std::string  profile_id_;
+    std::string  task_id_;
+    std::string  subtask_id_;
+    std::string  job_id_;
+    std::string  last_subtask_id_;
+    BBLSliceInfo* slice_info {nullptr};
+    boost::thread* get_slice_info_thread { nullptr };
+    boost::thread* get_model_task_thread { nullptr };
+
+    /* job attr */
+    int jobState_ = 0;
+
+    /* key: sequence id, value: callback */
+
+    bool is_makeworld_subtask();
+
+    int m_plate_index { -1 };
+    std::string m_gcode_file;
+    int gcode_file_prepare_percent = 0;
+    BBLSubTask* subtask_;
+    BBLModelTask *model_task { nullptr };
+    DevPrintTaskRatingInfo*  rating_info { nullptr };
+    int           request_model_result             = 0;
+    bool          get_model_mall_result_need_retry = false;
+
+    std::string obj_subtask_id;     // subtask_id == 0 for sdcard
+    std::string subtask_name;
+    bool is_sdcard_printing();
+    bool is_timelapse();
+    bool is_recording_enable();
+    bool is_recording();
+
+
+    int get_liveview_remote();
+    int get_file_remote();
+
+    std::string parse_version();
+    void parse_version_func();
+
+    /* quick check*/
+    bool canEnableTimelapse(wxString& error_message) const;
+
+    /* command commands */
+    int command_get_version(bool with_retry = true);
+    int command_request_push_all(bool request_now = false);
+    int command_pushing(std::string cmd);
+    int command_clean_print_error(std::string task_id, int print_error);
+    int command_clean_print_error_uiop(int print_error);
+    int command_set_printer_nozzle(std::string nozzle_type, float diameter);
+    int command_set_printer_nozzle2(int id, std::string nozzle_type, float diameter);
+    int command_get_access_code();
+    int command_ack_proceed(json& proceed);
+
+    /* control apis */
+
+    int command_task_abort();
+    /* cancelled the job_id */
+    int command_task_partskip(std::vector<int> part_ids);
+    int command_task_cancel(std::string job_id);
+    int command_task_pause();
+    int command_task_resume();
+    int command_hms_idle_ignore(const std::string &error_str, int type);
+    int command_hms_resume(const std::string& error_str, const std::string& job_id);
+    int command_hms_ignore(const std::string& error_str, const std::string& job_id);
+    int command_hms_stop(const std::string &error_str, const std::string &job_id);
+    /* buzzer*/
+    int command_stop_buzzer();
+
+    /* temp*/
+    bool m_support_mqtt_bet_ctrl = false;
+    int command_set_bed(int temp);
+
+    int command_set_nozzle(int temp);
+    int command_set_nozzle_new(int nozzle_id, int temp);
+    int command_refresh_nozzle();
+    int check_resume_condition();
+    // ams controls
+    //int command_ams_switch(int tray_index, int old_temp = 210, int new_temp = 210);
+    int command_ams_change_filament(bool load, std::string ams_id, std::string slot_id, int old_temp = 210, int new_temp = 210);
+    int command_ams_user_settings(bool start_read_opt, bool tray_read_opt, bool remain_flag = false);
+    int command_ams_switch_filament(bool switch_filament);
+    int command_ams_air_print_detect(bool air_print_detect);
+    int command_ams_calibrate(int ams_id);
+    int command_ams_filament_settings(int ams_id, int slot_id, std::string filament_id, std::string setting_id, std::string tray_color, std::string tray_type, int nozzle_temp_min, int nozzle_temp_max);
+    int command_ams_select_tray(std::string tray_id);
+    int command_ams_refresh_rfid(std::string tray_id);
+    int command_ams_refresh_rfid2(int ams_id, int slot_id);
+    int command_ams_control(std::string action);
+    int command_ams_drying_stop();
+    int command_start_extrusion_cali(int tray_index, int nozzle_temp, int bed_temp, float max_volumetric_speed, std::string setting_id = "");
+    int command_stop_extrusion_cali();
+    int command_extrusion_cali_set(int tray_index, std::string setting_id, std::string name, float k, float n, int bed_temp = -1, int nozzle_temp = -1, float max_volumetric_speed = -1);
+
+    // set printing speed
+    int command_set_printing_speed(DevPrintingSpeedLevel lvl);
+
+    //set prompt sound
+    int command_set_prompt_sound(bool prompt_sound);
+
+    //set fliament tangle detect
+    int command_set_filament_tangle_detect(bool fliament_tangle_detect);
+
+
+    // set print option
+    int command_set_printing_option(bool auto_recovery);
+
+    int command_nozzle_blob_detect(bool nozzle_blob_detect);
+
+    int command_extruder_control(int nozzle_id, double val);
+    // calibration printer
+    bool is_support_command_calibration();
+    int command_start_calibration(bool vibration, bool bed_leveling, bool xcam_cali, bool motor_noise, bool nozzle_cali, bool bed_cali, bool clumppos_cali);
+
+    // PA calibration
+    int command_start_pa_calibration(const X1CCalibInfos& pa_data, int mode = 0);  // 0: automatic mode; 1: manual mode. default: automatic mode
+    int command_set_pa_calibration(const std::vector<PACalibResult>& pa_calib_values, bool is_auto_cali);
+    int command_delete_pa_calibration(const PACalibIndexInfo& pa_calib);
+    int command_get_pa_calibration_tab(const PACalibExtruderInfo& calib_info);
+    int command_get_pa_calibration_result(float nozzle_diameter);
+    int commnad_select_pa_calibration(const PACalibIndexInfo& pa_calib_info);
+
+    // flow ratio calibration
+    int command_start_flow_ratio_calibration(const X1CCalibInfos& calib_data);
+    int command_get_flow_ratio_calibration_result(float nozzle_diameter);
+
+    // camera control
+    int command_ipcam_record(bool on_off);
+    int command_ipcam_timelapse(bool on_off);
+    int command_ipcam_resolution_set(std::string resolution);
+    int command_xcam_control(std::string module_name, bool on_off, std::string lvl = "");
+
+    //refine printer
+    int command_xcam_control_ai_monitoring(bool on_off, std::string lvl);
+    int command_xcam_control_spaghetti_detection(bool on_off, std::string lvl);
+    int command_xcam_control_purgechutepileup_detection(bool on_off, std::string lvl);
+    int command_xcam_control_nozzleclumping_detection(bool on_off, std::string lvl);
+    int command_xcam_control_airprinting_detection(bool on_off, std::string lvl);
+
+    int command_xcam_control_first_layer_inspector(bool on_off, bool print_halt);
+    int command_xcam_control_buildplate_marker_detector(bool on_off);
+    int command_xcam_control_auto_recovery_step_loss(bool on_off);
+    int command_xcam_control_allow_prompt_sound(bool on_off);
+    int command_xcam_control_filament_tangle_detect(bool on_off);
+    int command_xcam_control_build_plate_type_detector(bool on_off);
+    int command_xcam_control_build_plate_align_detector(bool on_off);
+
+    /* common apis */
+    inline bool is_local() { return !get_dev_ip().empty(); }
+    void set_bind_status(std::string status);
+    std::string get_bind_str();
+    bool can_print();
+    bool can_resume();
+    bool can_pause();
+    bool can_abort();
+    bool is_in_printing();
+    bool is_in_printing_pause() const;
+    bool is_in_prepare();
+    bool is_printing_finished();
+    void reset_update_time();
+    void reset();
+    static bool is_in_printing_status(std::string status);
+
+    void set_print_state(std::string status);
+
+    bool is_connected();
+    bool is_connecting();
+    void set_online_state(bool on_off);
+    bool is_online() { return m_is_online; }
+    bool is_info_ready(bool check_version = true) const;
+    bool is_security_control_ready() const;
+    bool is_camera_busy_off();
+
+    std::vector<std::string> get_resolution_supported();
+    std::vector<std::string> get_compatible_machine();
+
+    /* Msg for display MsgFn */
+    typedef std::function<void(std::string topic, std::string payload)> MsgFn;
+    int publish_json(const json& json_item, int qos = 0, int flag = 0) ;
+    int publish_json(const std::string& json_str, int qos = 0, int flag = 0) = delete;
+    int cloud_publish_json(std::string json_str, int qos = 0, int flag = 0);
+    int local_publish_json(std::string json_str, int qos = 0, int flag = 0);
+    int parse_json(std::string tunnel, std::string payload, bool key_filed_only = false);
+    int publish_gcode(std::string gcode_str);
+    void update_device_cert_state(bool ready);
+
+    static std::string setting_id_to_type(std::string setting_id, std::string tray_type);
+    BBLSubTask* get_subtask();
+    BBLModelTask* get_modeltask();
+    void set_modeltask(BBLModelTask* task);
+
+    void update_model_task();
+
+    void free_slice_info();
+    void update_slice_info(std::string project_id, std::string profile_id, std::string subtask_id, int plate_idx);
+
+    bool m_firmware_valid { false };
+    bool m_firmware_thread_started { false };
+    void get_firmware_info();
+    bool is_firmware_info_valid();
+
+    /*for more extruder*/
+    bool                        is_enable_np{ false };
+    bool                        is_enable_ams_np{ false };
+
+    /*vi slot data*/
+    std::vector<DevAmsTray> vt_slot;
+    DevAmsTray parse_vt_tray(json vtray);
+
+    /*get ams slot info*/
+    bool    contains_tray(const std::string &ams_id, const std::string &tray_id) const;
+    DevAmsTray get_tray(const std::string &ams_id, const std::string &tray_id) const;/*use contains_tray() check first*/
+
+    /*for parse new info*/
+    bool check_enable_np(const json& print) const;
+    void parse_new_info(json print);
+    int  get_flag_bits(std::string str, int start, int count = 1) const;
+    uint32_t get_flag_bits_no_border(std::string str, int start_idx, int count = 1) const;
+    int get_flag_bits(int num, int start, int count = 1, int base = 10) const;
+
+    /* Device Filament Check */
+    struct FilamentData
+    {
+        std::set<std::string>                      checked_filament;
+        std::string                                printer_preset_name;
+        std::map<std::string, std::pair<int, int>> filament_list; // filament_id, pair<min temp, max temp>
+    };
+    std::map<std::string, FilamentData> m_nozzle_filament_data;
+    void update_filament_list();
+    void update_printer_preset_name();
+    void check_ams_filament_valid();
+
+
+
+    /* xcam door open check*/
+    bool               support_door_open_check() const { return is_support_door_open_check;};
+    DoorOpenCheckState get_door_open_check_state() const { return xcam_door_open_check;};
+    void               command_set_door_open_check(DoorOpenCheckState state);
+
+    /* xcam save remove print file to local*/
+    bool get_save_remote_print_file_to_storage() const { return xcam__save_remote_print_file_to_storage; };
+    void command_set_save_remote_print_file_to_storage(bool save);
+
+private:
+
+    /* xcam door open check*/
+    bool is_support_door_open_check = false;
+    DoorOpenCheckState xcam_door_open_check  = DoorOpenCheckState::DOOR_OPEN_CHECK_DISABLE;
+    time_t xcam_door_open_check_start_time   = 0;
+
+    /* xcam save remove print file to local*/
+    bool xcam__save_remote_print_file_to_storage      = false;
+    time_t xcam__save_remote_print_file_to_storage_start_time = 0;
+};
+
+
+// change the opacity
+void change_the_opacity(wxColour& colour);
+wxString get_stage_string(int stage);
+
+}; // namespace Slic3r
+
+#endif //  slic3r_DeviceManager_hpp_
diff --git a/src/slic3r/GUI/SelectMachinePop.cpp b/src/slic3r/GUI/SelectMachinePop.cpp
new file mode 100644
index 0000000..0b67eeb
--- /dev/null
+++ b/src/slic3r/GUI/SelectMachinePop.cpp
@@ -0,0 +1,1094 @@
+#include "SelectMachinePop.hpp"
+#include "I18N.hpp"
+
+#include "libslic3r/Utils.hpp"
+#include "libslic3r/Thread.hpp"
+
+#include "slic3r/Utils/WxFontUtils.hpp"
+
+#include "GUI.hpp"
+#include "GUI_App.hpp"
+#include "GUI_Preview.hpp"
+#include "MainFrame.hpp"
+#include "format.hpp"
+#include "Widgets/ProgressDialog.hpp"
+#include "Widgets/RoundedRectangle.hpp"
+#include "Widgets/StaticBox.hpp"
+#include "ConnectPrinter.hpp"
+
+
+#include <wx/progdlg.h>
+#include <wx/clipbrd.h>
+#include <wx/dcgraph.h>
+#include <wx/mstream.h>
+#include <miniz.h>
+#include <algorithm>
+#include "Plater.hpp"
+#include "Notebook.hpp"
+#include "BitmapCache.hpp"
+#include "BindDialog.hpp"
+
+#include "DeviceCore/DevManager.h"
+
+namespace Slic3r { namespace GUI {
+
+wxDEFINE_EVENT(EVT_UPDATE_WINDOWS_POSITION, wxCommandEvent);
+wxDEFINE_EVENT(EVT_FINISHED_UPDATE_MACHINE_LIST, wxCommandEvent);
+wxDEFINE_EVENT(EVT_UPDATE_USER_MACHINE_LIST, wxCommandEvent);
+wxDEFINE_EVENT(EVT_BIND_MACHINE, wxCommandEvent);
+wxDEFINE_EVENT(EVT_UNBIND_MACHINE, wxCommandEvent);
+wxDEFINE_EVENT(EVT_DISSMISS_MACHINE_LIST, wxCommandEvent);
+wxDEFINE_EVENT(EVT_CONNECT_LAN_PRINT, wxCommandEvent);
+wxDEFINE_EVENT(EVT_EDIT_PRINT_NAME, wxCommandEvent);
+wxDEFINE_EVENT(EVT_CLEAR_IPADDRESS, wxCommandEvent);
+
+
+#define INITIAL_NUMBER_OF_MACHINES 0
+#define LIST_REFRESH_INTERVAL 200
+#define MACHINE_LIST_REFRESH_INTERVAL 2000
+
+#define WRAP_GAP FromDIP(2)
+
+MachineObjectPanel::MachineObjectPanel(wxWindow *parent, wxWindowID id, const wxPoint &pos, const wxSize &size, long style, const wxString &name)
+{
+    wxPanel::Create(parent, id, pos, wxDefaultSize, style, name);
+
+    SetSize(SELECT_MACHINE_ITEM_SIZE);
+    SetMinSize(SELECT_MACHINE_ITEM_SIZE);
+    SetMaxSize(SELECT_MACHINE_ITEM_SIZE);
+
+    Bind(wxEVT_PAINT, &MachineObjectPanel::OnPaint, this);
+
+    SetBackgroundColour(StateColor::darkModeColorFor(*wxWHITE));
+
+    m_unbind_img        = ScalableBitmap(this, "unbind", 18);
+    m_edit_name_img     = ScalableBitmap(this, "edit_button", 18);
+    m_select_unbind_img = ScalableBitmap(this, "unbind_selected", 18);
+
+    m_printer_status_offline = ScalableBitmap(this, "printer_status_offline", 12);
+    m_printer_status_busy    = ScalableBitmap(this, "printer_status_busy", 12);
+    m_printer_status_idle    = ScalableBitmap(this, "printer_status_idle", 12);
+    m_printer_status_lock    = ScalableBitmap(this, "printer_status_lock", 16);
+    m_printer_in_lan         = ScalableBitmap(this, "printer_in_lan", 16);
+
+    this->Bind(wxEVT_ENTER_WINDOW, &MachineObjectPanel::on_mouse_enter, this);
+    this->Bind(wxEVT_LEAVE_WINDOW, &MachineObjectPanel::on_mouse_leave, this);
+    this->Bind(wxEVT_LEFT_UP, &MachineObjectPanel::on_mouse_left_up, this);
+
+#ifdef __APPLE__
+    wxPlatformInfo platformInfo;
+    auto major = platformInfo.GetOSMajorVersion();
+    auto minor = platformInfo.GetOSMinorVersion();
+    auto micro = platformInfo.GetOSMicroVersion();
+
+    //macos over 13.1.0
+    if (major == 13 && minor >= 1) {
+        m_is_macos_special_version = true;
+    } else if (major > 13) {
+        m_is_macos_special_version = true;
+    }
+#endif
+
+}
+
+
+MachineObjectPanel::~MachineObjectPanel() {}
+
+void MachineObjectPanel::show_bind_dialog()
+{
+    if (wxGetApp().is_user_login()) {
+        BindMachineDialog dlg;
+        dlg.update_machine_info(m_info);
+        dlg.ShowModal();
+    }
+}
+
+void MachineObjectPanel::set_printer_state(PrinterState state)
+{
+    m_state = state;
+    Refresh();
+}
+
+void MachineObjectPanel::show_edit_printer_name(bool show)
+{
+    m_show_edit = show;
+    Refresh();
+}
+
+void MachineObjectPanel::show_printer_bind(bool show, PrinterBindState state)
+{
+    m_show_bind   = show;
+    m_bind_state  = state;
+    Refresh();
+}
+
+void MachineObjectPanel::OnPaint(wxPaintEvent &event)
+{
+    wxPaintDC dc(this);
+    doRender(dc);
+}
+
+void MachineObjectPanel::render(wxDC &dc)
+{
+#ifdef __WXMSW__
+    wxSize     size = GetSize();
+    wxMemoryDC memdc;
+    wxBitmap   bmp(size.x, size.y);
+    memdc.SelectObject(bmp);
+    memdc.Blit({0, 0}, size, &dc, {0, 0});
+
+    {
+        wxGCDC dc2(memdc);
+        doRender(dc2);
+    }
+
+    memdc.SelectObject(wxNullBitmap);
+    dc.DrawBitmap(bmp, 0, 0);
+#else
+    doRender(dc);
+#endif
+}
+
+void MachineObjectPanel::doRender(wxDC &dc)
+{
+    auto   left = 10;
+    wxSize size = GetSize();
+    dc.SetPen(*wxTRANSPARENT_PEN);
+
+    auto dwbitmap = m_printer_status_offline;
+    if (m_state == PrinterState::IDLE) { dwbitmap = m_printer_status_idle; }
+    if (m_state == PrinterState::BUSY) { dwbitmap = m_printer_status_busy; }
+    if (m_state == PrinterState::OFFLINE) { dwbitmap = m_printer_status_offline; }
+    if (m_state == PrinterState::LOCK) { dwbitmap = m_printer_status_lock; }
+    if (m_state == PrinterState::IN_LAN) { dwbitmap = m_printer_in_lan; }
+
+    // dc.DrawCircle(left, size.y / 2, 3);
+    dc.DrawBitmap(dwbitmap.bmp(), wxPoint(left, (size.y - dwbitmap.GetBmpSize().y) / 2));
+
+    left += dwbitmap.GetBmpSize().x + 8;
+    dc.SetFont(Label::Body_13);
+    dc.SetBackgroundMode(wxTRANSPARENT);
+    dc.SetTextForeground(StateColor::darkModeColorFor(SELECT_MACHINE_GREY900));
+    wxString dev_name = "";
+    if (m_info) {
+        dev_name = from_u8(m_info->get_dev_name());
+
+         if (m_state == PrinterState::IN_LAN) {
+             dev_name += _L("(LAN)");
+         }
+    }
+    auto        sizet        = dc.GetTextExtent(dev_name);
+    auto        text_end     = 0;
+
+    if (m_show_edit) {
+        text_end = size.x - m_unbind_img.GetBmpSize().x - 30;
+    }
+    else {
+        text_end = size.x - m_unbind_img.GetBmpSize().x;
+    }
+
+    wxString finally_name =  dev_name;
+    if (sizet.x > (text_end - left)) {
+        auto limit_width = text_end - left - dc.GetTextExtent("...").x - 15;
+        for (auto i = 0; i < dev_name.length(); i++) {
+            auto curr_width = dc.GetTextExtent(dev_name.substr(0, i));
+            if (curr_width.x >= limit_width) {
+                finally_name = dev_name.substr(0, i) + "...";
+                break;
+            }
+        }
+    }
+
+    dc.DrawText(finally_name, wxPoint(left, (size.y - sizet.y) / 2));
+
+
+    if (m_hover || m_is_macos_special_version) {
+
+        if (m_hover && !m_is_macos_special_version) {
+            dc.SetPen(SELECT_MACHINE_BRAND);
+            dc.SetBrush(*wxTRANSPARENT_BRUSH);
+            dc.DrawRectangle(0, 0, size.x, size.y);
+        }
+
+        if (m_show_bind) {
+            if (m_bind_state == ALLOW_UNBIND) {
+                left = size.x - m_unbind_img.GetBmpSize().x - 6;
+                dc.DrawBitmap(m_unbind_img.bmp(), left, (size.y - m_unbind_img.GetBmpSize().y) / 2);
+            }
+        }
+
+        if (m_show_edit) {
+            left = size.x - m_unbind_img.GetBmpSize().x - 6 - m_edit_name_img.GetBmpSize().x - 6;
+            dc.DrawBitmap(m_edit_name_img.bmp(), left, (size.y - m_edit_name_img.GetBmpSize().y) / 2);
+        }
+    }
+
+}
+
+void MachineObjectPanel::update_machine_info(MachineObject *info, bool is_my_devices)
+{
+    m_info = info;
+    m_is_my_devices = is_my_devices;
+    Refresh();
+}
+
+void MachineObjectPanel::on_mouse_enter(wxMouseEvent &evt)
+{
+    m_hover = true;
+    Refresh();
+}
+
+void MachineObjectPanel::on_mouse_leave(wxMouseEvent &evt)
+{
+    m_hover = false;
+    Refresh();
+}
+
+void MachineObjectPanel::on_mouse_left_up(wxMouseEvent &evt)
+{
+    if (m_is_my_devices) {
+        // show edit
+        if (m_show_edit) {
+            auto edit_left   = GetSize().x - m_unbind_img.GetBmpSize().x - 6 - m_edit_name_img.GetBmpSize().x - 6;
+            auto edit_right  = edit_left + m_edit_name_img.GetBmpSize().x;
+            auto edit_top    = (GetSize().y - m_edit_name_img.GetBmpSize().y) / 2;
+            auto edit_bottom = (GetSize().y - m_edit_name_img.GetBmpSize().y) / 2 + m_edit_name_img.GetBmpSize().y;
+            if ((evt.GetPosition().x >= edit_left && evt.GetPosition().x <= edit_right) && evt.GetPosition().y >= edit_top && evt.GetPosition().y <= edit_bottom) {
+                wxCommandEvent event(EVT_EDIT_PRINT_NAME);
+                event.SetEventObject(this);
+                wxPostEvent(this, event);
+                return;
+            }
+        }
+        if (m_show_bind) {
+            auto left   = GetSize().x - m_unbind_img.GetBmpSize().x - 6;
+            auto right  = left + m_unbind_img.GetBmpSize().x;
+            auto top    = (GetSize().y - m_unbind_img.GetBmpSize().y) / 2;
+            auto bottom = (GetSize().y - m_unbind_img.GetBmpSize().y) / 2 + m_unbind_img.GetBmpSize().y;
+
+            if ((evt.GetPosition().x >= left && evt.GetPosition().x <= right) && evt.GetPosition().y >= top && evt.GetPosition().y <= bottom) {
+                wxCommandEvent event(EVT_UNBIND_MACHINE, GetId());
+                event.SetEventObject(this);
+                GetEventHandler()->ProcessEvent(event);
+            } else {
+                if (m_info) {
+                    wxGetApp().mainframe->jump_to_monitor(m_info->get_dev_id());
+                }
+                //wxGetApp().mainframe->SetFocus();
+                wxCommandEvent event(EVT_DISSMISS_MACHINE_LIST);
+                event.SetEventObject(this->GetParent());
+                wxPostEvent(this->GetParent(), event);
+            }
+            return;
+        }
+        if (m_info && m_info->is_lan_mode_printer()) {
+            if (m_info->has_access_right() && m_info->is_avaliable()) {
+                wxGetApp().mainframe->jump_to_monitor(m_info->get_dev_id());
+            } else {
+                wxCommandEvent event(EVT_CONNECT_LAN_PRINT);
+                event.SetEventObject(this);
+                wxPostEvent(this, event);
+            }
+        } else {
+            wxGetApp().mainframe->jump_to_monitor(m_info->get_dev_id());
+        }
+    } else {
+        if (m_info && m_info->is_lan_mode_printer()) {
+            wxCommandEvent event(EVT_CONNECT_LAN_PRINT);
+            event.SetEventObject(this);
+            wxPostEvent(this, event);
+        } else {
+            wxCommandEvent event(EVT_BIND_MACHINE);
+            event.SetEventObject(this);
+            wxPostEvent(this, event);
+        }
+    }
+
+}
+
+SelectMachinePopup::SelectMachinePopup(wxWindow *parent)
+    : PopupWindow(parent, wxBORDER_NONE | wxPU_CONTAINS_CONTROLS), m_dismiss(false)
+{
+#ifdef __WINDOWS__
+    SetDoubleBuffered(true);
+#endif //__WINDOWS__
+
+
+    SetSize(SELECT_MACHINE_POPUP_SIZE);
+    SetMinSize(SELECT_MACHINE_POPUP_SIZE);
+    SetMaxSize(SELECT_MACHINE_POPUP_SIZE);
+
+    Freeze();
+    wxBoxSizer *m_sizer_main = new wxBoxSizer(wxVERTICAL);
+    SetBackgroundColour(SELECT_MACHINE_GREY400);
+
+
+
+    m_scrolledWindow = new wxScrolledWindow(this, wxID_ANY, wxDefaultPosition, SELECT_MACHINE_LIST_SIZE, wxHSCROLL | wxVSCROLL);
+    m_scrolledWindow->SetBackgroundColour(*wxWHITE);
+    m_scrolledWindow->SetMinSize(SELECT_MACHINE_LIST_SIZE);
+    m_scrolledWindow->SetScrollRate(0, 5);
+    auto m_sizxer_scrolledWindow = new wxBoxSizer(wxVERTICAL);
+    m_scrolledWindow->SetSizer(m_sizxer_scrolledWindow);
+    m_scrolledWindow->Layout();
+    m_sizxer_scrolledWindow->Fit(m_scrolledWindow);
+
+#if defined(__WINDOWS__)
+	m_sizer_search_bar = new wxBoxSizer(wxVERTICAL);
+	m_search_bar = new wxSearchCtrl( this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0 );
+	m_search_bar->SetDescriptiveText(_L("Search"));
+	m_search_bar->ShowSearchButton( true );
+	m_search_bar->ShowCancelButton( false );
+	m_sizer_search_bar->Add( m_search_bar, 1, wxALL| wxEXPAND, 1 );
+	m_sizer_main->Add(m_sizer_search_bar, 0, wxALL | wxEXPAND, FromDIP(2));
+	m_search_bar->Bind( wxEVT_COMMAND_TEXT_UPDATED, &SelectMachinePopup::update_machine_list, this );
+#endif
+    auto own_title        = create_title_panel(_L("My Device"));
+    m_sizer_my_devices    = new wxBoxSizer(wxVERTICAL);
+    auto other_title      = create_title_panel(_L("Other Device"));
+    m_sizer_other_devices = new wxBoxSizer(wxVERTICAL);
+
+
+    m_panel_ping_code = new PinCodePanel(m_scrolledWindow, 0, wxID_ANY, wxDefaultPosition, SELECT_MACHINE_ITEM_SIZE);
+    m_panel_direct_connection = new PinCodePanel(m_scrolledWindow, 1, wxID_ANY, wxDefaultPosition, SELECT_MACHINE_ITEM_SIZE);
+
+    m_sizxer_scrolledWindow->Add(own_title, 0, wxEXPAND | wxLEFT, FromDIP(15));
+    m_sizxer_scrolledWindow->Add(m_sizer_my_devices, 0, wxEXPAND, 0);
+    m_sizxer_scrolledWindow->Add(m_panel_ping_code, 0, wxEXPAND, 0);
+    m_sizxer_scrolledWindow->Add(m_panel_direct_connection, 0, wxEXPAND, 0);
+    m_sizxer_scrolledWindow->Add(other_title, 0, wxEXPAND | wxLEFT, FromDIP(15));
+    m_sizxer_scrolledWindow->Add(m_sizer_other_devices, 0, wxEXPAND, 0);
+
+    m_sizer_main->Add(m_scrolledWindow, 0, wxALL | wxEXPAND, FromDIP(2));
+
+    SetSizer(m_sizer_main);
+    Layout();
+    Thaw();
+
+    #ifdef __APPLE__
+    m_scrolledWindow->Bind(wxEVT_LEFT_UP, &SelectMachinePopup::OnLeftUp, this);
+    #endif // __APPLE__
+
+    m_refresh_timer = new wxTimer();
+    m_refresh_timer->SetOwner(this);
+    Bind(EVT_UPDATE_USER_MACHINE_LIST, &SelectMachinePopup::update_machine_list, this);
+    Bind(wxEVT_TIMER, &SelectMachinePopup::on_timer, this);
+    Bind(EVT_DISSMISS_MACHINE_LIST, &SelectMachinePopup::on_dissmiss_win, this);
+}
+
+SelectMachinePopup::~SelectMachinePopup() { delete m_refresh_timer;}
+
+void SelectMachinePopup::Popup(wxWindow *WXUNUSED(focus))
+{
+    BOOST_LOG_TRIVIAL(trace) << "get_print_info: start";
+    start_ssdp(true);
+    if (m_refresh_timer) {
+        m_refresh_timer->Stop();
+        m_refresh_timer->Start(MACHINE_LIST_REFRESH_INTERVAL);
+    }
+
+    if (wxGetApp().is_user_login()) {
+        if (!get_print_info_thread) {
+            get_print_info_thread = new boost::thread(Slic3r::create_thread([this, token = std::weak_ptr(m_token)] {
+                NetworkAgent* agent = wxGetApp().getAgent();
+                unsigned int http_code;
+                std::string body;
+                int result = agent->get_user_print_info(&http_code, &body);
+                CallAfter([token, this, result, body]() {
+                    if (token.expired()) {return;}
+                    if (result == 0) {
+                        m_print_info = body;
+                    }
+                    else {
+                        m_print_info = "";
+                    }
+                    wxCommandEvent event(EVT_UPDATE_USER_MACHINE_LIST);
+                    event.SetEventObject(this);
+                    wxPostEvent(this, event);
+                });
+            }));
+        }
+    }
+
+    {
+        wxGetApp().reset_to_active();
+        wxCommandEvent user_event(EVT_UPDATE_USER_MACHINE_LIST);
+        user_event.SetEventObject(this);
+        wxPostEvent(this, user_event);
+    }
+
+    PopupWindow::Popup();
+}
+
+void SelectMachinePopup::OnDismiss()
+{
+    BOOST_LOG_TRIVIAL(trace) << "get_print_info: dismiss";
+    start_ssdp(false);
+    m_dismiss = true;
+
+    if (m_refresh_timer) {
+        m_refresh_timer->Stop();
+    }
+    if (get_print_info_thread) {
+        if (get_print_info_thread->joinable()) {
+            get_print_info_thread->join();
+            delete get_print_info_thread;
+            get_print_info_thread = nullptr;
+        }
+    }
+
+    wxCommandEvent event(EVT_FINISHED_UPDATE_MACHINE_LIST);
+    event.SetEventObject(this);
+    wxPostEvent(this, event);
+}
+
+bool SelectMachinePopup::ProcessLeftDown(wxMouseEvent &event) {
+    return PopupWindow::ProcessLeftDown(event);
+}
+
+bool SelectMachinePopup::Show(bool show) {
+    if (show) {
+        for (int i = 0; i < m_user_list_machine_panel.size(); i++) {
+            m_user_list_machine_panel[i]->mPanel->update_machine_info(nullptr);
+            m_user_list_machine_panel[i]->mPanel->Hide();
+        }
+
+         for (int j = 0; j < m_other_list_machine_panel.size(); j++) {
+            m_other_list_machine_panel[j]->mPanel->update_machine_info(nullptr);
+            m_other_list_machine_panel[j]->mPanel->Hide();
+        }
+    }
+    return PopupWindow::Show(show);
+}
+
+wxWindow *SelectMachinePopup::create_title_panel(wxString text)
+{
+    auto m_panel_title_own = new wxWindow(m_scrolledWindow, wxID_ANY, wxDefaultPosition, SELECT_MACHINE_ITEM_SIZE, wxTAB_TRAVERSAL);
+    m_panel_title_own->SetBackgroundColour(*wxWHITE);
+
+    wxBoxSizer *m_sizer_title_own = new wxBoxSizer(wxHORIZONTAL);
+
+    auto m_title_own = new wxStaticText(m_panel_title_own, wxID_ANY, text, wxDefaultPosition, wxDefaultSize, 0);
+    m_title_own->SetForegroundColour(wxColour(147,147,147));
+    m_title_own->Wrap(-1);
+    m_sizer_title_own->Add(m_title_own, 0, wxALIGN_CENTER, 0);
+
+    wxBoxSizer *m_sizer_line_own = new wxBoxSizer(wxHORIZONTAL);
+
+    auto m_panel_line_own = new wxPanel(m_panel_title_own, wxID_ANY, wxDefaultPosition, wxSize(SELECT_MACHINE_ITEM_SIZE.x, FromDIP(1)), wxTAB_TRAVERSAL);
+    m_panel_line_own->SetBackgroundColour(SELECT_MACHINE_GREY400);
+
+    m_sizer_line_own->Add(m_panel_line_own, 0, wxALIGN_CENTER, 0);
+    m_sizer_title_own->Add(0, 0, 0, wxLEFT, FromDIP(10));
+    m_sizer_title_own->Add(m_sizer_line_own, 1, wxEXPAND | wxRIGHT, FromDIP(10));
+
+    m_panel_title_own->SetSizer(m_sizer_title_own);
+    m_panel_title_own->Layout();
+    return m_panel_title_own;
+}
+
+void SelectMachinePopup::on_timer(wxTimerEvent &event)
+{
+    BOOST_LOG_TRIVIAL(trace) << "SelectMachinePopup on_timer";
+    wxGetApp().reset_to_active();
+    wxCommandEvent user_event(EVT_UPDATE_USER_MACHINE_LIST);
+    user_event.SetEventObject(this);
+    wxPostEvent(this, user_event);
+}
+
+void SelectMachinePopup::update_other_devices()
+{
+    DeviceManager* dev = wxGetApp().getDeviceManager();
+    if (!dev) return;
+    m_free_machine_list = dev->get_local_machinelist();
+
+    BOOST_LOG_TRIVIAL(trace) << "SelectMachinePopup update_other_devices start";
+    this->Freeze();
+    m_scrolledWindow->Freeze();
+    int i = 0;
+
+    for (auto &elem : m_free_machine_list) {
+        MachineObject *     mobj = elem.second;
+        /* do not show printer bind state is empty */
+        if (!mobj->is_avaliable()) continue;
+
+        if (!wxGetApp().is_user_login() && !mobj->is_lan_mode_printer())
+            continue;
+
+        /* do not show printer in my list */
+        auto it = m_bind_machine_list.find(mobj->get_dev_id());
+        if (it != m_bind_machine_list.end())
+            continue;
+
+        MachineObjectPanel* op = nullptr;
+        if (i < m_other_list_machine_panel.size()) {
+            op = m_other_list_machine_panel[i]->mPanel;
+        } else {
+            op = new MachineObjectPanel(m_scrolledWindow, wxID_ANY);
+            MachinePanel* mpanel = new MachinePanel();
+            mpanel->mIndex = wxString::Format("%d", i);
+            mpanel->mPanel = op;
+            m_other_list_machine_panel.push_back(mpanel);
+            m_sizer_other_devices->Add(op, 0, wxEXPAND, 0);
+        }
+#if defined(__WINDOWS__)
+        if (!search_for_printer(mobj)) {
+            op->Hide();
+        }
+        else {
+            op->Show();
+        }
+#else
+        op->Show();
+#endif
+        i++;
+
+        op->update_machine_info(mobj);
+
+        if (mobj->is_lan_mode_printer()) {
+            if (mobj->has_access_right()) {
+                op->set_printer_state(PrinterState::IN_LAN);
+            } else {
+                op->set_printer_state(PrinterState::LOCK);
+            }
+        } else {
+            op->show_edit_printer_name(false);
+            op->show_printer_bind(true, PrinterBindState::ALLOW_BIND);
+            if (mobj->is_in_printing()) {
+                op->set_printer_state(PrinterState::BUSY);
+            } else {
+                op->SetToolTip(_L("Online"));
+                op->set_printer_state(IDLE);
+            }
+        }
+
+        op->Bind(EVT_CONNECT_LAN_PRINT, [this, mobj](wxCommandEvent &e) {
+            if (mobj) {
+                if (mobj->is_lan_mode_printer()) {
+                    ConnectPrinterDialog dlg(wxGetApp().mainframe, wxID_ANY, _L("Input access code"));
+                    dlg.set_machine_object(mobj);
+                    if (dlg.ShowModal() == wxID_OK) {
+                        wxGetApp().mainframe->jump_to_monitor(mobj->get_dev_id());
+                    }
+                }
+            }
+        });
+
+        op->Bind(EVT_BIND_MACHINE, [this, mobj](wxCommandEvent &e) {
+            BindMachineDialog dlg;
+            dlg.update_machine_info(mobj);
+            int dlg_result = wxID_CANCEL;
+            dlg_result     = dlg.ShowModal();
+            if (dlg_result == wxID_OK) { wxGetApp().mainframe->jump_to_monitor(mobj->get_dev_id()); }
+        });
+    }
+
+    for (int j = i; j < m_other_list_machine_panel.size(); j++) {
+        m_other_list_machine_panel[j]->mPanel->update_machine_info(nullptr);
+        m_other_list_machine_panel[j]->mPanel->Hide();
+    }
+
+    if (m_placeholder_panel != nullptr) {
+        m_scrolledWindow->RemoveChild(m_placeholder_panel);
+        m_placeholder_panel->Destroy();
+        m_placeholder_panel = nullptr;
+    }
+
+    m_placeholder_panel = new wxWindow(m_scrolledWindow, wxID_ANY, wxDefaultPosition, wxSize(-1,FromDIP(26)));
+    wxBoxSizer* placeholder_sizer = new wxBoxSizer(wxVERTICAL);
+
+    m_hyperlink = new wxHyperlinkCtrl(m_placeholder_panel, wxID_ANY, _L("Can't find my devices?"), wxT("https://wiki.bambulab.com/en/software/bambu-studio/failed-to-connect-printer"), wxDefaultPosition, wxDefaultSize, wxHL_DEFAULT_STYLE);
+    placeholder_sizer->Add(m_hyperlink, 0, wxALIGN_CENTER | wxALL, 5);
+
+
+    m_placeholder_panel->SetSizer(placeholder_sizer);
+    m_placeholder_panel->Layout();
+    placeholder_sizer->Fit(m_placeholder_panel);
+
+    m_placeholder_panel->SetBackgroundColour(StateColor::darkModeColorFor(*wxWHITE));
+    m_sizer_other_devices->Add(m_placeholder_panel, 0, wxEXPAND, 0);
+
+    //m_sizer_other_devices->Layout();
+    if(m_other_devices_count != i) {
+		m_scrolledWindow->Fit();
+    }
+    m_scrolledWindow->Layout();
+	m_scrolledWindow->Thaw();
+	Layout();
+	Fit();
+	this->Thaw();
+    m_other_devices_count = i;
+    BOOST_LOG_TRIVIAL(trace) << "SelectMachinePopup update_other_devices end";
+}
+
+void SelectMachinePopup::update_user_devices()
+{
+    Slic3r::DeviceManager* dev = Slic3r::GUI::wxGetApp().getDeviceManager();
+    if (!dev) return;
+
+    if (!m_print_info.empty()) {
+        dev->parse_user_print_info(m_print_info);
+        m_print_info = "";
+    }
+
+    m_bind_machine_list.clear();
+    m_bind_machine_list = dev->get_my_machine_list();
+
+    //sort list
+    std::vector<std::pair<std::string, MachineObject*>> user_machine_list;
+    for (auto& it: m_bind_machine_list) {
+        user_machine_list.push_back(it);
+    }
+
+    std::sort(user_machine_list.begin(), user_machine_list.end(), [&](auto& a, auto&b) {
+            if (a.second && b.second) {
+                return a.second->get_dev_name().compare(b.second->get_dev_name()) < 0;
+            }
+            return false;
+        });
+
+    BOOST_LOG_TRIVIAL(trace) << "SelectMachinePopup update_machine_list start";
+    this->Freeze();
+    m_scrolledWindow->Freeze();
+    int i = 0;
+
+    for (auto& elem : user_machine_list) {
+        MachineObject* mobj = elem.second;
+        MachineObjectPanel* op = nullptr;
+        if (i < m_user_list_machine_panel.size()) {
+            op = m_user_list_machine_panel[i]->mPanel;
+#if defined(__WINDOWS__)
+			if (!search_for_printer(mobj)) {
+				op->Hide();
+			} else {
+                op->Show();
+            }
+#else
+            op->Show();
+#endif
+        } else {
+            op = new MachineObjectPanel(m_scrolledWindow, wxID_ANY);
+            MachinePanel* mpanel = new MachinePanel();
+            mpanel->mIndex = wxString::Format("%d", i);
+            mpanel->mPanel = op;
+            m_user_list_machine_panel.push_back(mpanel);
+            m_sizer_my_devices->Add(op, 0, wxEXPAND, 0);
+        }
+        i++;
+        op->update_machine_info(mobj, true);
+        //set in lan
+        if (mobj->is_lan_mode_printer()) {
+            if (!mobj->is_online()) {
+                continue;
+            }
+            else {
+                op->show_printer_bind(false, PrinterBindState::NONE);
+                if (mobj->has_access_right() && mobj->is_avaliable()) {
+                    op->set_printer_state(PrinterState::IN_LAN);
+                    op->show_printer_bind(true, PrinterBindState::ALLOW_UNBIND);
+                    op->show_edit_printer_name(true);  // Enable editing for LAN devices with access
+                    op->SetToolTip(_L("Online"));
+                }
+                else {
+                    op->set_printer_state(PrinterState::LOCK);
+                    op->show_edit_printer_name(false);
+                }
+            }
+            op->Bind(EVT_UNBIND_MACHINE, [this, dev, mobj](wxCommandEvent& e) {
+                dev->set_selected_machine("");
+                if (mobj) {
+                    mobj->set_access_code("");
+                    mobj->erase_user_access_code();
+                }
+
+                if (GUI::wxGetApp().plater())
+                    GUI::wxGetApp().plater()->update_machine_sync_status();
+
+                MessageDialog msg_wingow(nullptr, _L("Log out successful."), "", wxAPPLY | wxOK);
+                if (msg_wingow.ShowModal() == wxOK) { return; }
+                });
+        }
+        else {
+            op->show_printer_bind(true, PrinterBindState::ALLOW_UNBIND);
+            op->Bind(EVT_UNBIND_MACHINE, [this, mobj, dev](wxCommandEvent& e) {
+                // show_unbind_dialog
+                UnBindMachineDialog dlg;
+                dlg.update_machine_info(mobj);
+                if (dlg.ShowModal() == wxID_OK) {
+                    dev->set_selected_machine("");
+                }
+                });
+
+            if (!mobj->is_online()) {
+                op->SetToolTip(_L("Offline"));
+                op->set_printer_state(PrinterState::OFFLINE);
+            }
+            else {
+                op->show_edit_printer_name(true);
+                op->show_printer_bind(true, PrinterBindState::ALLOW_UNBIND);
+                if (mobj->is_in_printing()) {
+                    op->SetToolTip(_L("Busy"));
+                    op->set_printer_state(PrinterState::BUSY);
+                }
+                else {
+                    op->SetToolTip(_L("Online"));
+                    op->set_printer_state(PrinterState::IDLE);
+                }
+            }
+        }
+
+        op->Bind(EVT_CONNECT_LAN_PRINT, [this, mobj](wxCommandEvent &e) {
+            if (mobj) {
+                if (mobj->is_lan_mode_printer()) {
+                    ConnectPrinterDialog dlg(wxGetApp().mainframe, wxID_ANY, _L("Input access code"));
+                    dlg.set_machine_object(mobj);
+                    if (dlg.ShowModal() == wxID_OK) {
+                        wxGetApp().mainframe->jump_to_monitor(mobj->get_dev_id());
+                    }
+                }
+            }
+        });
+
+         op->Bind(EVT_EDIT_PRINT_NAME, [this, mobj](wxCommandEvent &e) {
+            EditDevNameDialog dlg;
+            dlg.set_machine_obj(mobj);
+            dlg.ShowModal();
+         });
+    }
+
+    for (int j = i; j < m_user_list_machine_panel.size(); j++) {
+        m_user_list_machine_panel[j]->mPanel->update_machine_info(nullptr);
+        m_user_list_machine_panel[j]->mPanel->Hide();
+    }
+    //m_sizer_my_devices->Layout();
+
+    if (m_my_devices_count != i) {
+		m_scrolledWindow->Fit();
+    }
+    m_scrolledWindow->Layout();
+    m_scrolledWindow->Thaw();
+	Layout();
+	Fit();
+	this->Thaw();
+    m_my_devices_count = i;
+}
+
+bool SelectMachinePopup::search_for_printer(MachineObject* obj)
+{
+	const std::string& search_text = m_search_bar->GetValue().ToStdString();
+	if (search_text.empty()) {
+		return true;
+	}
+
+	const auto& name = wxString::FromUTF8(obj->get_dev_name()).ToStdString();
+    const auto& name_it = name.find(search_text);
+    if (name_it != std::string::npos) {
+        return true;
+    }
+
+#if !BBL_RELEASE_TO_PUBLIC
+    const auto& ip_it = obj->get_dev_ip().find(search_text);
+    if (ip_it != std::string::npos) {
+        return true;
+    }
+#endif
+
+    return false;
+}
+
+void SelectMachinePopup::on_dissmiss_win(wxCommandEvent &event)
+{
+    Dismiss();
+}
+
+void SelectMachinePopup::update_machine_list(wxCommandEvent &event)
+{
+    update_user_devices();
+    update_other_devices();
+    BOOST_LOG_TRIVIAL(trace) << "SelectMachinePopup update_machine_list end";
+}
+
+void SelectMachinePopup::start_ssdp(bool start)
+{
+    return;
+    //if (wxGetApp().getAgent()) { wxGetApp().getAgent()->start_discovery(true, start); }
+}
+
+void SelectMachinePopup::OnLeftUp(wxMouseEvent &event)
+{
+    auto mouse_pos = ClientToScreen(event.GetPosition());
+    auto wxscroll_win_pos = m_scrolledWindow->ClientToScreen(wxPoint(0, 0));
+
+    if (mouse_pos.x > wxscroll_win_pos.x && mouse_pos.y > wxscroll_win_pos.y && mouse_pos.x < (wxscroll_win_pos.x + m_scrolledWindow->GetSize().x) &&
+        mouse_pos.y < (wxscroll_win_pos.y + m_scrolledWindow->GetSize().y)) {
+
+        for (MachinePanel* p : m_user_list_machine_panel) {
+            auto p_rect = p->mPanel->ClientToScreen(wxPoint(0, 0));
+            if (mouse_pos.x > p_rect.x && mouse_pos.y > p_rect.y && mouse_pos.x < (p_rect.x + p->mPanel->GetSize().x) && mouse_pos.y < (p_rect.y + p->mPanel->GetSize().y)) {
+                wxMouseEvent event(wxEVT_LEFT_UP);
+                auto         tag_pos = p->mPanel->ScreenToClient(mouse_pos);
+                event.SetPosition(tag_pos);
+                event.SetEventObject(p->mPanel);
+                wxPostEvent(p->mPanel, event);
+            }
+        }
+
+        for (MachinePanel* p : m_other_list_machine_panel) {
+            auto p_rect = p->mPanel->ClientToScreen(wxPoint(0, 0));
+            if (mouse_pos.x > p_rect.x && mouse_pos.y > p_rect.y && mouse_pos.x < (p_rect.x + p->mPanel->GetSize().x) && mouse_pos.y < (p_rect.y + p->mPanel->GetSize().y)) {
+                wxMouseEvent event(wxEVT_LEFT_UP);
+                auto         tag_pos = p->mPanel->ScreenToClient(mouse_pos);
+                event.SetPosition(tag_pos);
+                event.SetEventObject(p->mPanel);
+                wxPostEvent(p->mPanel, event);
+            }
+        }
+
+        //pin code
+        auto pc_rect = m_panel_ping_code->ClientToScreen(wxPoint(0, 0));
+        if (mouse_pos.x > pc_rect.x && mouse_pos.y > pc_rect.y && mouse_pos.x < (pc_rect.x + m_panel_ping_code->GetSize().x) && mouse_pos.y < (pc_rect.y + m_panel_ping_code->GetSize().y)) {
+            wxGetApp().popup_ping_bind_dialog();
+        }
+
+        //bind with access code
+        auto dc_rect = m_panel_direct_connection->ClientToScreen(wxPoint(0, 0));
+        if (mouse_pos.x > dc_rect.x && mouse_pos.y > dc_rect.y && mouse_pos.x < (dc_rect.x + m_panel_direct_connection->GetSize().x) && mouse_pos.y < (dc_rect.y + m_panel_direct_connection->GetSize().y)) {
+            InputIpAddressDialog dlgo;
+            dlgo.ShowModal();
+        }
+
+        //hyper link
+        auto h_rect = m_hyperlink->ClientToScreen(wxPoint(0, 0));
+        if (mouse_pos.x > h_rect.x && mouse_pos.y > h_rect.y && mouse_pos.x < (h_rect.x + m_hyperlink->GetSize().x) && mouse_pos.y < (h_rect.y + m_hyperlink->GetSize().y)) {
+          wxLaunchDefaultBrowser(wxT("https://wiki.bambulab.com/en/software/bambu-studio/failed-to-connect-printer"));
+        }
+    }
+}
+
+EditDevNameDialog::EditDevNameDialog(Plater *plater /*= nullptr*/)
+    : DPIDialog(static_cast<wxWindow *>(wxGetApp().mainframe), wxID_ANY, _L("Modifying the device name"), wxDefaultPosition, wxDefaultSize, wxCAPTION | wxCLOSE_BOX)
+{
+    std::string icon_path = (boost::format("%1%/images/BambuStudioTitle.ico") % resources_dir()).str();
+    SetIcon(wxIcon(encode_path(icon_path.c_str()), wxBITMAP_TYPE_ICO));
+
+    SetBackgroundColour(*wxWHITE);
+    wxBoxSizer *m_sizer_main = new wxBoxSizer(wxVERTICAL);
+    auto        m_line_top   = new wxPanel(this, wxID_ANY, wxDefaultPosition, wxSize(-1, 1), wxTAB_TRAVERSAL);
+    m_line_top->SetBackgroundColour(wxColour(166, 169, 170));
+    m_sizer_main->Add(m_line_top, 0, wxEXPAND, 0);
+    m_sizer_main->Add(0, 0, 0, wxTOP, FromDIP(38));
+    m_textCtr = new ::TextInput(this, wxEmptyString, wxEmptyString, wxEmptyString, wxDefaultPosition, wxSize(FromDIP(260), FromDIP(40)), wxTE_PROCESS_ENTER);
+    m_textCtr->GetTextCtrl()->SetSize(wxSize(-1, FromDIP(22)));
+    m_textCtr->SetMinSize(wxSize(FromDIP(260), FromDIP(40)));
+    m_sizer_main->Add(m_textCtr, 0, wxALIGN_CENTER_HORIZONTAL | wxLEFT | wxRIGHT, FromDIP(40));
+
+    m_static_valid = new wxStaticText(this, wxID_ANY, wxT(""), wxDefaultPosition, wxDefaultSize, 0);
+    m_static_valid->Wrap(-1);
+    m_static_valid->SetFont(::Label::Body_13);
+    m_static_valid->SetForegroundColour(wxColour(255, 111, 0));
+    m_sizer_main->Add(m_static_valid, 0, wxALIGN_CENTER_HORIZONTAL | wxTOP | wxLEFT | wxRIGHT, FromDIP(10));
+
+
+    m_button_confirm = new Button(this, _L("Confirm"));
+    StateColor btn_bg_green(std::pair<wxColour, int>(wxColour(27, 136, 68), StateColor::Pressed), std::pair<wxColour, int>(wxColour(0, 174, 66), StateColor::Normal));
+    m_button_confirm->SetBackgroundColor(btn_bg_green);
+    m_button_confirm->SetBorderColor(wxColour(0, 174, 66));
+    m_button_confirm->SetTextColor(wxColour(255, 255, 255));
+    m_button_confirm->SetSize(wxSize(FromDIP(72), FromDIP(24)));
+    m_button_confirm->SetMinSize(wxSize(FromDIP(72), FromDIP(24)));
+    m_button_confirm->SetCornerRadius(FromDIP(12));
+    m_button_confirm->Bind(wxEVT_BUTTON, &EditDevNameDialog::on_edit_name, this);
+
+    m_sizer_main->Add(m_button_confirm, 0, wxALIGN_CENTER_HORIZONTAL | wxTOP, FromDIP(10));
+    m_sizer_main->Add(0, 0, 0, wxBOTTOM, FromDIP(38));
+
+    SetSizer(m_sizer_main);
+    Layout();
+    Fit();
+    Centre(wxBOTH);
+    wxGetApp().UpdateDlgDarkUI(this);
+}
+
+EditDevNameDialog::~EditDevNameDialog() {}
+
+void EditDevNameDialog::set_machine_obj(MachineObject *obj)
+{
+    m_info = obj;
+    if (m_info)
+        m_textCtr->GetTextCtrl()->SetValue(from_u8(m_info->get_dev_name()));
+}
+
+void EditDevNameDialog::on_dpi_changed(const wxRect &suggested_rect)
+{
+    m_button_confirm->SetSize(wxSize(FromDIP(72), FromDIP(24)));
+    m_button_confirm->SetMinSize(wxSize(FromDIP(72), FromDIP(24)));
+}
+
+void EditDevNameDialog::on_edit_name(wxCommandEvent &e)
+{
+    m_static_valid->SetLabel(wxEmptyString);
+    auto     m_valid_type = Valid;
+    wxString info_line;
+    auto     new_dev_name = m_textCtr->GetTextCtrl()->GetValue();
+
+    const char *      unusable_symbols = "<>[]:/\\|?*\"";
+    const std::string unusable_suffix  = PresetCollection::get_suffix_modified();
+
+    for (size_t i = 0; i < std::strlen(unusable_symbols); i++) {
+        if (new_dev_name.find_first_of(unusable_symbols[i]) != std::string::npos) {
+            info_line    = _L("Name is invalid;") + _L("illegal characters:") + " " + unusable_symbols;
+            m_valid_type = NoValid;
+            break;
+        }
+    }
+
+    if (m_valid_type == Valid && new_dev_name.find(unusable_suffix) != std::string::npos) {
+        info_line    = _L("Name is invalid;") + _L("illegal suffix:") + "\n\t" + from_u8(PresetCollection::get_suffix_modified());
+        m_valid_type = NoValid;
+    }
+
+    if (m_valid_type == Valid && new_dev_name.empty()) {
+        info_line    = _L("The name is not allowed to be empty.");
+        m_valid_type = NoValid;
+    }
+
+    if (m_valid_type == Valid && new_dev_name.find_first_of(' ') == 0) {
+        info_line    = _L("The name is not allowed to start with space character.");
+        m_valid_type = NoValid;
+    }
+
+    if (m_valid_type == Valid && new_dev_name.find_last_of(' ') == new_dev_name.length() - 1) {
+        info_line    = _L("The name is not allowed to end with space character.");
+        m_valid_type = NoValid;
+    }
+
+    if (m_valid_type == Valid && new_dev_name.length() > 32)
+    {
+        info_line    = _L("The name is not allowed to exceeds 32 characters.");
+        m_valid_type = NoValid;
+    }
+
+    if (m_valid_type == NoValid) {
+        m_static_valid->SetLabel(info_line);
+        m_static_valid->Wrap(m_static_valid->GetSize().GetWidth());
+        Layout();
+    }
+
+    if (m_valid_type == Valid) {
+        m_static_valid->SetLabel(wxEmptyString);
+        DeviceManager *dev      = Slic3r::GUI::wxGetApp().getDeviceManager();
+        if (dev) {
+            auto           utf8_str = new_dev_name.ToUTF8();
+            auto           name     = std::string(utf8_str.data(), utf8_str.length());
+            if (m_info)
+                dev->modify_device_name(m_info->get_dev_id(), name);
+        }
+        DPIDialog::EndModal(wxID_CLOSE);
+    }
+}
+
+PinCodePanel::PinCodePanel(wxWindow* parent, int type, wxWindowID winid /*= wxID_ANY*/, const wxPoint& pos /*= wxDefaultPosition*/, const wxSize& size /*= wxDefaultSize*/)
+ {
+     wxPanel::Create(parent, winid, pos);
+     Bind(wxEVT_PAINT, &PinCodePanel::OnPaint, this);
+     SetSize(SELECT_MACHINE_ITEM_SIZE);
+     SetMaxSize(SELECT_MACHINE_ITEM_SIZE);
+     SetMinSize(SELECT_MACHINE_ITEM_SIZE);
+
+     m_type = type;
+     this->Bind(wxEVT_ENTER_WINDOW, &PinCodePanel::on_mouse_enter, this);
+     this->Bind(wxEVT_LEAVE_WINDOW, &PinCodePanel::on_mouse_leave, this);
+     this->Bind(wxEVT_LEFT_UP, &PinCodePanel::on_mouse_left_up, this);
+ }
+
+ void PinCodePanel::OnPaint(wxPaintEvent& event)
+ {
+     wxPaintDC dc(this);
+     render(dc);
+ }
+
+ void PinCodePanel::render(wxDC& dc)
+ {
+#ifdef __WXMSW__
+     wxSize     size = GetSize();
+     wxMemoryDC memdc;
+     wxBitmap   bmp(size.x, size.y);
+     memdc.SelectObject(bmp);
+     memdc.Blit({ 0, 0 }, size, &dc, { 0, 0 });
+
+     {
+         wxGCDC dc2(memdc);
+         doRender(dc2);
+     }
+
+     memdc.SelectObject(wxNullBitmap);
+     dc.DrawBitmap(bmp, 0, 0);
+#else
+     doRender(dc);
+#endif
+ }
+
+ void PinCodePanel::doRender(wxDC& dc)
+ {
+     auto size = GetSize();
+
+     //m_bitmap = ScalableBitmap(this, "bind_device_ping_code",10);
+
+     m_bitmap = ScalableBitmap(this, wxGetApp().dark_mode() ? "bind_device_ping_code_dark" : "bind_device_ping_code_light", 10);
+
+     dc.DrawBitmap(m_bitmap.bmp(), wxPoint(FromDIP(12), (size.y - m_bitmap.GetBmpSize().y) / 2));
+     dc.SetFont(::Label::Head_13);
+     dc.SetTextForeground(StateColor::darkModeColorFor(SELECT_MACHINE_GREY900));
+     wxString txt;
+     if (m_type == 0) {txt = _L("Bind with Pin Code");}
+     else if (m_type == 1) {txt = _L("Bind with Access Code");}
+
+     WxFontUtils::get_suitable_font_size(0.5 * size.GetHeight(), dc);
+     auto txt_size = dc.GetTextExtent(txt);
+     dc.DrawText(txt, wxPoint(FromDIP(28), (size.y - txt_size.y) / 2));
+
+     if (m_hover) {
+         dc.SetPen(SELECT_MACHINE_BRAND);
+         dc.SetBrush(*wxTRANSPARENT_BRUSH);
+         dc.DrawRectangle(0, 0, size.x, size.y);
+     }
+ }
+
+ void PinCodePanel::on_mouse_enter(wxMouseEvent& evt)
+ {
+     m_hover = true;
+     Refresh();
+ }
+
+ void PinCodePanel::on_mouse_leave(wxMouseEvent& evt)
+ {
+     m_hover = false;
+     Refresh();
+ }
+
+ void PinCodePanel::on_mouse_left_up(wxMouseEvent& evt)
+ {
+     if (m_type == 0) {
+        if (wxGetApp().getAgent() && wxGetApp().getAgent()->is_user_login()){
+             wxGetApp().popup_ping_bind_dialog();
+         }
+         else{
+             auto m_confirm_login_dlg = new SecondaryCheckDialog(nullptr, wxID_ANY, _L("Bind with Pin Code"), SecondaryCheckDialog::ButtonStyle::ONLY_CONFIRM, wxDefaultPosition);
+             m_confirm_login_dlg->SetSize(wxSize(FromDIP(270), FromDIP(158)));
+             m_confirm_login_dlg->update_text(_L("Please log in before binding your device with a PIN code.\nAlternatively, you can use LAN mode to bind your device. Learn about LAN mode."));
+             m_confirm_login_dlg->update_btn_label(_L("Go to Login"), _L(""));
+             m_confirm_login_dlg->Bind(EVT_SECONDARY_CHECK_CONFIRM, [this](wxCommandEvent& e) {
+                 //m_confirm_login_dlg->on_hide();
+                 wxGetApp().request_login();
+                 return;
+                 });
+             m_confirm_login_dlg->on_show();
+         }
+     }
+     else if (m_type == 1) {
+         InputIpAddressDialog dlgo;
+         dlgo.ShowModal();
+     }
+ }
+
+ }} // namespace Slic3r::GUI
-- 
2.43.0.windows.1

